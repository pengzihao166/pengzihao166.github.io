<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2107的小崽子们</title>
    <url>/2021/12/01/2107%E7%9A%84%E5%B0%8F%E5%B4%BD%E5%AD%90%E4%BB%AC/</url>
    <content><![CDATA[<h3 id="Hello，大家好啊，我是小八"><a href="#Hello，大家好啊，我是小八" class="headerlink" title="Hello，大家好啊，我是小八"></a>Hello，大家好啊，我是小八</h3><span id="more"></span>
<p>&ensp;&ensp;最近在学计组，实在不想学了，今天咱不谈学习，本学期临近期末，就来写一篇博客来回忆一下本学期的时光，来缓解一下心情吧。</p>
<p>&ensp;&ensp;咳咳咳，那就从大一下的暑假开始说起吧，没错，就在上学期，我很荣幸的被选成21级新生小班助，虽然当时的我并不知道我带的是哪个班，更不知道你们一个个“小兔崽子”长啥样，更别说你们会不会到时候惹我生气，但是我当时真的还是很开心，当时当上小班助，还特意发了个朋友圈庆祝一下：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/banzhu.jpg?versionId=CAEQFxiBgICXuoTX6xciIDZkNjkyMGU5NmQ3ZDRkYWVhNjdmZjA2YTU2ZTlhNWM5" alt="banzhu"></p>
<h3 id="ensp-ensp-2021-8-09-19-31"><a href="#ensp-ensp-2021-8-09-19-31" class="headerlink" title="&ensp;&ensp;2021-8-09 19:31"></a>&ensp;&ensp;2021-8-09 19:31</h3><p>&ensp;&ensp;我收到了班助分配通知，很荣幸成为了大类2107班的小班助，和你们的大班助杨姐姐一起共事，那天晚上，我们班助也就开始进行新生迎新工作了。</p>
<h3 id="ensp-ensp-2021-8-12-21-48"><a href="#ensp-ensp-2021-8-12-21-48" class="headerlink" title="&ensp;&ensp;2021-8-12 21:48"></a>&ensp;&ensp;2021-8-12 21:48</h3><p>&ensp;&ensp;老师发给我们你们的联系方式，要求我们通过联系方式通知你们一个个进入班级通知群和聊天群，虽然我和大班助打电话的时候，还被部分家长当成过诈骗电话，但是觉得还是挺有意义的，hhhhhhhh，想起来这里就挺搞笑的，不过最后在辅导员的努力下，你们还是顺利进到了2107班这个新的大集体。</p>
<h3 id="ensp-ensp-2021-8-20-——2021-9-11"><a href="#ensp-ensp-2021-8-20-——2021-9-11" class="headerlink" title="&ensp;&ensp;2021-8-20 ——2021-9-11"></a>&ensp;&ensp;2021-8-20 ——2021-9-11</h3><p>&ensp;&ensp;身为班助的我还有大班助杨姐姐，为了你们能顺利开学，根据当时学校的疫情返校规定，每天都一日三次在通知群提醒你们进行完美校园的健康打卡，中途杨姐姐和我想让你们在QQ聊天群里活跃起来，想尽了一切办法，把隔壁班的班助都拉进来了，一直在那里水群，想着带动你们一起来说说话，讨论一下你们对大学的看法，水着水着还是那几个“老油条”在里面水群，好家伙，好像并没啥用，可能是我活跃气氛的能力不行吧，要是下次还能当你们班助，我一定会尽力去学一下怎么带动你们。</p>
<p>&ensp;&ensp;有一说一，你们在还没有进学校的时候，有很多人，加了我的好友，然后问我计算机怎么入门，当时的我，真的就在想，好家伙，一个个的都这么卷的吗，不在群里聊天，在这里问我怎么学习，当然当时能告诉你们怎么入门，我真的感到很荣幸，毕竟我自己一直也是一个菜鸟。那时候还记得我们班的有些人经常问我c语言的题目，但是当时我也在自学Java，回消息就比较慢，希望你们能体谅一下，诶嘿嘿嘿。你看看你们内卷的时候，是多么恐怖：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/suanfa.png?versionId=CAEQFxiBgID8uITX6xciIGYyMDU3MjBkY2U1OTQ5NmM5ZmM0NGY4NmJiZjE5YmI4" alt="neijuan"></p>
<p>&ensp;&ensp;不过你们真的很优秀，我当时要大一这么有觉悟，也不至于现在还这么菜了（来自小八的自嘲）。</p>
<h3 id="2021-9-11-——-2021-9-30"><a href="#2021-9-11-——-2021-9-30" class="headerlink" title="2021-9-11 —— 2021-9.30"></a>2021-9-11 —— 2021-9.30</h3><p>&ensp;&ensp;这段时间是你们最快乐的时候吧，我觉得你们挺快乐的，就前几天军训你们训练比较累，后面就感觉你们教官还是对你们太好了，这段时间，因为害怕你们军训时会晕倒，我们七八班的班助每天都是轮换制去陪着你们军训，要是有课都会请假去陪你们，看你们晒太阳，hhhhhhhhh，不过我不知道为什么，我好像没怎么晒太阳，咋也黑了好几个度，就挺离谱的，到现在我还是很黑。</p>
<p>&ensp;&ensp;有一说一哈，那一个月真的很快很快，我都感觉像在昨天一样，虽然跟你们接触的时间很短，但是，我和大班助，真的就像把你们当做自己的弟弟妹妹来对待的。</p>
<p>&ensp;&ensp;还记得，在军训期间的第一次晚自习，我们七八班的班助请你们喝奶茶，你们很多人都发了QQ空间，在中秋晚会的时候，为你们准备中秋的零食，虽然那天我不在场（我去陪谁了，你们懂的），但是我的心还是跟你们在一起的。当时，我还记得有几个“小崽子”进了方阵队，甚至有人进了国旗队，你们真的很了不起，为自己班上争了很多光，我身为班助也很开心啊。最后结束军训的那天，我们班也有了一张在军训期间的第n张大合影，（当时大班助在上课，没有及时赶到，挺遗憾的）。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/2107.jpg?versionId=CAEQFxiBgIDKvITX6xciIDEyOWRmNjg4MzBkZTQ1MTY4YzBlNjJkM2FkNzExOTVk" alt="2107"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/21071.jpg?versionId=CAEQFxiBgIDYuYTX6xciIGI4YThiMzg5NzRjOTQwMmVhMmQxMzU4ZTQxMzI2N2Rl" alt="21071"></p>
<h3 id="2021-9-30-——-现在"><a href="#2021-9-30-——-现在" class="headerlink" title="2021-9-30 —— 现在"></a>2021-9-30 —— 现在</h3><p>&ensp;&ensp;你们终于结束了军训，9-30当天，我们也相应选出了属于自己班的班委，这个时候也就意味着，班助差不多要撒手交给你们自己来管理好这个大集体了，但这并不意味着我们的缘分就此结束，我们在学校肯定也会有很多遇到的时候，说到这里，我觉得我们班的崽子真的很讲礼貌，每次看到我，都会主动跟我打招呼。</p>
<p>&ensp;&ensp;2021-10-1，迎来了你们在大学的第一个小长假，虽然因为疫情，你们哪都不能去，你们也很懂事，非特殊情况的人都乖乖留在了株洲，没有私自外出，这点真的做的很好，当时也很感谢你们和家长的支持和谅解.</p>
<p>&ensp;&ensp;在国庆之后，我们也和八班这个大集体一起进行了团建，那天因为临时有点私事，也没有及时赶到，不好意思哈。后面你们组织篮球队，很积极参加了学院新生杯的篮球赛，在三场淘汰赛中均以大比分战胜对手，进入八强，虽然最后那天在八强赛，你们下半场状态有点下滑，以一分之差输给了对手，但是你们真的已经很棒了。我想对你们说“七班一直都很牛逼！！！”</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/lanqiu.jpg?versionId=CAEQFxiBgIDPuYTX6xciIDQ2MWYxNGM1MDczYjQ2YjU5YmI5ZTk2NDlkYzJmMDZl" alt="lanqiu"></p>
<p>&ensp;&ensp;最后小助想对你们说：“大学嘛，是一个新的开始，希望你们在这已经过去的几个月，早已丢掉了初来乍到时的迷茫、焦虑、失望、堕落，而是找到了自己的生活方式和学习方式，记住，在大学，不要在任何东西面前失去自我，哪怕是别人的目光，哪怕是别人对你感情的插手，就是希望你们都能拥有自由而有趣的灵魂，很荣幸能和你们一起在2107共同战斗过，以后有啥需要帮助的，小助也随时可以给你们提供帮助，希望你们在大一的一年中能够带着稚气、迷惑和理想，完成你们曾在大学许下的梦！！！最重要的就是，千万别挂科，才能有可能选到自己想选的专业，当初这件事，我在班会上面也给你们强调过很多次，也就不多说了。加油加油！！！”</p>
<p>&ensp;&ensp; 好了，差不多回忆完了，我要去学习了，今天的分享就到此结束吧。</p>
 <p align="right">———————————你们的小班助-小八</p>]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 backing</title>
    <url>/2022/01/01/2021-backing/</url>
    <content><![CDATA[<h2 id="回首2021"><a href="#回首2021" class="headerlink" title="回首2021"></a>回首2021</h2><p>大家好，我是小八，是一名HUT的大二在校本科生，今天写一篇博客来说说2021我的成长之旅吧。</p>
<h3 id="2021年上半年（大一下学期）"><a href="#2021年上半年（大一下学期）" class="headerlink" title="2021年上半年（大一下学期）"></a>2021年上半年（大一下学期）</h3><h4 id="2021-1-1"><a href="#2021-1-1" class="headerlink" title="2021.1.1"></a>2021.1.1</h4><p>大病初愈的我，和我好兄弟们跨过了第二个大学元旦，也抓到了2021年的第一个娃娃，而这也是我新的一年的开始，那时候的我也才大一下学期，对未来也只是仅仅抱着幻想，但仍然十分的迷茫和无奈。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/20210101.jpg?versionId=CAEQGRiBgMDPtKvZ8BciIDhiZWMwZDEyYTRjODRjMjk5YTc3NTcxZWJkY2FiMmQy" alt="20210101"></p>
<h4 id="2021-1-1—2021-3-13"><a href="#2021-1-1—2021-3-13" class="headerlink" title="2021.1.1—2021.3.13"></a>2021.1.1—2021.3.13</h4><p>这段时间，没错正如我所说的，非常迷茫、无知，天天除了打游戏，打篮球，和好兄弟们一起在外面狂嗨等，也没啥事干，可以说是天天无所事事，天天在学校混世度日，虽然我的综合成绩排名在年级也混得过去，不算很差（年级几十名吧），但真的算不上优秀。</p>
<p>可是当时的我真的不知道去干嘛，但应该去做一些什么有意义的事情。</p>
<h4 id="2021-3-14"><a href="#2021-3-14" class="headerlink" title="2021.3.14"></a>2021.3.14</h4><p>我遇到了我生命中除了亲朋好友之外最喜欢的人——那个她，在这一天，我们官宣了，实际上我们当时2021.3.12号就在一起了，我在那之后的每一周周末都会去陪着我喜欢的人，一起开心的玩耍，当时我以为，这样的我，算是走出了一点点的迷茫大学生涯，其实我还是一个迷茫的憨批。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/20210314.jpg?versionId=CAEQGRiBgMDZtKvZ8BciIGUxODM4YTRiMThlMjQwNWE5MTUwMDA3OTRjOWNjMzJh" alt="20210314"></p>
<h4 id="2021-3-27"><a href="#2021-3-27" class="headerlink" title="2021.3.27"></a>2021.3.27</h4><p>这一天，我真的可以说是上天给我了一个莫名的惊喜，我肯定要好好把握住这一个很好的机会，毕竟我当时也意识到了自己的迷茫，而这也算是人生中的一次转折点吧，很高兴遇到了这个学长，有一说一，我和他的大学经历，真的很像，因为他给的这个机会，我真的有了很大的改变，也就有了后面很大的学习动力和进步，但是这也需要付出一定的代价。那时候，我也便开始了我的java学习之旅。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/202103271.png?versionId=CAEQGRiBgICktKvZ8BciIDhjNTdhNzFhNDIxNzQzMmFiZGY1YTU2NjE2MzAwOWRm" alt="20210327 1"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/202103272.png?versionId=CAEQGRiBgICdtKvZ8BciIDMzNjVlZjI2MDA4ODRhNjNiODc4MjQ3ODRmNzk1MWIy" alt="20210327 2"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/202103273.png?versionId=CAEQGRiBgMCntKvZ8BciIDcwYmE5MTc5Yjk2NjQ2YzA4M2Q0YTM1MGIxZTU5ZDk3" alt="20210327 3"></p>
<p>可是好景不长，果然我要付出的代价来了，我和我的好兄弟，也因为这个，渐渐减少了和他们一起聚会，一起快乐，一起玩耍，一起做我们大学生想做的事情，想想真的挺烦的，但是也没有办法，说点自私的，我也是在为自己的未来奋斗，毕竟我实力有限，我也只能独自前行，不能带着他们一起进步。</p>
<p>虽说后悔，但是我也无法后退，既然踏出了那一步，我只能看好当下，而不是留在过去，只想着能够在自己变优秀之后，慢慢再带着他们一起变优秀，一起在大学留下属于自己的足迹。</p>
<h4 id="2021-6月"><a href="#2021-6月" class="headerlink" title="2021.6月"></a>2021.6月</h4><p>我们学院为了迎接新生，辅导员需要在19级和20级学生里面选一部分同学当大小班助，为21级新生的到来提供我们力所能及的帮助，并为他们解决进入大学之后的迷茫，无知。可是在我看来，其实当时的我，也顶多只是比21级新生多了一点点“如何在大学生存下去”的生活常识？</p>
<p>但是我想着这也是一次锻炼自己的机会，我当然不想放弃，果断下定决心，参加这一次的选拔，记得当时报名的人有一百来个吧，我也不知道能不能选上，单纯就抱着一个尝试的心理去面试了，没想到当时真的通过了老师和各个主席的认同，当上了2107班的小班助。</p>
<p>在得到这次机会之后，也是临近放假的时候，当时就在想，当上了小班助可得懂得更多一点，那这暑假更不能闲着了，得好好学学还没有学完的java了，到时候可不能比大部分新生差啊。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/20216.jpg?versionId=CAEQGRiBgICptKvZ8BciIDhjZjdhYzU4NmJlODQ0MGRhM2UzY2M1ZTNiMmE1YzQ1" alt="20216"></p>
<h3 id="2021下半年（大二上学期）"><a href="#2021下半年（大二上学期）" class="headerlink" title="2021下半年（大二上学期）"></a>2021下半年（大二上学期）</h3><h4 id="2021-7-10月"><a href="#2021-7-10月" class="headerlink" title="2021.7-10月"></a>2021.7-10月</h4><p>这是我和她吵架高峰期，因为学习和班助工作，真的少了很多时间对她的陪伴，这段时间，我尽量不把自己的心情影响到身边人，不想因为周围的人被我的心情影响到，我只能努力忍着自己随时可能爆发的情绪，每天照常如故对待身边的人，先把自己感情的事情放在一边，做好自己身为班助应该做的工作。</p>
<p>可以说，我算得上是一个合格的班助吧，但算不上一个合格的男朋友，那段时间居然还有人在外面传言说我分手了，真的听到了我都笑了，对这些人挺够无语的。</p>
<p>迎新工作开始，而我也陷入了学习java和迎新的工作之中，在迎新的过程中，当时还立了好几个flag，要学好java其他相关的技术，比如：MySQL、ssm框架、spring boot、spring cloud等等。</p>
<p>当时的我真的觉得，自己会在暑假干好上面的flag，但事与愿违，自制力还是不够，仅仅只是学完了java基础部分和很浅的了解了一下java的ssm框架，终究还是败给了懒惰。</p>
<p>大二正式开学之后，因为有了新的课程学习，自然没有暑假那么多时间学习java更多的知识了，而且当上了小班助，为了防止他们军训时发生什么事故，请了很多节课假，选择陪他们一起军训，java的学习进度也就减慢了很多。</p>
<p>到了十月份，我基本放下了班助的工作，那时候，我不知道为什么，再次陷入了学习的迷茫之中，那段时间，我感觉我学了java，但是毫无用处，对java的框架学习也比较反感，那时候我还想着要不要转iOS开发呢？</p>
<p>带着这个疑惑，突然想起了那个学长，便去咨询了他，我在这种迷茫的时候，到底应该怎么办，我该怎么做？后来在和他的聊天过程中发现，不是我对java彻底失去兴趣，也不是我不适合学习java，只是暂时的失去了对它的兴趣，这算是一种叫做“递减效应”的心理效应吧。他当时推荐我去学学前端，写写网页后面再去转向后端，用前端来做一个跳板，像后端再去慢慢转换。</p>
<p>在他的建议下，我很快入手了前端，毕竟web前端的核心js的学习，其实跟java十分相似，自然上手就很快。</p>
<h4 id="2021-11"><a href="#2021-11" class="headerlink" title="2021.11"></a>2021.11</h4><p>这一个月怎么说呢，有快乐也有伤心吧，快乐就是我得到了学长的认可，有不开心的事情，也可以跟学长分享，并且他能在闲暇的时候帮我解决，伤心的是我失去了很多，少了很多时间给她，少了和兄弟们当初的快乐。陪她的时间越来越少，我们之间的争吵也越来越多，可是我当初也是想着做这个项目，能够好好带着她一起去她想去的城市，也算是为未来打拼奋斗，虽然以后我可能不是一个Winner，但我不想做一个未来的Loser。</p>
<h5 id="2021-11-24-9-34"><a href="#2021-11-24-9-34" class="headerlink" title="2021.11.24 9:34"></a>2021.11.24 9:34</h5><p>那个学长给我发了一条微信，询问我是否愿意来一起和他一起做项目，我当时收到这条消息，真的乐开了花，多的不说，机会是自己把握的，当机立断就答应了，毕竟我觉得，不管最终结果如何，我相信我一定能学到很多东西，学到在学校学不到的东西，慢慢摆脱在大学的迷茫和无知。</p>
<h4 id="2021-12"><a href="#2021-12" class="headerlink" title="2021.12"></a>2021.12</h4><p>我在学长的学习路线下，慢慢学会了怎样使用Git、HEXO、Node.js、前端等等开发技术，在慢慢学习了计网、计组等基础知识。</p>
<p>我还记得，我当时为了学习，经常熬夜到晚上一两点，前面的好几篇blog，也是在那段时间写出来的。有兴趣的可以去看看“<a href="https://pengzihao166.work/2021/11/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">小八学习git从0到基本运用</a>”，“<a href="https://pengzihao166.work/2021/11/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Git%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">自学如何使用Git+Hexo搭建个人博客</a>”。</p>
<p>真的很喜欢一句话，<strong>“没有人会因为你熬到两三点就心疼你，也没有人会在乎你在熬什么，你只需要知道你自己在奋斗”</strong>。</p>
<p>这个月我也便在学习新知识和期末备考中度过了，过得算不上很“大学生”。而我的一年差不多也就这么过去了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说了这么多，有了很多的失去，也有很多的收获，多的不说，送给大家一句话，<strong>看好当下，跳向未来吧</strong>。做好自己2022立下的flag，加油加油，冲冲冲，也希望我身边的人能够快快乐乐，成为自己想成为的人！！！</p>
<p>你好，这里是小八，一个专门分享学习经验和经历的菜鸟。</p>
]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker使用</title>
    <url>/2023/05/29/Docker%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h2><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230529235020493.png" alt="image-20230529235020493"></p>
<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul>
<li>docker images</li>
</ul>
<blockquote>
<p>罗列出docker的所有的镜像相关信息</p>
</blockquote>
<ul>
<li>docker search 某个xxx镜像的名字</li>
</ul>
<blockquote>
<p>在hub仓库查询是否有相关的镜像 –limit 默认罗列前25个</p>
</blockquote>
<ul>
<li>docker pull 某个xxx镜像名[:tag]</li>
</ul>
<blockquote>
<p>tag:表示版本号    </p>
</blockquote>
<ul>
<li><p>docker system df 查看镜像/容器/数据卷所占空间</p>
</li>
<li><p>docker rmi 某个xxx镜像的id或者名字  -f强制删除</p>
<blockquote>
<p>docker rmi hello-world 或 docker rmi 9c7a54a9a43c<br>删除多个:</p>
<pre><code>docker rmi -f 镜像名1:tag 镜像名2:tag....
docker rmi -f $(docker images -qa)
</code></pre>
</blockquote>
<p>什么叫虚悬镜像？</p>
<p>仓库名、标签都是<none>的，俗称虚悬镜像，通常会把他删掉</none></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2023/02/01/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Java基础（一）"><a href="#Java基础（一）" class="headerlink" title="Java基础（一）"></a>Java基础（一）</h2><h3 id="Java语言的特点："><a href="#Java语言的特点：" class="headerlink" title="Java语言的特点："></a>Java语言的特点：</h3><ul>
<li>简单易学</li>
<li>面向对象（封装、继承、多态）</li>
<li>平台无关性（Java虚拟机实现平台无关性）</li>
<li>支持多线程</li>
<li>可靠性</li>
<li>安全性</li>
<li>支持网络编程并且很方便</li>
<li>编译与解释并存</li>
</ul>
<h3 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a>什么是字节码？采用字节码的好处是什么？</h3><p>JVM可以理解的代码就是字节码（扩展名.class文件），JVM解释器进行对字节码的解释比较慢、引入了JIT编译器，JIT属于运行时编译，当JIT编译完成第一次编译之后，热点代码和方法的字节码对应机器码会被保存下来，下次可以直接进行使用，而不需要再次被解释器进行解释。</p>
<p>好处：</p>
<ul>
<li>面向虚拟机，不面向任何特定的处理器</li>
<li>通过字节码的方式，在一定程度上解决了传统解释性语言执行效率低的问题，同时又保留了解释型语言可移植的特点</li>
<li>字节码不针对某一特定机器，所以Java不需要重新编译就可以在不同的操作系统的计算机运行。</li>
</ul>
<h3 id="Java源码一次编写，为啥能到处运行？"><a href="#Java源码一次编写，为啥能到处运行？" class="headerlink" title="Java源码一次编写，为啥能到处运行？"></a>Java源码一次编写，为啥能到处运行？</h3><p>&emsp;JVM（Java虚拟机）是关键原因。</p>
<p>&emsp;<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230204194523252.png" alt="image-20230204194523252"></p>
<blockquote>
<p>注意：Java程序是跨平台的程序、JVM是C/C++开发的软件，不同平台下的JVM版本不一样</p>
</blockquote>
<h3 id="为什么说Java语言“编译与解释并存”？"><a href="#为什么说Java语言“编译与解释并存”？" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h3><blockquote>
<p><strong>编译型：</strong>编译型语言可以通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较开，开发效率比较低，常见的编译型语言就是C、C++、GO等</p>
<p><strong>解释型：</strong>通过解释器将代码一句句解释成机器代码，解释型语言开发快，执行速度慢，常见的解释型语言就是PHP、Python、JavaScript等。</p>
</blockquote>
<p>&ensp;因为Java要先通过javac编译器将程序编译成字节码(.class文件)，然后通过Java解释器来解释执行。</p>
<h3 id="一个Java程序可包含多个类吗？（内部类除外）"><a href="#一个Java程序可包含多个类吗？（内部类除外）" class="headerlink" title="一个Java程序可包含多个类吗？（内部类除外）"></a>一个Java程序可包含多个类吗？（内部类除外）</h3><p>&emsp;可以包含多个类，但是被public修饰的类只有一个，且被public修饰的这个类必须跟类文件名同名</p>
<h3 id="Java的访问权限：private、protected、default、public"><a href="#Java的访问权限：private、protected、default、public" class="headerlink" title="Java的访问权限：private、protected、default、public"></a>Java的访问权限：private、protected、default、public</h3><p>&emsp;private &lt; default &lt; protected &lt; public：从左到右权限依次变大</p>
<p>&emsp;对成员变量/成员方法而言：</p>
<p>&emsp;&emsp;1、private：仅限该类内部成员访问</p>
<p>&emsp;&emsp;2、default：同包下的其他类成员以及该类内部成员可以访问</p>
<p>&emsp;&emsp;3、protected：同包下的其他类成员、该类内部成员、以及子类可以访问。</p>
<p>&emsp;&emsp;4、public：任意包下的任意类的成员均可访问。</p>
<p>&emsp;修饰类时，仅有default、public两种修饰符：</p>
<p>&emsp;&emsp;1、default：同包下的其他类可以访问</p>
<p>&emsp;&emsp;2、public：任意包下的任意类可以访问</p>
<blockquote>
<p>注：没有任何修饰符修饰，默认为default</p>
</blockquote>
<h3 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h3><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230204213714958.png" alt="image-20230204213714958"></p>
<p>byte(1 byte = 8 bits)&emsp;&emsp;&emsp;&emsp;&emsp;short(2 byte = 16 bits)&emsp;&emsp;&emsp;&emsp;&emsp;int(4 byte = 32 bits)&emsp;&emsp;&emsp;&emsp;&emsp;long(8 byte = 64 bits)</p>
<p>float(4 byte = 32 bits)&emsp;&emsp;&emsp;&emsp;double(8 byte = 64bits)&emsp;&emsp;&emsp;&emsp;&emsp;char(2byte = 16bits)&emsp;&emsp;&emsp;&emsp;&emsp;boolean(根据Java规范规定，不同JVM实现机制不同)</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>关键字</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>访问控制</td>
<td>private</td>
<td>protected</td>
<td>public</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>类、方法和变量修饰符</td>
<td>abstract</td>
<td>class</td>
<td>extends</td>
<td>final</td>
<td>implements</td>
<td>interface</td>
<td>native</td>
</tr>
<tr>
<td></td>
<td>new</td>
<td>static</td>
<td>strictfp</td>
<td>synchronized</td>
<td>transient</td>
<td>volatile</td>
<td>enum</td>
</tr>
<tr>
<td>程序控制</td>
<td>break</td>
<td>continue</td>
<td>return</td>
<td>do</td>
<td>while</td>
<td>if</td>
<td>else</td>
</tr>
<tr>
<td></td>
<td>for</td>
<td>instanceof</td>
<td>switch</td>
<td>case</td>
<td>default</td>
<td>assert</td>
<td></td>
</tr>
<tr>
<td>错误处理</td>
<td>try</td>
<td>catch</td>
<td>throw</td>
<td>throws</td>
<td>finally</td>
<td></td>
<td></td>
</tr>
<tr>
<td>包相关</td>
<td>import</td>
<td>package</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean</td>
<td>byte</td>
<td>char</td>
<td>double</td>
<td>float</td>
<td>int</td>
<td>long</td>
</tr>
<tr>
<td></td>
<td>short</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>变量引用</td>
<td>super</td>
<td>this</td>
<td>void</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>保留字</td>
<td>goto</td>
<td>const</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p>
<ul>
<li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li>
<li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li>
<li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li>
</ul>
</blockquote>
<h3 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h3><p>这个需要结合 JVM 的相关知识，主要原因如下：</p>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><p><strong>1、调用方式</strong></p>
<p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p>
<p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p>
<p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staicMethod</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 调用实例方法</span></span><br><span class="line">        person.method();</span><br><span class="line">        <span class="comment">// 调用静态方法</span></span><br><span class="line">        Person.staicMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、访问类成员是否存在限制</strong></p>
<p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
<h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><ul>
<li>成员变量包装类型不赋值就<strong>是 <code>null</code></strong> ，而基本类型**有默认值且不是 <code>null</code>**。</li>
<li>包装类型可用于泛型，而基本类型不可以。</li>
<li>基本数据类型的<strong>局部变量</strong>存放在 Java 虚拟机<strong>栈</strong>中的局部变量表中，基本数据类型的<strong>成员变量（未被 <code>static</code> 修饰 ）</strong>存放在 Java 虚拟机的<strong>堆</strong>中。包装类型属于对象类型，我们知道<strong>几乎所有对象实例都存在于堆中</strong>。</li>
<li>相比于对象类型， 基本数据类型占用的空间非常小。</li>
</ul>
<p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p>
<p>⚠️ 注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果<strong>没有</strong>被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicTypeVar</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆区、栈区、方法区的区别："><a href="#堆区、栈区、方法区的区别：" class="headerlink" title="堆区、栈区、方法区的区别："></a>堆区、栈区、方法区的区别：</h3><p><strong>堆区:</strong> </p>
<p>1、存储的全部是对象 ，每个对象都包含一个与之对应的Class的信息。(Class的目的是得到操作指令) </p>
<p>2、JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 ，即实例对象</p>
<p><strong>栈区:</strong> </p>
<p>1、每个线程包含一个栈区 ，栈中 只保存基础数据类型的对象和自定义对象的引用(不是对象) ，对象都存放在堆区中 </p>
<p>2、每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问 。 </p>
<p>3、栈分为3个部分： 基本类型变量区、执行环境上下文、操作指令区(存放操作指令) 。 </p>
<p><strong>方法区:</strong> </p>
<p>1、又叫 静态区 ，跟堆一样， 被所有的线程共享 。方法区 包含所有的Class和static变量 。</p>
<p>2、方法区中包含的都是在整个程序中永远唯一的元素，如Class，static变量。</p>
<h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h3><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p><strong>Integer 缓存源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Character</code> 缓存源码:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>Boolean</code> 缓存源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p>
<p><strong>OS:所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>
<h3 id="自动拆箱和自动装箱，原理是什么？"><a href="#自动拆箱和自动装箱，原理是什么？" class="headerlink" title="自动拆箱和自动装箱，原理是什么？"></a>自动拆箱和自动装箱，原理是什么？</h3><ul>
<li>拆箱：将包装类型转换成基本数据类型</li>
<li>装箱：将基本数据类型用对应的引用类型（包装类型）包装起来</li>
</ul>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p>对应的字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure>

<p>装箱其实就是调用了包装类的<strong>valueOf()<strong>方法，</strong>拆箱</strong>其实就是调用了**xxxValue()**方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; =====&gt; <span class="type">Integer</span>  <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>)</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;  ======&gt;  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot开发规范(二)</title>
    <url>/2023/02/04/SpringBoot%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="PO即persistant-Object-持久对象："><a href="#PO即persistant-Object-持久对象：" class="headerlink" title="PO即persistant Object 持久对象："></a><strong>PO即persistant Object 持久对象：</strong></h3><p>&emsp;在O/R 映射（即ORM-ObjectRelationMapping）中出现的概念，通常对应数据模型（数据库），是与数据库汇总的表想影射的java对象，最简单的PO就是对应数据库中某个表中的一条记录，多个记录则用PO的集合。PO中不应该包含任何对数据库的操作。</p>
<h3 id="DO即Domain-Object-领域对象："><a href="#DO即Domain-Object-领域对象：" class="headerlink" title="DO即Domain Object 领域对象："></a><strong>DO即Domain Object 领域对象：</strong></h3><p>&emsp;是从现实世界中抽象出来的有形或无形的业务实体。</p>
<h3 id="TO即Transfer-Object数据传输对象："><a href="#TO即Transfer-Object数据传输对象：" class="headerlink" title="TO即Transfer Object数据传输对象："></a><strong>TO即Transfer Object数据传输对象：</strong></h3><p>&emsp;不同应用程序之间传输的对象</p>
<h3 id="DTO即Data-Transfer-Object-数据传输对象："><a href="#DTO即Data-Transfer-Object-数据传输对象：" class="headerlink" title="DTO即Data Transfer Object:数据传输对象："></a><strong>DTO即Data Transfer Object:数据传输对象：</strong></h3><p>&emsp;泛指用于展示层与服务层之间的数据传输对象</p>
<h3 id="VO即value-Object："><a href="#VO即value-Object：" class="headerlink" title="VO即value Object："></a><strong>VO即value Object：</strong></h3><p>&emsp;通常用于业务层之间的数据传递，和PO一样仅包含数据，但是抽象出的业务对象，可以和表对应，用new 关键字创建，GC回收</p>
<h3 id="BO即Business-Object-业务对象"><a href="#BO即Business-Object-业务对象" class="headerlink" title="BO即Business Object 业务对象:"></a><strong>BO即Business Object 业务对象:</strong></h3><p>&emsp;主要是将业务逻辑封装为一个对象，这个对象可以包含一个或多个其他对象，如一个简历中包含教育经历、工作经历、社会关系等，可以将一个教育经历对应一个PO、工作经历对应一个PO、设计关系对应一个PO，然后简历一个对应简历的BO兑现处理简历，每个BO包含这个PO这样处理业务逻辑是，可以针对BO去处理。封装业务逻辑的java对象，通过调用DAO方法，结合PO,VO进行业务操作。</p>
<h3 id="POJO即Plain-Ordinary-Java-Object"><a href="#POJO即Plain-Ordinary-Java-Object" class="headerlink" title="POJO即Plain Ordinary Java Object:"></a><strong>POJO即Plain Ordinary Java Object:</strong></h3><p>&emsp;简单无规则的java对性，即在一些O/R 映射工具中，能做到维护数据库表记录的PO完全是一个符合Java Bean规范的纯java对象</p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础复习笔记</title>
    <url>/2021/12/21/C-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="C-面对对象笔记整理："><a href="#C-面对对象笔记整理：" class="headerlink" title="C++面对对象笔记整理："></a>C++面对对象笔记整理：</h1><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/C-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/C%2B%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.png?versionId=CAEQGBiBgID9.uzZ7xciIGE0NmYxMzZhNzE5MDQ3ODU5NzA2ZDE2NmNhNzUyYTdl"></p>
<h2 id="内存分区："><a href="#内存分区：" class="headerlink" title="内存分区："></a>内存分区：</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<p>​    <strong>代码区：</strong></p>
<ul>
<li><p>存放 CPU 执行的机器指令</p>
</li>
<li><p>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
</li>
<li><p>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
</li>
</ul>
<p>​    <strong>全局区：</strong></p>
<ul>
<li><p>全局变量和静态变量存放在此.</p>
</li>
<li><p>全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
</li>
<li><p>该区域的数据在程序结束后由操作系统释放</p>
</li>
</ul>
<h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//局部变量</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印地址</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态变量</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
<li>全局变量、静态变量、全局常量的地址&amp;隔得比较近</li>
</ul>
<h3 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h3><p>​    <strong>栈区：</strong></p>
<p>​        由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>   private static void handleResult(String result) {        if (result != null) {            JSONObject responseJson = new JSONObject(result);            int errcode = responseJson.getInt(“errcode”);            String errmsg = responseJson.getString(“errmsg”);​            if (errcode == 0) {                // 获取综合结果信息                JSONObject resultObject = responseJson.getJSONObject(“result”);                String suggest = resultObject.getString(“suggest”);                int label = resultObject.getInt(“label”);​                // 输出综合结果信息                System.out.println(“综合结果：”);                System.out.println(“建议：” + suggest);                System.out.println(“标签：” + label);​                // 如果文本内容建议审核，则根据实际需求执行人工审核流程                if (“review”.equals(suggest)) {                    System.out.println(“该文本内容建议进行人工审核！”);                    // 可以将内容设置为待审核状态，由人工审核决定是否发布                } else if (“pass”.equals(suggest)) {                    // 如果文本内容正常或命中关键词但不违规，允许发布                    System.out.println(“文本内容合规，可以发布！”);                } else if (“risky”.equals(suggest)) {                    // 如果文本内容被判定为违规，禁止发布，并输出违规信息                    System.out.println(“文本内容违规，请修改后重新提交！”);                    JSONArray detailArray = responseJson.getJSONArray(“detail”);                    for (int i = 0; i &lt; detailArray.length(); i++) {                        JSONObject detailObject = detailArray.getJSONObject(i);                        String strategy = detailObject.getString(“strategy”);                        if (“keyword”.equals(strategy)) {                            String keyword = detailObject.getString(“keyword”);                            int prob = detailObject.getInt(“prob”);                            System.out.println(“命中关键词：” + keyword + “，概率：” + prob);                        }                    }                } else {                    System.out.println(“未知建议类型：” + suggest);                }            } else {                // 输出错误信息                System.out.println(“接口调用失败，错误码：” + errcode + “，错误信息：” + errmsg);            }        } else {            System.out.println(“接口调用失败！”);        }Java</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结</strong>：栈区由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>​    <strong>堆区：</strong></p>
<p>​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​        在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<ul>
<li><p>堆区数据由程序员管理开辟和释放</p>
</li>
<li><p>堆区数据利用new关键字进行开辟内存</p>
</li>
</ul>
<h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><p>​    C++中利用<strong>new</strong>操作符在堆区开辟数据</p>
<p>​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 <strong>delete</strong></p>
<p>​    语法：<code> new 数据类型</code></p>
<p>​    利用new创建的数据，会返回该数据对应的类型的指针</p>
<p><strong>示例1： 基本语法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：开辟数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = i + <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">	<span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h3><p>**作用： **给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">	<span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">	<span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">	c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递，把主函数里面的a,b的值传过来，把主函数里面的实参a,b的值赋给了形参a,b,在mySwap01函数里面的形参a,b的值发生了改变，但是主函数的里面的a,b的地址和值都没有改变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递,通过把主函数里面的a,b的地址和值传给 mySwap02的*a,*b。即a的地址原来是01，值为10，b的地址是02，值是20，在mySwap02中的通过*a和*b传过来主函数的a,b的地址和值，将a的地址和值转换成02,20,b的地址和值转换成01,10</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递，在mySwap03中&amp;a,&amp;b指向主函数的a,b对应地址。比如原先的a,b的地址分别为01,02，进行交换之后,a,b的地址没有变，但是把01,02地址的里面的值交换了，即变量a的地址为01的值变成了20,变量b的地址为02的值变成了10</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量，存放在栈区，返回之后会被自动释放</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;<span class="comment">//全局变量</span></span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<span class="comment">//第一次会被编译器保存</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<span class="comment">//第二次就不会保存,a的内存已经被释放</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">	<span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>() = <span class="number">1000</span>;<span class="comment">//把1000赋值给a也就相当于赋给了a的别名ref2</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<span class="comment">//1000</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>​    </p>
<h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">	ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">	<span class="type">int</span>&amp; ref = a; </span><br><span class="line">	ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">func</span>(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//v += 10;</span></span><br><span class="line">    <span class="comment">//因为const的存在 v=1000修改不了v</span></span><br><span class="line">	cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误，10是一个常量</span></span><br><span class="line">	<span class="comment">//加入const就可以了，编译器优化代码，相当于int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">	cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数，即：声明和实现只能有一个默认参数</span></span><br><span class="line"><span class="comment">//3、如果我们自己传入数据，就用自己的数据，如果没有就用默认值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;<span class="comment">//声明函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="comment">//实现函数</span></span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>,<span class="number">10</span>)&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func2</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;<span class="comment">//void func(int a, int =10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h4 id="函数重载概述"><a href="#函数重载概述" class="headerlink" title="函数重载概述"></a>函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li>
</ul>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改函数返回值类型不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h4 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span><span class="comment">//int &amp;a=10,不合法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">func</span>(a); <span class="comment">//调用无const，a是一个变量，不是常量</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const，10是一个常量const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//func2(10); //碰到默认参数产生歧义，即：void func2(int a)和void func2(int a, int b = 10)均可以被调用，出现二义性，需要避免，所以写函数重载的时候，尽量避免形参中有默认参数的出现</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p>
<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>
<p><strong>例如：</strong></p>
<p>​    人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p>
<p>​    车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p>
<p>​    具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h4><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>​    在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p><strong>示例1：</strong>设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	<span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//行为</span></span><br><span class="line">	<span class="comment">//获取到圆的周长</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//2 * pi  * r</span></span><br><span class="line">		<span class="comment">//获取圆的周长</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过圆类，创建圆的对象c1</span></span><br><span class="line">	<span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">	Circle c1;</span><br><span class="line">	c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p>
<p><strong>示例2代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类,属性+行为=成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//行为</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_name = name;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">		m_id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//属性</span></span><br><span class="line">	string m_name;</span><br><span class="line">	<span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Student stu;</span><br><span class="line">	stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);<span class="comment">//stu.m_name=&quot;德玛西亚&quot;</span></span><br><span class="line">	stu.<span class="built_in">setID</span>(<span class="number">250</span>);<span class="comment">//stu.id=250</span></span><br><span class="line">	stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限  </li>
<li>protected 保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问 可以通过所属类的成员函数、友元类、友元函数、派生类对象</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问 只可以被所属类的成员函数、友元函数、友元类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_Name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string m_Car;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">		m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">		m_Password = <span class="number">123456</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//实例化对象p</span></span><br><span class="line">	Person p;</span><br><span class="line">	p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">	<span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line">	p.<span class="built_in">func</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	C1 c1;</span><br><span class="line">	c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">	C2 c2;</span><br><span class="line">	c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













<h4 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//姓名设置可读可写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">		m_Name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取年龄 </span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置年龄</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置为只写</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">		m_Lover = lover;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> m_Age; <span class="comment">//只读  年龄,如果需要读取，那么就写一个getAge函数</span></span><br><span class="line"></span><br><span class="line">	string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Person p;</span><br><span class="line">	<span class="comment">//姓名设置</span></span><br><span class="line">	p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//年龄设置</span></span><br><span class="line">	p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//情人设置</span></span><br><span class="line">	p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h3><ul>
<li> 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li> C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>​    一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>​    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><p>两种分类方式：</p>
<p>​    按参数分为： 有参构造和无参构造</p>
<p>​    按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​    括号法</p>
<p>​    显示法</p>
<p>​    隐式转换法</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.1  括号法，常用</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">	<span class="comment">//Person p2();类似于void func();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.2 显式法</span></span><br><span class="line">	Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); <span class="comment">//有参构造p2，即：右边的无名函数声明取名为p2</span></span><br><span class="line">	Person p3 = <span class="built_in">Person</span>(p2);<span class="comment">//拷贝构造p3</span></span><br><span class="line">	<span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.3 隐式转换法</span></span><br><span class="line">	Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">	Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明，即：Person(p3)===Person p3，会默认为重定义</span></span><br><span class="line">	<span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		mAge = p.mAge;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">	<span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">	Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person newman3;</span></span><br><span class="line">	<span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">	<span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p1;</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">	cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="comment">//test02();</span></span><br><span class="line">	<span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造，但要是需要创建一个类对象，必须写上默认无参构造函数</li>
</ul>
<ul>
<li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数，默认构造和有参构造均不提供，析构函数还是有</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">		age = a;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		age = p.age;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">	<span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">	Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">	Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">	<span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//无参（默认）构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有参构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		m_age = age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数  </span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">		m_age = p.m_age;</span><br><span class="line">		m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数</span></span><br><span class="line">	~<span class="built_in">Person</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_height;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_age;</span><br><span class="line">	<span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供深拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">////传统方式初始化</span></span><br><span class="line">	<span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">	<span class="comment">//	m_A = a;</span></span><br><span class="line">	<span class="comment">//	m_B = b;</span></span><br><span class="line">	<span class="comment">//	m_C = c;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表方式初始化</span></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B类中有对象A作为成员，A为对象成员</p>
<p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Phone</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		m_PhoneName = name;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Phone</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">	<span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">Person</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	string m_Name;</span><br><span class="line">	Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">	<span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">	<span class="comment">//析构顺序与构造相反</span></span><br><span class="line">	<span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">	p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li> 所有对象共享同一份数据</li>
<li> 在编译阶段分配内存</li>
<li> 类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li> 所有对象共享同一个函数</li>
<li> 静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1 ：</strong>静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员变量特点：</span></span><br><span class="line">	<span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">	<span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">	<span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.m_A = <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Person p2;</span><br><span class="line">	p2.m_A = <span class="number">200</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：</strong>静态成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数特点：</span></span><br><span class="line">	<span class="comment">//1 程序共享一个函数</span></span><br><span class="line">	<span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line">	<span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、通过对象</span></span><br><span class="line">	Person p1;</span><br><span class="line">	p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2、通过类名</span></span><br><span class="line">	Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h3><h4 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		mA = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">	<span class="type">int</span> mA;</span><br><span class="line">	<span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line">	<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li> 当形参和成员变量同名时，可用this指针来区分</li>
<li> 在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">        <span class="comment">//this指针指向被调用的成员函数所属的对象</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">		<span class="comment">//this指向p2的指针，而*this指向的就是p2对象的本体</span></span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//链式变成思想</span></span><br><span class="line">	p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//mAge相当于this-&gt;mAge，但是当p-&gt;ShowPerson()调用这个函数的时候，因为此时*p指向一个空的值，并不是一个确定的对象，无法访问Person属性的成员变量</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person * p = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">	p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h4><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;</span><br><span class="line">		m_A = <span class="number">0</span>;</span><br><span class="line">		m_B = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line">	<span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line">    <span class="comment">//在成员函数的后面加const，修饰的是this指向，让this指向的 值 也不可以进行修改</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//const Type* const pointer;</span></span><br><span class="line">		<span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line">		<span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//mA = 10000;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//加mutable之后，此属性可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">	cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">	person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//常对象访问成员函数</span></span><br><span class="line">	person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象只能调用常函数，常对象不能调用普通的成员函数，因为普通成员函数能修改</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜好基友进去。</p>
<p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p>
<p>友元的关键字为  ==friend==</p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Building</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Building b;</span><br><span class="line">	<span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">goodGay</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">	building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	goodGay  gg;</span><br><span class="line">	gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<p>下面我就拿两个例子简单示例一下，当然还有**++运算符**等重载，有兴趣的小伙伴可以去自己上网或者查询书籍深入了解一下</p>
<h4 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">	Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">		Person temp;</span><br><span class="line">		temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">		temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//	Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//	temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//	temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//	return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">	Person temp;</span><br><span class="line">	temp.m_A = p2.m_A + val;</span><br><span class="line">	temp.m_B = p2.m_B + val;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//对类对象p1，p2的m_A,m_B属性分别进行初始化</span></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数Person operator+(const Person&amp; p)的调用</span></span><br><span class="line">	Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//全局函数operator+的调用</span></span><br><span class="line">	Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h4><p>作用：可以输出自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line">	<span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承是面向对象三大特性之一</strong></p>
<p>我们发现，定义很多类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p>
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p>
<h4 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p><strong>普通实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Java页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Java ja;</span><br><span class="line">	ja.<span class="built_in">header</span>();</span><br><span class="line">	ja.<span class="built_in">footer</span>();</span><br><span class="line">	ja.<span class="built_in">left</span>();</span><br><span class="line">	ja.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Python页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Python py;</span><br><span class="line">	py.<span class="built_in">header</span>();</span><br><span class="line">	py.<span class="built_in">footer</span>();</span><br><span class="line">	py.<span class="built_in">left</span>();</span><br><span class="line">	py.<span class="built_in">content</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//C++页面</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	CPP cp;</span><br><span class="line">	cp.<span class="built_in">header</span>();</span><br><span class="line">	cp.<span class="built_in">footer</span>();</span><br><span class="line">	cp.<span class="built_in">left</span>();</span><br><span class="line">	cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>继承的好处：==可以减少重复的代码==</p>
<p>class A : public B; </p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son1 s1;</span><br><span class="line">	s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son2 s;</span><br><span class="line">	<span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">		m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">		<span class="comment">//m_C; //不可访问</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">		<span class="comment">//m_A;</span></span><br><span class="line">		<span class="comment">//m_B;</span></span><br><span class="line">		<span class="comment">//m_C;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//父类中的非静态成员属性都会被子类继承，只不过父类的private 被隐藏了</span></span><br><span class="line">    <span class="comment">//子类可以继承父类的静态属性</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>利用工具查看：</p>
<p>1、找到visual studio下面的vs2017的开发人员命令指示符</p>
<p>2、打开工具窗口后，定位到当前CPP文件的盘符，假如你的cpp文件在F盘那就先输入F:</p>
<p>3、然后输入cd 你的以.cpp为后缀代码文件的文件夹</p>
<p>4、然后输入dir,查看此文件夹中的文件目录 </p>
<p>5、输入cl  /d1  reportSingleClassLayout查看的类名  “所属文件名”  （cl是字母cl，/d后面的是数字1，而且cl 和/d1之间有空格）</p>
<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">	Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
<p>​            就是类似于先有爸爸，才生的出来儿子一样的</p>
</blockquote>
<h4 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域，格式即：类对象.父类类名 :: 父类中同名的函数( );</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">	<span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Son s;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员   直接访问即可</li>
<li>访问父类同名成员   需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过类名访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一个：：代表通过类名的方式访问  第二个::代表访问父类作用域下</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//通过对象访问</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son s;</span><br><span class="line">	s.<span class="built_in">func</span>();</span><br><span class="line">	s.Base::<span class="built_in">func</span>();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//子类类名::父类类名::父类静态成员函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	Son::<span class="built_in">func</span>();</span><br><span class="line">	Son::Base::<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">	Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
<p>​           切记在类外访问类内非静态成员函数的时候，不能通过<strong>类名::函数名</strong>的方式直接访问，并且静态成员函数只能访问静态成员变量</p>
</blockquote>
<h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p><strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">100</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base2</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Son</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_C = <span class="number">300</span>;</span><br><span class="line">		m_D = <span class="number">400</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_C;</span><br><span class="line">	<span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当父类中出现同名的成员，需要加作用域进行区分</span></span><br><span class="line">	Son s;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p><strong>菱形继承概念：</strong></p>
<p>​    两个派生类继承同一个基类</p>
<p>​    又有某个类同时继承者两个派生类</p>
<p>​    这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>菱形继承问题：</strong></p>
<ol>
<li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
</code></pre>
</li>
<li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。
</code></pre>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SheepTuo st;</span><br><span class="line">	st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">	st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承问题</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h4 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//Speak函数就是虚函数，此时的animal类的Speak也就是动态化的一个函数</span></span><br><span class="line">	<span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了，就会根据运行阶段进行函数的地址，实现晚绑定</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Cat cat;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(cat);<span class="comment">//Animal &amp;animal = cat</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	Dog dog;</span><br><span class="line">	<span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数，但是不要加virtual</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类的 指针 或 引用 指向子类对象</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p>
<h4 id="多态案例一-计算器类"><a href="#多态案例一-计算器类" class="headerlink" title="多态案例一-计算器类"></a>多态案例一-计算器类</h4><p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展以及维护</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//普通实现测试</span></span><br><span class="line">	Calculator c;</span><br><span class="line">	c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">	c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> m_Num1;</span><br><span class="line">	<span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//创建加法计算器</span></span><br><span class="line">	AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁，只是把堆区的abc的值删除了，但是abc的指针并没有删除，故后面直接用abc指向新的对象即可。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建减法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建乘法计算器</span></span><br><span class="line">	abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">	abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">	abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li>C++多态组织结构清晰，可读性强，便于前后期的扩展以及维护</li>
<li>使用条件：父类的 “指针” 或者 “子类” 指向子类对象</li>
</ul>
<h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，如果父类中的虚函数对项目的开发毫无用处，那就可以定义成一个<strong>纯虚函数</strong>进行开发</p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象，只能通过指针</li>
<li>子类必须重写抽象（父）类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//纯虚函数</span></span><br><span class="line">	<span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line">	<span class="comment">//1、抽象类无法实例化对象</span></span><br><span class="line">	<span class="comment">//2、子类必须重写父类中的纯虚函数，否则也属于抽象类，无法实例化对象</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base * base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">	base = <span class="keyword">new</span> Son;<span class="comment">//或者Base * base = NULL;base = new Son;写成一句话 Base * base = new Son;</span></span><br><span class="line">	base-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> base;<span class="comment">//记得销毁.释放base指针的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="多态案例二-制作饮品"><a href="#多态案例二-制作饮品" class="headerlink" title="多态案例二-制作饮品"></a>多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶，实现烧、冲、倒、加等功能</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//规定流程</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">Boil</span>();</span><br><span class="line">		<span class="built_in">Brew</span>();</span><br><span class="line">		<span class="built_in">PourInCup</span>();</span><br><span class="line">		<span class="built_in">PutSomething</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//烧水</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//冲泡</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//倒入杯中</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//加入辅料</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">	drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">	<span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);<span class="comment">//即让void DoWork(AbstractDrinking* drink)中的* drink指针指向Coffee并调用DoWork函数，此时Coffee便会调用继承下来的void MakeDrink()和已经重写好的void MakeDrink()函数中的烧、冲、倒、加等功能</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);<span class="comment">//同理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code> virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Animal</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//析构函数加上virtual关键字，变成虚析构函数，来解决父类指针释放子类对象不干净的问题</span></span><br><span class="line">	<span class="comment">//virtual ~Animal()</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//纯虚析构函数，但是需要对此纯虚构函数进行 声明和实现</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Cat</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span> m_Name;</span><br><span class="line">			m_Name = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过父类指针去释放，不会调用子类中的析构函数，子类如果有堆区属性，会造成内存泄漏</span></span><br><span class="line">	<span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line">	<span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line">	<span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象的问题，并且纯虚析构和虚析构都需要进行声明和实现，来防止父类开辟堆区对象时的问题</p>
<p>​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p>
<pre><code> 3. 拥有纯虚析构函数的类也属于抽象类
</code></pre>
<h4 id="多态案例三-电脑组装"><a href="#多态案例三-电脑组装" class="headerlink" title="多态案例三-电脑组装"></a>多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p>
<p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p>
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
<p>测试时组装三台不同的电脑进行工作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的计算函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的显示函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//抽象的存储函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">	&#123;</span><br><span class="line">		m_cpu = cpu;</span><br><span class="line">		m_vc = vc;</span><br><span class="line">		m_mem = mem;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供工作的函数</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">		m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">		m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">		m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">	~<span class="built_in">Computer</span>()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放CPU零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_cpu;</span><br><span class="line">			m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放显卡零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_vc;</span><br><span class="line">			m_vc = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//释放内存条零件</span></span><br><span class="line">		<span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> m_mem;</span><br><span class="line">			m_mem = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">	CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">	VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">	Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//第一台电脑零件</span></span><br><span class="line">	CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">	VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">	Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//创建第一台电脑</span></span><br><span class="line">	Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">	computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>C++笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP、IP、DNS</title>
    <url>/2022/01/16/TCP%E3%80%81IP%E3%80%81DNS/</url>
    <content><![CDATA[<p>你好，我是小八，最近在备考，考试总算是结束了，终于可以放假，学习更多的技术了<del>干自己想干的事情了</del></p>
<p>下面分享一些 IP、TCP、DNS 的基础知识点，大家可以看看，绝对通俗易懂！！！</p>
<h1 id="与-HTTP-关系密切的协议：IP、TCP-和-DNS"><a href="#与-HTTP-关系密切的协议：IP、TCP-和-DNS" class="headerlink" title="与 HTTP 关系密切的协议：IP、TCP 和 DNS"></a>与 HTTP 关系密切的协议：IP、TCP 和 DNS</h1><h4 id="负责传输的-IP-协议："><a href="#负责传输的-IP-协议：" class="headerlink" title="负责传输的 IP 协议："></a>负责传输的 IP 协议：</h4><p>&emsp;&emsp;按层次分，IP（Internet Protocol）网际协议属于网络层。<strong>IP 地址</strong>和<strong>IP</strong>不同，“IP”其实就是一种协议的名称，即：网际协议。</p>
<p>&emsp;&emsp;IP 协议作用：把各种<strong>数据包</strong>传送给对方，但是必须满足<strong>IP 地址</strong>和<strong>MAC 地址</strong>（Media Access Control Address）两个条件才能确实送到对方那里。</p>
<p>&emsp;&emsp;<strong>IP 地址</strong>：节点被分配到的地址，</p>
<p>&emsp;&emsp;<strong>MAC 地址</strong>：网卡所属的固定地址。</p>
<p>&emsp;&emsp;<strong>注意：</strong> IP 地址可以变换，MAC 地址基本不变。</p>
<p>&emsp;&emsp;IP 通信依赖 MAC 地址, 因为不同计算机之间通信时，通常是不在一个局域网(LAN)下，此时就需要多个中间计算机和设备（路由器等均可作为中转设备）进行中转，最后连接到你所需要连接的计算机，在中转的过程中，会利用到下一个中转设备的 MAC 地址来寻找到下一个中转目标。这下就要用到了<strong>ARP 协议</strong>(Address Resolution Protocol).</p>
<p>&emsp;&emsp;<strong>ARP 协议：</strong> 一种解析地址的协议，根据对方的 IP 地址可以反查出对应的 MAC 地址。</p>
<p>&emsp;&emsp;如果还是不懂的话，就拿快递公司的收发货方式来打一个比方吧，我们要是双十一买了东西（“东西”就是我们在网络上要传递给某个设备的信息），卖家需要把东西寄给我们（”我们“就是接收信息的设备），那么他们就会把自己的货物送到某快递的集散中心，然后集散中心通过核对收件人地址，来确定送到下一个集散中心（这里的“集散中心”就是类似于一个中转设备），最后到达离收件地址最近的集散中心之后，再送到我们手上（这时候就实现了发起设备和接收设备的信息传递）。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/IP%E3%80%81TCP%E5%92%8CDNS/ARP%E5%8D%8F%E8%AE%AE.png?versionId=CAEQGRiBgID_98q58hciIGU2NDAxY2JlNmQ5MzQ2YjViYzQyZTgyZTQ3NmI0ZDY1" alt="img"></p>
<h4 id="确保可靠性的-TCP-协议"><a href="#确保可靠性的-TCP-协议" class="headerlink" title="确保可靠性的 TCP 协议"></a>确保可靠性的 TCP 协议</h4><p>&emsp;&emsp;TCP 和 UDP 都位于传输层，这个前面说过，其中 TCP 是用来提供可靠的字节流服务。</p>
<p>&emsp;&emsp;其中 TCP 协议能够准确确定数据是否送达目标处，这样的实现的过程就是通过三次握手（three-way handshaking）策略，其中握手过程中使用了 TCP 的标志（flag）——ACK 和 SYN，原理如下：</p>
<p>&emsp;&emsp;第一次由发起端首先发送一个 SYN 标志的数据包给接收端，第二次握手就是在接收端接收这个标志之后，接收端再反馈一个 SYN 和 ACK 的数据包给发起端，来表达自己已经接收到了发起端的请求，最后一次握手就是在收到接收端的确认信息之后，发起端回传一个 ACK 的数据包给接收端，代表“握手”结束。</p>
<p>&emsp;&emsp;如果其中有某一次握手中断，那就会延续上一次握手进行重复的请求，但要是请求超时之后就会重新开始由发送端进行第一次握手。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/IP%E3%80%81TCP%E5%92%8CDNS/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png?versionId=CAEQGRiBgMDa98q58hciIGZjNTZlZWU4OWI1MzRjYjdhMDIyMzEzYWYyNWNiMGE2" alt="image-20211230200934379"></p>
<h4 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h4><p>就是当你在访问某个网站的时候，会有一个网址(比如：<code>www.baidu.com</code>也就是此网站的域名)，而在访问某个计算机的时候也可以通过赋予此计算机一个域名，最后通过 DNS 解析域名来获取其 IP 地址，最后访问到此计算机。</p>
<p>DNS 的作用便是通过域名查找对应的设备的 IP 地址，或者逆向从 IP 地址查域名的服务。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/IP%E3%80%81TCP%E5%92%8CDNS/DNS.png?versionId=CAEQGRiBgMDIlN658hciIGI1YTcxNDhjZjNlMjQxNTdiMTA1OTVkYjJjZjE5ODg5" alt="image-20211230202446976"></p>
<hr>
<p>你好，我是小八，一个分享学习经历和知识的在读大学生。</p>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>URI</title>
    <url>/2022/02/04/URI/</url>
    <content><![CDATA[<blockquote>
<p>时隔一周，我终于抽空又来分享一些知识了<del>承蒙关注，希望各位小伙伴点赞加关注</del></p>
</blockquote>
<p>你好，我是小八，一个分享学习知识和经验的在读大学生。</p>
<p>前几期我们已经讲了 tcp/ip 协议族、IP，TCP，DNS 的作用，我们再来讲讲我们经常上网都会使用到的 URI 和 URL 吧~</p>
<h2 id="URL-和-URI"><a href="#URL-和-URI" class="headerlink" title="URL 和 URI"></a>URL 和 URI</h2><p><strong>URL</strong>（Uniform Resource Locator）：统一资源定位符。也就是我们口中所称的网址。</p>
<p><strong>URI</strong>（Uniform Resource Identifier）：URI 用字符串表示某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。</p>
<p>也就是说 URL 是 URI 的子集。</p>
<blockquote>
<p>所以我们下面讲一讲 URI 的格式，也就能理解什么是 URL 了~</p>
</blockquote>
<h2 id="URI-格式"><a href="#URI-格式" class="headerlink" title="URI 格式"></a>URI 格式</h2><p>URI 需要涵盖全部必要信息的绝对 URI、绝对 URL 以及相对 URL，这时候大家肯定很疑惑，什么是<strong>相对</strong>，什么是<strong>绝对</strong>？其实很好理解。</p>
<p><strong>绝对 URL</strong>（比如说一个完整的通信地址，包含国家，省，市，小区门牌号，姓名。） 包含了指向目录或文件的完整信息，包括指向目录或文件的完整信息，包括模式、主机名和路径。</p>
<p>绝对 url 本身与被引用的文件实际位置无关，无论在哪个主机上的网页中，某一文件的绝对 URL 都是完全一样的。因此，当引用别人服务器上的文件时，应该总是使用绝对 URL。</p>
<p><strong>相对 URL</strong> 指出的位置是以信息提供者的位置为参照的。（假设 A 的位置标记为在 B 的向左十米，那么这个位置就是相对地址，相对于 B 的位置而言的）相对 URL 以包含 URL 本身的文件位置为参照点，描述目标文件的位置。因此，相对 URL 可以表达像“指向本页面同一目录的那个文件”的意思。</p>
<p>下面就是绝对 URI 的格式：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220124170905495.png" alt="绝对URI格式"></p>
<p>当然上面的协议方案名也不止一种，还有 https、ftp、mailto、file 等 30 种左右</p>
<p>说了这么多，我再来解释一下上面的各个小模块的意思吧</p>
<h3 id="登录信息（认证）"><a href="#登录信息（认证）" class="headerlink" title="登录信息（认证）"></a>登录信息（认证）</h3><p>其实就是为了当你在访问服务器资源的时候，通过用户名账号和密码对你的身份信息进行认证。</p>
<h3 id="服务器地址"><a href="#服务器地址" class="headerlink" title="服务器地址"></a>服务器地址</h3><p>使用绝对 URI 必须指定待访问的服务器地址。</p>
<ul>
<li><p>可以是类似 <a href="https://pengzihao166.work/">pengzihao166.work</a> 这种 DNS 可解析的地址</p>
</li>
<li><p>也可以是 192.168.1.1 这类 IPv4 地址</p>
</li>
<li><p>再或者是类似[0:0:0:0:0:0:0:1]这种 IPv6 地址名</p>
</li>
</ul>
<h3 id="服务器端口号"><a href="#服务器端口号" class="headerlink" title="服务器端口号"></a>服务器端口号</h3><p>此项和登录信息一样是可选项，可以指定服务器连接的网络端口号，如果省略就会自动使用默认的端口号。</p>
<h3 id="带层次的文件路径"><a href="#带层次的文件路径" class="headerlink" title="带层次的文件路径"></a>带层次的文件路径</h3><p>就和电脑某个文件的<strong>路径</strong>类似，指定服务器上的文件路径来定位特指的资源。</p>
<h3 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h3><p>对已指定的文件路径内资源，可以使用查询字符串传入任意参数。</p>
<h3 id="片段标识符"><a href="#片段标识符" class="headerlink" title="片段标识符"></a>片段标识符</h3><p>使用片段标识符通常可<strong>标记</strong>出已获取资源中的子资源（文档内的某个位置）。</p>
<p><strong>注意</strong>：登录信息、查询字符号、服务器端口号、片段标识符都是可选项~</p>
<p>好了~今天的知识分享就到此结束了</p>
<hr>
<p>你好，我是小八，承蒙厚爱，能不能点赞加个关注呢~</p>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>终于熬过来了！！！</title>
    <url>/2022/01/06/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<p>大家好，我是小八，好久不见啊，我今天终于熬完了课设和汇编备考。</p>
<p>现在来分享一下我的<strong>战斗经历</strong></p>
<p>我们课设的小组成员由 5 个人组成：周**、小八、赵.**、陈**、曹**</p>
<p>因为复习汇编的时间和课设的时间挤在了一起，导致我们寝室小组最近都经常肝到凌晨两三点，<strong>划重点：不建议学弟学妹们这么做！！！</strong> 属实很累。</p>
<p>经过是这样的，我们小组确定的课设题目是 <strong>校园助手</strong> 。</p>
<p>既然是校园助手，肯定得有查成绩、查课表、查地图、聊天、修改个人信息等功能，这样的话，因为我最近在学习前端，组长也在学习服务器开发，于是我们小组就一拍即合，做一个前后端分离的 demo，并且得有一个像校园助手的样子，自然就不能继续用控制台，用黑框框来展示我们的成果了，果断选择 QT 平台。</p>
<p>毕竟要做，就要做一个牛逼的东西！！！先给你们看看登录界面的展示效果吧。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/mainwindow1.png?versionId=CAEQGRiBgID80f.28RciIGE4OWU3ZDI1OGJmNzRiNGM4ZjQ4ZjEwYzgzZGYyYWRj"></p>
<p>下面的是我们客户端的图标，有没有想到湖工大考试平台的图标呢？？</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/myico.png?versionId=CAEQGRiBgIC7.ZS48RciIGZlZDVhM2MxYzE4NTRkNzliYjk2MjE5MjJlOTlhNTZm"></p>
<p>这个界面看似简单，但实际上，后面很多的功能实现、界面跳转、跟服务器的数据请求以及初始化数据都是在这个界面的代码块进行实现，简简单单看看代码就知道了，这个 demo 好歹也是做了大半个月呢。</p>
<p>截图如下：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/code.png?versionId=CAEQGRiBgMDPis.38RciIDhkMjgyM2UyMGQwMDQ1MWE5ZDA1NzZlMDhmMzBkMjBl"></p>
<h2 id="最大瓶颈出现"><a href="#最大瓶颈出现" class="headerlink" title="最大瓶颈出现"></a>最大瓶颈出现</h2><p>而这也仅仅是主界面的一个很小的功能模块的代码块罢了，我还记得当时我们遇到的最大的一个瓶颈就是，实现两台不同设备之间的向服务器端发送请求，并且记录对方 IP，通过服务器作为中转站交互信息。我们小组一直在接触服务器开发的也就是我们的组长——周**，而我也最近才只是刚刚入门计网，我和他也只能仅仅讨论一下，解决的想法。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>遇到这个问题的时候，我和组长刚开始毫无思路，我就在一个在字节、腾讯、快手等大佬汇集的群里问一问经验和解决方案。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/chat1.png?versionId=CAEQGRiBgIDF1f238RciIGRhYWEyMTc2MmZkNDQ3MDU4ZDQ0MjY1NWZkMTA1YTg5"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/chat2.png?versionId=CAEQGRiBgMDH1f238RciIDgwODZlMWU3NmRiMzRhY2NiZTAyNzM1ZGFkMzk1NWIx"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/chat3.png?versionId=CAEQGRiBgMDN1f238RciIDM1M2RkNWNlZWNhZjQ5YjJiMWMwNjE5YWEyMzc2Yjll"></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/chat4.png?versionId=CAEQGRiBgMDZ1f238RciIDVmMGZkNmMyZWU4YjQwZWU5NmZkYzg0ZTdiNDYzMjBi"></p>
<p>当时毕竟很晚了他们应该已经睡觉了，没有人回我，后来才回复了我。</p>
<p>过了一会，我和组长突然想到了一个办法，那就是通过每个人的固定学号绑定到每个用户的 IP，并固定 IP，就是说等我们连接到服务器之后，再分别在 cmd 里面 ipconfig /all 一下两台设备的 IP，最后改一下服务器端的代码块里面的 IP 地址，岂不是走了一波小捷径？毕竟不知道怎么获取 IP 地址，并实时更新对应用户的 IP，因为 IP 一直是会更新的，一般随着路由的分配形成一个局域网，重连一次网络 DHCP 就会重新分配一次新的 IP，而且咱也实力有限,能想到这个想法，个人觉得已经很不错了。</p>
<p>这虽然说是服务器端的任务，前端只需要直接从服务器获取数据就行了，但这样我对计网也有了更加深层次的了解，知道怎么在实际需求中，进行构思解决方案，并且我还发现，后端要跟着前端的需求走，前端需要什么，后端就得实时进行更新并处理数据，所以感觉后端好惨。</p>
<blockquote>
<p><strong>划重点</strong>：以后还是要转后端学习的我，先让组长替我受受苦吧，hhhhhhhh。</p>
</blockquote>
<p>当然当时这个 demo 的问题还有很多，比如，修改个人信息栏如何实现<strong>换行</strong>，而不是在一行里面显示，导致显示溢出的问题，当时不知道怎么解决，我就写了一个判断语句，来控制那个信息栏输入字符长度，让个人信息就显示在一行，但不会溢出，就类似于 QQ 个性签名文字个数限制一样。</p>
<h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><p>刚刚介绍的只是我们前后端交互当时遇到的一个最大的问题，而我们前端，当时有很多功能，比如：登录，注册，修改密码，显示课程表，班级成员成绩等，都需要从后端获取相应的数据之后，在前端进行逻辑实现，并反馈给服务器。</p>
<p>比如：你在登录的时候，需要输入账号密码之后，将用户数据发送到服务器进行用户信息的遍历，找到是否有匹配的用户，如果没有，那么服务器就会反馈 NO 的信息给前端，自然也就登录不进去，如果有，那么反馈给前端一个 YES，则就能登入客户端，进行查看课表、查成绩等功能。</p>
<p>登录失败前端反馈如下图：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/logNO.png?versionId=CAEQGRiBgMCW9MO48RciIDdmYjJkYzU4YTZlNjQ1YmU5ZDA5OGEwM2M1NjRjN2Jm"></p>
<p>登录成功便进入此界面：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/logYES.png?versionId=CAEQGRiBgMCX9MO48RciIDJlN2VmOGNjOWJkYjQ4YjU4MGI3MjA3Y2E3ZTM3NGJl"></p>
<p>服务器这边的反馈信息如下：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/houduan.png?versionId=CAEQGRiBgIC368q48RciIDQzOThjZDE3OTNiMDRkNGNhZWI0NjdjOTIwYzc2MTlk"></p>
<p>有一说一，看到这个后端是不是觉得很牛逼，我也确实佩服我的组长，一个人能完成所有的前端发来的数据处理，在下属实佩服，不知道你们怎么觉得，反正我还很菜，目前还做不出来一个服务器。</p>
<p>当然还有其他的功能，我就不一一展示了，比如：注册、修改个人信息、忘记密码、展示工大地图、查询成绩等。都是其他小组成员分别负责的几个小模块。</p>
<p>这里科普一下：只要服务器一开，我们打开客户端的时候，对服务器就会<strong>三次握手</strong>发送连接请求（有兴趣的小伙伴可以去了解一下）。</p>
<h2 id="答辩过程"><a href="#答辩过程" class="headerlink" title="答辩过程"></a>答辩过程</h2><p>昨天上午我们找到老师进行了答辩，而且我们小组因为敢于尝试 QT 平台和实现了前后端分离，小组成绩获得了所有小组中的最高分</p>
<p>还记得当时有挺多人来围观我们的课设，小组成员在答辩的时候附近声音属实嘈杂。</p>
<p>当组长答辩完他写的服务器之后，便到我进行对自己的功能模块的答辩了，首先我对老师介绍了我的功能模块，能够实现什么？能够干些什么？</p>
<p>我的解答就是，我的负责的模块可以分为三大块：</p>
<h4 id="1、窗口（mainwidow）、对话框（dialog）、按钮（button）之间的跳转-（QT-自带的信号，槽函数进行实现）"><a href="#1、窗口（mainwidow）、对话框（dialog）、按钮（button）之间的跳转-（QT-自带的信号，槽函数进行实现）" class="headerlink" title="1、窗口（mainwidow）、对话框（dialog）、按钮（button）之间的跳转 （QT 自带的信号，槽函数进行实现）"></a>1、窗口（mainwidow）、对话框（dialog）、按钮（button）之间的跳转 （QT 自带的信号，槽函数进行实现）</h4><p>比如这一块就是通过信号和槽来实现对数据传递，并跳转出成绩查询窗口。</p>
<p>代码如下：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">void MainWindow1::<span class="built_in">on_serch_clicked</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">connect</span>(dialog1, SIGNAL(sendNum(QString)), this, <span class="built_in">SLOT</span>(getNum(QString)));</span><br><span class="line">    <span class="comment">//查询成绩</span></span><br><span class="line">    dialog1-&gt;<span class="built_in">setModal</span>(true);</span><br><span class="line">    dialog1-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、在主窗口对服务器发送数据，接收服务器数据"><a href="#2、在主窗口对服务器发送数据，接收服务器数据" class="headerlink" title="2、在主窗口对服务器发送数据，接收服务器数据"></a>2、在主窗口对服务器发送数据，接收服务器数据</h4><p>比如下面的代码就是登录之后，将登录用户数据发送给服务器。</p>
<p>代码如下：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">this</span>-&gt;</span><span class="function"><span class="title">clint_Login</span>-&gt;</span>write(user_msg);</span><br></pre></td></tr></table></figure>

<h4 id="3、登录功能、课表的查询展示"><a href="#3、登录功能、课表的查询展示" class="headerlink" title="3、登录功能、课表的查询展示"></a>3、登录功能、课表的查询展示</h4><p>介绍完之后，老师问了我一个问题，下面的代码是什么意思：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">QJsonDocument <span class="attr">doc</span> <span class="operator">=</span> QJsonDocument::fromJson(UserInfo, <span class="variable">&amp;json_error</span>)<span class="punctuation">;</span></span><br></pre></td></tr></table></figure>

<p>我的回答无疑就是解释它的是怎么用的，通过定义一个QJsonDocument的 doc 对象，把 userinfo 里面的信息进行解析出来获取数据放到 doc 中。</p>
<p>毕竟当时是一边学 QT 一边做的，并不是很了解深层原理，也就只好这么回答了。但老师好像就是要我剖析它的深层原理，对我的答案，并不是很满意，只怪自己当初并没有花更多的时间去研究 QT 吧。</p>
<p>再就是问了一下我的课表是怎么实现的，实现代码在哪？</p>
<p>我的回答就是，其实真的很简单，就是一个插图的办法实现的，通过 new 一个课表类的对象 Class_Schedule 初始化课表，再进行窗口模糊 setModal 和窗口展示 show 进行实现。</p>
<p>跳转代码段如下：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">void</span> <span class="variable">MainWindow1</span>::<span class="function"><span class="title">on_scotmtb_clicked</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">Class_Schedule</span>-&gt;<span class="function"><span class="title">setModal</span>(<span class="variable"><span class="literal">true</span></span>);</span></span><br><span class="line"><span class="function">    <span class="variable">Class_Schedule</span>-&gt;<span class="title">show</span>();</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>不过这有很大<strong>局限性</strong>：因为只能查到自己班的课表。嘻嘻嘻~</p>
<p>我的课设答辩差不多就这样结束了。</p>
<p>不过当时有一个学生在那里跟我们的课设指指点点，我当时就在想：能不能尊重一下我？是我在答辩，不是你！你当你能像毛主席一样指点江山？</p>
<p>希望关注我的小伙伴们以后不会遇到这种人。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说了这么多，总结以下几点：</p>
<p>1、前后端分离，能改善修改代码的效率，不会因为一个小 bug，去修改一整片的代码，从而提高了功能更新的效率。</p>
<p>2、少熬夜，熬夜伤身。（在这里再立一个 flag，2022 年不仅要好好学习技术，还得少熬夜，跟以前一样 11 点之前就睡觉，没事多锻炼一下身体。）</p>
<p>3、bug 常常有，有时候一个 bug 一天都修复不了很正常，慢慢去想就行了，不要急躁，切记，敲代码务必要戒骄戒躁。</p>
<p>4、不知道某个瓶颈怎么解决，可以换一种思路或者方式去解决这个问题，多和同学讨论，或者像大佬请教，上百度找教程等等。<strong>（忌:ctrl c + ctrl v）</strong></p>
<p>5、最近计网的知识，能够在实际应用中想到相应的解决方案，并跟组员一同分享。</p>
<p>6、不足就是，组员中除了我都不会用 Git，不然能更高效率实现各功能模块代码的合并，减少很多不必要的麻烦。</p>
]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot开发规范（一）</title>
    <url>/2022/11/21/springboot-levelFunction/</url>
    <content><![CDATA[<h2 id="model（entity）"><a href="#model（entity）" class="headerlink" title="model（entity）"></a>model（entity）</h2><p>​        model是模型的意思，与entity、domain、pojo类似，是存放实体的类，类中定义了多个类属性，并与数据库表的字段保持一致，一张表对应一个model类。 主要用于定义与数据库对象应的属性，提供get/set方法,tostring方法,有参无参构造函数。</p>
<h2 id="dao（mapper）"><a href="#dao（mapper）" class="headerlink" title="dao（mapper）"></a>dao（mapper）</h2><p>​        又被成为mapper层，叫数据持久层，先设计接口，然后在配置文件中进行配置其实现的关联。 dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。 数据持久化操作就是指，把数据放到持久化的介质中，同时提供增删改查操作，比如数据通过hibernate插入到数据库中</p>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>​        业务逻辑层，完成功能的设计 和dao层一样都是先设计接口，再创建要实现的类，然后在配置文件中进行配置其实现的关联。接下来就可以在service层调用dao层的接口进行业务逻辑应用的处理。 service的impl是把mapper和service进行整合的文件 封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。</p>
<h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>​        控制层，控制业务逻辑service，控制请求和响应，负责前后端交互 controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/2052481-20210417164128180-1418412203.png" alt="img"></p>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>初识TCP/IP协议族</title>
    <url>/2021/12/30/%E5%88%9D%E8%AF%86TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/</url>
    <content><![CDATA[<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E5%88%9D%E5%A7%8BTCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/%E5%88%9D%E8%AF%86TCP%20IP%E5%8D%8F%E8%AE%AE%E6%97%8F.png?versionId=CAEQGRiBgMDG4eKp8BciIDc4YjRlNWZiOTUwNzRlNGY5OTFiNmQzYjBlZWZkODRk"></p>
<p>&emsp;  你好，我是小八。今天我们来讲一下TCP/IP协议族。</p>
<h2 id="初识TCP-IP协议族"><a href="#初识TCP-IP协议族" class="headerlink" title="初识TCP/IP协议族"></a>初识TCP/IP协议族</h2><p>&emsp; HTTP属于TCP/IP的一个子类，通常使用的网络（包括互联网）都是在TCP/IP协议族的基础上运作。</p>
<h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p>&emsp;计算机网络设备之间进行信息交互就需要基于相同的方法或者说是同一种协议才能进行通信。就比如：我们需要进行通信的时候，就需要知道如何探测到通信的目标、从哪一边开始发起通信请求、使用什么语言通信、怎么结束通信请求等所制定的规则，便被成为协议（protocol）。</p>
<p>&emsp;<strong>而TCP/IP协议族就是互联网相关的各类协议族的总称。</strong>对于TCP/IP协议族，通常有两种说法，一是指TCP和IP这两种协议，二是指TCP/IP在IP协议的通信中，使用到的协议族的统称。</p>
<p>TCP/IP协议族如下图：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E5%88%9D%E5%A7%8BTCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/%E6%97%8F%E7%BE%A4%E5%9B%BE.png?versionId=CAEQGRiBgIDE4eKp8BciIDdkZjU1ZTAzOTEzYTQ3ZWFhY2IxMzIyMTU5OTNlMjBi" alt="image-20211230151831761"></p>
<h3 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP/IP的分层管理"></a>TCP/IP的分层管理</h3><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E5%88%9D%E5%A7%8BTCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/TCP%20IP%E5%88%86%E5%B1%82%E7%AE%A1%E7%90%86.png?versionId=CAEQGRiBgICU4eKp8BciIGU0OTczOWY0YmE5YjRjYmRhMjRiNTdhOGUwOTAzOTEz" alt="image-20211230151253140"></p>
<p>&emsp;协议族通过分层化，可以高效管理改变不同层次设计的任务，把每个层次之间的不同接口规划好之后，每个层次的内部设计也可以自由改动，而不需要替换所有部分整体。</p>
<p>&emsp;<strong>应用层：</strong></p>
<p>&emsp;&emsp;预存各类通用的应用服务，决定了向用户提供应用服务时通信的活动。其中HTTP（超文本传输协议）、FTP（文件传输协议）、DNS（域名协议）等服务在此层</p>
<p>&emsp;<strong>传输层：</strong></p>
<p>&emsp;&emsp;对应用层提供处于<strong>网络连接中</strong>的两台计算机的<strong>数据传输</strong>。在此层中有两种不同性质的协议：TCP（传输控制协议）和UDP（用户数据报协议）</p>
<p>&emsp;<strong>网络层：</strong></p>
<p>&emsp;&emsp;用来处理在网络上流动的数据包，该层规定与对方计算机进行传输时，通过选择某一种路径（或者说是某一条传输路线）到达对方计算机，并且把数据包传给对方。因此此层又被称为<strong>网络互连层</strong>。</p>
<p>&emsp;&emsp;<strong>数据包</strong>是网络传输的最小数据单位。</p>
<p>&emsp;<strong>链路层：</strong></p>
<p>&emsp;&emsp;用来处理连接网络的硬件部分的层次，包括控制操作系统，硬件设备驱动，NIC（网络适配器，即网卡）等一系列可见的物理传输硬件设备（媒介）。</p>
<h3 id="TCP-IP通信传输流"><a href="#TCP-IP通信传输流" class="headerlink" title="TCP/IP通信传输流"></a>TCP/IP通信传输流</h3><p>xxxxxxxxxx class Solution {    public boolean isPalindrome(int x) {        // 特殊情况：        // 如上所述，当 x &lt; 0 时，x 不是回文数。        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，        // 则其第一位数字也应该是 0        // 只有 0 满足这一属性        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) {            return false;        }​        int revertedNumber = 0;        while (x &gt; revertedNumber) {            revertedNumber = revertedNumber * 10 + x % 10;            x /= 10;        }​        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。        return x == revertedNumber || x == revertedNumber / 10;    }}​作者：力扣官方题解链接：<a href="https://leetcode.cn/problems/palindrome-number/solutions/281686/hui-wen-shu-by-leetcode-solution/%E6%9D%A5%E6%BA%90%EF%BC%9A%E5%8A%9B%E6%89%A3%EF%BC%88LeetCode%EF%BC%89%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82java">https://leetcode.cn/problems/palindrome-number/solutions/281686/hui-wen-shu-by-leetcode-solution/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。java</a></p>
<p>xxxxxxxxxx ​class Solution {    public int[] twoSum(int[] nums, int target) {        for(int i = 0;i&lt;nums.length;i++){            for(int j=i+1;j&lt;nums.length;j++){                if(nums[i]+nums[j]==target){                    return new int[]{i,j};                }            }        }         return new int[0];    }}Java []</p>
<p>&emsp;发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。 这种把数据信息包装起来的做法称为<strong>封装（encapsulate）</strong>（就类似于C++类的使用，将类中的成员和数据进行封装）。下图为例：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E5%88%9D%E5%A7%8BTCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/%E6%B5%81%E7%A8%8B%E5%9B%BE2.png?versionId=CAEQGRiBgICx4eKp8BciIDIzNDlkYjhjYWM1YjQyYTRiNTVjOTk4NmVhYmE0YWEz" alt="image-20211230160020206"></p>
<p>&emsp;</p>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题之两数之和</title>
    <url>/2022/10/26/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<blockquote>
<p>Problem: <a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h1><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20221026204201974.png" alt="两数之和"></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>看到这一题我首先想到的就是通过类似于冒泡排序的思想，通过两个for循环对数组里面的值进行一一相加并跟target进行比较，如果值等于target那么就返回，否则就进行下一次循环，也就是所谓的暴力解法，不过这样真的非常损耗时间复杂度</p>
</blockquote>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote>
<p>这里面要注意的是，同一个数x不能进行重复相加，那么就需要我们进行一一枚举，即在数组nums中寻找中有没有一个数是target - x，且当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。如果找到了这个target - x则返回x和target - x的下标index即可</p>
</blockquote>
<p>代码</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li><p>时间复杂度: </p>
<blockquote>
<p> $O(N2)$</p>
</blockquote>
</li>
<li><p>空间复杂度: </p>
<blockquote>
<p> $O(1)$</p>
</blockquote>
</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题之回文数</title>
    <url>/2022/10/27/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>Problem: <a href="https://leetcode.cn/problems/palindrome-number/description/">9. 回文数</a></p>
</blockquote>
<p>[TOC]</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote>
<p>看到这题的第一想法就是把数字x进行反转得到数字reverse，然后与x进行比较是否相等即可，刚开始我想的是把数字转成字符串然后使用反转函数直接反转，最后使用eqauls方法进行比较即可，但是我忘记了怎么将数字转换成String类型的字符串。后来遍知道一个数一个数字进行翻转</p>
</blockquote>
<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote>
<p>由题可知x&lt;0的时候因为含有负号，故所有小于0的数都不是回文数，直接return false即可，x&gt;0的时候，我用一个temp表示x翻转后的数字，num用于x逐一翻转，直到num/10==0的时候说明翻转完成，得到的结果return num == x的结果即可。</p>
</blockquote>
<p>但是，看了题解之后我发现其实翻转一半就行了，就算是奇数个位数，最后return reverse/10 == x即可</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul>
<li><p>时间复杂度: </p>
<blockquote>
<p>O(logn)</p>
</blockquote>
</li>
<li><p>空间复杂度: </p>
<blockquote>
<p>O(1)</p>
</blockquote>
</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> x;</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">                temp = temp*<span class="number">10</span>+num%<span class="number">10</span>;</span><br><span class="line">                num = num/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x == temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">revertedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/palindrome-number/solutions/281686/hui-wen-shu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题之两数相加</title>
    <url>/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[2,4,3]</span>, l2 = <span class="comment">[5,6,4]</span></span><br><span class="line">输出：<span class="comment">[7,0,8]</span></span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[0]</span>, l2 = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：l1 = [<span class="number">9,9,9,9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>], l2 = [<span class="number">9,9,9,9</span>]</span><br><span class="line">输出：[<span class="number">8,9,9,9</span>,<span class="number">0,0,0,1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<h2 id="题解如下："><a href="#题解如下：" class="headerlink" title="题解如下："></a>题解如下：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//进位数字</span></span><br><span class="line">        <span class="comment">//定义一个可移动的指针，用来指向存储两个数之和的位置</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">         <span class="comment">//定义一个新联表伪指针，用来指向头指针，返回结果</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="comment">//当l1 不等于null或l2 不等于空时，就进入循环</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果l1 不等于null时，就取他的值，等于null时，就赋值0，保持两个链表具有相同的位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="comment">//将两个链表的值，进行相加，并加上进位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + carry;</span><br><span class="line">            <span class="comment">//计算进位数</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//计算两个数的和，此时排除超过10的请况（大于10，取余数）</span></span><br><span class="line">            sum %= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//将求和数赋值给新链表的节点，</span></span><br><span class="line">            <span class="comment">//注意这个时候不能直接将sum赋值给cur.next = sum。这时候会报，类型不匹配。</span></span><br><span class="line">            <span class="comment">//所以这个时候要创一个新的节点，将值赋予节点</span></span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line">             <span class="comment">//将新链表的节点后移</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="comment">//当链表l1不等于null的时候，将l1 的节点后移</span></span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">null</span>)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果最后两个数，相加的时候有进位数的时候，就将进位数，赋予链表的新节点。</span></span><br><span class="line">        	<span class="comment">//两数相加最多小于20，所以的的值最大只能时1</span></span><br><span class="line">            <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题之寻找两个正序数组的中位数</title>
    <url>/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,3]</span>, nums2 = <span class="comment">[2]</span></span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = <span class="comment">[1,2,3]</span> ，中位数 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 <span class="comment">(2 + 3)</span> / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m &lt;= 1000</code></li>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= m + n &lt;= 2000</code></li>
<li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li>
</ul>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>xxxxxxxxxx ​class Solution {    public int[] twoSum(int[] nums, int target) {        for(int i = 0;i&lt;nums.length;i++){            for(int j=i+1;j&lt;nums.length;j++){                if(nums[i]+nums[j]==target){                    return new int[]{i,j};                }            }        }         return new int[0];    }}Java []</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[m+n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            nums[i] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n; j++)&#123;</span><br><span class="line">            nums[nums1.length + j] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span>(nums.length % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[(m + n) / <span class="number">2</span> - <span class="number">1</span>] + nums[(m + n) / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[(m + n) / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他方法还在研究ing。。。。</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题之无重复字符的最长子串</title>
    <url>/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下"></a>题目如下</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<h2 id="题解如下："><a href="#题解如下：" class="headerlink" title="题解如下："></a>题解如下：</h2><p>主要用到的思想就是滑动窗口，通过HashMap集合的key值不可重复原理来判断是否遇到重复的字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//考虑孔字符串的情况</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//统计最大的子串长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左指针指向子串的第一个字符index</span></span><br><span class="line">        <span class="comment">//以字符串的一个字符作为key,其对应的index作为value</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;<span class="comment">//判断是否i位置下的字符是否有对应的value，如果有那么就说明重复了，此时将左指针定位到对应的value下，因为对应的value保存的就是此时此字符的index</span></span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            <span class="comment">//此时最大的子串不重复长度就是i - left + 1(即此时正在扫描的子串长度) 和 maxLength(上一串扫描的子串长度) 二者最大值之一。</span></span><br><span class="line">            maxLength = Math.max(maxLength,i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题之最长回文子串</title>
    <url>/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
<h2 id="题解如下"><a href="#题解如下" class="headerlink" title="题解如下"></a>题解如下</h2><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230321164819370.png" alt="image-20230321164819370"></p>
<h5 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">boolean</span> [][]dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">//所有的一个字符的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">//记录回文子串的初始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录回文子串长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">childLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span>; l &lt;= len;l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">                <span class="comment">//j代表子串的尾字符的index，即确定右边界</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果尾字符超出字符串最大长度、跳出循环</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= len)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(charArray[i]!=charArray[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//可能是一个或者两个或者三个字符的子串</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则就依次递归</span></span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若 dp[i][l] == true 成立，就表示s[i....l]是回文，记录此时回文的长度以及起始位置</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; childLen)&#123;</span><br><span class="line">                    childLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin + childLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题之连续子数组的最大和</title>
    <url>/2023/02/02/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=cug7nw1"><em>剑指 Offer 42. 连续子数组的最大和</em></a></p>
<p>[TOC]</p>
<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230202220726900.png"></p>
<h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h3 id="1、动态规划"><a href="#1、动态规划" class="headerlink" title="1、动态规划"></a>1、动态规划</h3><h4 id="推想："><a href="#推想：" class="headerlink" title="推想："></a>推想：</h4><p>​    若nums数组的长度为n，下标则为0~n-1，用f(i)表示以第i个数结尾的<strong>连续子数组的最大和</strong>，故有：</p>
<p>​<br>$$<br>max{f(i)},0≤i≤n-1<br>$$</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>​    求出每段以第i个数结尾的子数组的f(i)，返回最大的f(i)即可</p>
<h4 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h4><p>​    考虑nums[i]单独成一段还是加入f(i-1)这一段子数组，则可以通过判断nums[i] + f(i-1)和nums[i]的大小实现</p>
<p>$$<br>f(i) = max{nums[i]+f(i-1),nums[i]}<br>$$</p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//存储f(i - 1)的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">           pre = Math.max(x + pre, x);</span><br><span class="line">           maxSum = Math.max(pre , maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、分治法："><a href="#2、分治法：" class="headerlink" title="2、分治法："></a>2、分治法：</h3><p>见<a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solutions/876881/lian-xu-zi-shu-zu-de-zui-da-he-by-leetco-tiui/">leetcode题解</a>(点击即可查看)</p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>备份hexo-_o-U盘篇</title>
    <url>/2023/05/16/%E5%A4%87%E4%BB%BDhexo-o-U%E7%9B%98%E7%AF%87/</url>
    <content><![CDATA[<h2 id="新机环境搭建"><a href="#新机环境搭建" class="headerlink" title="新机环境搭建"></a>新机环境搭建</h2><p>​    1、安装Node.js</p>
<p>​    2、安装Git</p>
<p>​    3、新建存放Blog的文件夹</p>
<h2 id="拷贝旧机器中得文件-文件夹"><a href="#拷贝旧机器中得文件-文件夹" class="headerlink" title="拷贝旧机器中得文件/文件夹"></a>拷贝旧机器中得文件/文件夹</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line"><span class="keyword">package</span>.json</span><br><span class="line">scaffolds/</span><br><span class="line"><span class="keyword">source</span>/</span><br><span class="line">themes/</span><br><span class="line">其中/代表拷贝的是文件夹</span><br></pre></td></tr></table></figure>

<h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>右键打开Git bash，依次输入下列命令之后，安装相关依赖</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>安装hexo</span><br><span class="line">   <span class="built_in">npm</span> install -g hexo</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>本地测试的时候需要用hexo server</span><br><span class="line">   <span class="built_in">npm</span> i hexo-server</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>将文章部署到github上的模块</span><br><span class="line">   <span class="built_in">npm</span> install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>安装RSS插件</span><br><span class="line">   <span class="built_in">npm</span> install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>添加Sitemap,加速网页收录速度</span><br><span class="line">   <span class="built_in">npm</span> install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>

<h2 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s -g == hexo g + hexo s</span><br></pre></td></tr></table></figure>

<p>在浏览器打开<a href="http://localhost:4000/">http://localhost:4000</a>查看效果</p>
]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>自学如何使用Git+Hexo搭建个人博客</title>
    <url>/2021/11/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Git%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>&ensp; &ensp;Hello,我们又见面了，不好意思，各位小伙伴，今天身边出了点状况，本来上午就想着更新的，但是下午发生了一件很让人不爽的事情，就耽误了分享学习心得的方法与步骤，好了，言归正传，不知道你们看了上一篇关于“Git从0到基本运用”的文章，有没有学会Git的使用呢？</p>
<p>&ensp; &ensp;要是还没有学会呢，那还得加油啊，学会了的话，那我们现在就进入正题吧，我们既然学会了这个Git，那我们就来学习一下如何通过Git和Hexo搭建一个属于自己的个人博客吧</p>
<span id="more"></span>
<h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><blockquote>
<ul>
<li>准备一个Github账号（在前面学习Git的时候应该就准备好了）</li>
<li>安装node.js，npm，并了解相关知识</li>
<li>安装Git for Windows（不同系统安装对应不同的版本）</li>
</ul>
</blockquote>
<h2 id="三、应用简介："><a href="#三、应用简介：" class="headerlink" title="三、应用简介："></a>三、应用简介：</h2><h3 id="3-1Node-js"><a href="#3-1Node-js" class="headerlink" title="3.1Node.js:"></a>3.1Node.js:</h3><h4 id="ensp-ensp-3-1-1-由来及优势："><a href="#ensp-ensp-3-1-1-由来及优势：" class="headerlink" title="&ensp; &ensp;3.1.1 由来及优势："></a>&ensp; &ensp;3.1.1 由来及优势：</h4><p>&ensp; &ensp; Node.js发布于2009年5月，由Ryan Dahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I/O模型，让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。</p>
<p>&ensp; &ensp; Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好，V8引擎执行Javascript的速度非常快，性能非常好，基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。</p>
<h4 id="ensp-ensp-3-1-2-主要功能："><a href="#ensp-ensp-3-1-2-主要功能：" class="headerlink" title="&ensp; &ensp;3.1.2 主要功能："></a>&ensp; &ensp;3.1.2 主要功能：</h4><p>&ensp; &ensp; V8引擎本身使用了一些最新的编译技术。这使得用Javascript这类脚本语言编写出来的代码运行速度获得了极大提升，又节省了开发成本。对性能的苛求是Node的一个关键因素。 Javascript是一个事件驱动语言，Node利用了这个优点，编写出可扩展性高的服务器。Node采用了一个称为“事件循环(event loop）”的架构，使得编写可扩展性高的服务器变得既容易又安全。提高服务器性能的技巧有多种多样。Node选择了一种既能提高性能，又能减低开发复杂度的架构。这是一个非常重要的特性。并发编程通常很复杂且布满地雷。Node绕过了这些，但仍提供很好的性能。</p>
<p>&ensp; &ensp; Node采用一系列“非阻塞”库来支持事件循环的方式。本质上就是为文件系统、数据库之类的资源提供接口。向文件系统发送一个请求时，无需等待硬盘（寻址并检索文件），硬盘准备好的时候非阻塞接口会通知Node。该模型以可扩展的方式简化了对慢资源的访问， 直观，易懂。尤其是对于熟悉onmouseover、onclick等DOM事件的用户，更有一种似曾相识的感觉。</p>
<p>&ensp; &ensp; 虽然让Javascript运行于服务器端不是Node的独特之处，但却是其一强大功能。不得不承认，浏览器环境限制了我们选择编程语言的自由。任何服务器与日益复杂的浏览器客户端应用程序间共享代码的愿望只能通过Javascript来实现。虽然还存在其他一些支持Javascript在服务器端 运行的平台，但因为上述特性，Node发展迅猛，成为事实上的平台。</p>
<p>&ensp; &ensp; 在Node启动的很短时间内，社区就已经贡献了大量的扩展库（模块）。其中很多是连接数据库或是其他软件的驱动，但还有很多是凭他们的实力制作出来的非常有用的软件。</p>
<p>&ensp; &ensp; 最后，不得不提到的是Node社区。虽然Node项目还非常年轻，但很少看到对一个项目如此狂热的社区。不管是新手，还是专家，大家都围绕着项目，使用并贡献自己的能力，致力于打造一个探索、支持、分享、听取建议的乐土。</p>
<h3 id="ensp-ensp-3-2-NPM："><a href="#ensp-ensp-3-2-NPM：" class="headerlink" title="&ensp; &ensp;3.2 NPM："></a>&ensp; &ensp;3.2 NPM：</h3><p>&ensp; &ensp;&ensp; &ensp; NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<blockquote>
<p>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</p>
</blockquote>
<blockquote>
<p>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</p>
</blockquote>
<blockquote>
<p>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p>
</blockquote>
<h3 id="ensp-ensp-3-3-其他应用："><a href="#ensp-ensp-3-3-其他应用：" class="headerlink" title="&ensp; &ensp;3.3 其他应用："></a>&ensp; &ensp;3.3 其他应用：</h3><p>&ensp; &ensp;&ensp; &ensp;Git的功能在前面的学习之后，大家也有所了解了，这里也就不多说了。</p>
<h2 id="四、搭建github博客"><a href="#四、搭建github博客" class="headerlink" title="四、搭建github博客"></a>四、搭建github博客</h2><h3 id="4-1-创建仓库"><a href="#4-1-创建仓库" class="headerlink" title="4.1 创建仓库"></a>4.1 创建仓库</h3><p>&ensp; &ensp;登录Github网站新建一个名为<code>你的用户名.github.io</code>比如说，如果你的github用户名是pengzihao166，那么你就新建pengzihao166.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <code>http://pengzihao166.github.io</code> 了。</p>
<p>&ensp; &ensp;由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p>
<p>注意：</p>
<p>&ensp; &ensp;1、注册的邮箱一定要验证，否则不会成功；</p>
<p>&ensp; &ensp;2、仓库名字必须是：<code>username.github.io</code>，其中<code>username</code>是你的github用户名。</p>
<p>&ensp; &ensp;3、仓库创建成功一般不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我等了十几分钟才生效。</p>
<p>&ensp; &ensp;当时还以为我操作失败了，然后疯狂重新删库，建库，就这个步骤我活活弄了一小时左右，后来把那个挂后台，去打了一把LOL大乱斗，回来之后发现好了，就继续战斗搭建博客了。</p>
<h3 id="4-2-绑定域名"><a href="#4-2-绑定域名" class="headerlink" title="4.2 绑定域名"></a>4.2 绑定域名</h3><p>&ensp; &ensp;这个有钱的，可以去买一个域名再去绑定，什么腾讯云，阿里云，godaddy都可以。</p>
<p>&ensp; &ensp;当然，你不绑定域名肯定也是可以的，就用默认的 <code>xxx.github.io</code> 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那就去买一个域名吧。</p>
<h2 id="五、配置SSH-Key"><a href="#五、配置SSH-Key" class="headerlink" title="五、配置SSH Key"></a>五、配置SSH Key</h2><p>&ensp; &ensp;其实在你们学习git的时候就已经有了SSH Key的配置，这里我就再稍微讲一下怎么进行配置吧。</p>
<blockquote>
<p>$ cd ~/. ssh #检查本机已存在的ssh密钥</p>
</blockquote>
<p>如果提示：No such file or directory 说明你是第一次使用git。</p>
<blockquote>
<p>ssh-keygen -t rsa -C “邮件地址”</p>
</blockquote>
<p>&ensp; &ensp;然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key,粘贴上去。</p>
<p>注意：这里是个人设置界面，不是你的远程库的那个settings！！！截图如下：</p>
<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/git和hexo搭建个人博客/QQ%E5%9B%BE%E7%89%8720211205165600.png?versionId=CAEQFxiBgICVrqGn7BciIDQwNjM5ODE0YTJjNDQ1ODg4OGYxODc3YjgzMGYyNGE1">

<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/git和hexo搭建个人博客/QQ%E5%9B%BE%E7%89%8720211205170337.jpg?versionId=CAEQFxiBgICr4Kun7BciIDNiNTA4OTFkZmNiZjQwN2FiZWNhMzNiNTQ0MzJkNDQw">

<h3 id="5-1-测试是否成功"><a href="#5-1-测试是否成功" class="headerlink" title="5.1 测试是否成功"></a>5.1 测试是否成功</h3><p>&ensp; &ensp;<code>$ ssh -T git@github.com </code># 注意邮箱地址不用改</p>
<p>&ensp; &ensp;如果提示Are you sure you want to continue connecting (yes/no)?，输入yes</p>
<p>&ensp; &ensp;然后会看到：</p>
<p>&ensp; &ensp;&gt; Hi xxxxx! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
<p>&ensp; &ensp;看到这个信息说明SSH已配置成功！</p>
<p>&ensp; &ensp;此时你还需要配置：</p>
<p>&ensp; &ensp;<code>$ git config --global user.name &quot;xxxx&quot;</code></p>
<p>&ensp; &ensp;// xxx是指你的github用户名，非昵称</p>
<p>&ensp; &ensp;<code>$ git config --global user.email  &quot;xxx@qq.com&quot;</code></p>
<p>&ensp; &ensp;// xxx是指填写你的github注册邮箱</p>
<p>注意：这里验证结果展示图如下：</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/QQ%E5%9B%BE%E7%89%8720211204135329.png?versionId=CAEQFxiBgICPxYSQ7BciIGU4NjQzYWNkMzY3NTQxYjc5OTU0MTU3MzVjZDU1ZGUw"></p>
<p>&ensp; &ensp;你没有看错，没错就是啥都不会显示，然后你就可以进行下面的操作了</p>
<h2 id="六、使用hexo写博客"><a href="#六、使用hexo写博客" class="headerlink" title="六、使用hexo写博客"></a>六、使用hexo写博客</h2><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>下面的注意事项，需要各位小伙伴认真看好了，并且记住了，不然对你以后写博客的改动有很大影响。</p>
<ul>
<li><p>前面的配置环境只要搭好了，其实后面也就不难了，但是！！！也是非常重要的一个内容，不然前面的全白搭了</p>
</li>
<li><p>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行。</p>
</li>
<li><p>hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的<code>_config.yml</code>；</p>
</li>
</ul>
<h3 id="6-1-npm的安装"><a href="#6-1-npm的安装" class="headerlink" title="6.1 npm的安装"></a>6.1 npm的安装</h3><blockquote>
<p>$ npm install -g hexo</p>
</blockquote>
<h3 id="6-2-初始化"><a href="#6-2-初始化" class="headerlink" title="6.2 初始化"></a>6.2 初始化</h3><p>&ensp; &ensp;在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取,建议就取名hexo，方便以后代码管理），比如我的是E:/hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p>
<p>初始化的方法有两种：</p>
<p>1、可以随便找个地方右键打开 git bash here，然后输入cd /e/hexo/</p>
<blockquote>
<p>$ cd /e/hexo/</p>
</blockquote>
<blockquote>
<p>$ hexo init</p>
</blockquote>
<p>2、或者进入你前面创建的E:/hexo的文件夹之后，右键打开 git bash here，直接输入</p>
<blockquote>
<p>$ hexo init</p>
</blockquote>
<p>&ensp; &ensp;hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下：</p>
<blockquote>
<p>$ hexo g # 生成文件</p>
</blockquote>
<blockquote>
<p>$ hexo s # 启动服务</p>
</blockquote>
<p>&ensp; &ensp;执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的</p>
<p>hexo s是开启本地预览服务，打开浏览器访问 <code>http://localhost:4000</code> 即可看到内容</p>
<h3 id="6-3-主题修改-这一步可以不用做，等学会后面的操作之后，再去寻找自己喜欢的主题Theme"><a href="#6-3-主题修改-这一步可以不用做，等学会后面的操作之后，再去寻找自己喜欢的主题Theme" class="headerlink" title="6.3 主题修改(这一步可以不用做，等学会后面的操作之后，再去寻找自己喜欢的主题Theme)"></a>6.3 主题修改(这一步可以不用做，等学会后面的操作之后，再去寻找自己喜欢的主题Theme)</h3><p>&ensp; &ensp;既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。</p>
<p>&ensp; &ensp;个人比较喜欢的主题是：hexo-theme-yilia。</p>
<p>&ensp; &ensp;1、首先下载这个主题：</p>
<blockquote>
<p><code>$ cd /e/hexo/（或者进入你前面创建的E:/hexo的文件夹之后，右键打开 git bash here）</code></p>
</blockquote>
<blockquote>
<p><code>$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></p>
</blockquote>
<p>&ensp; &ensp;2、下载后的主题都在你的hexo的theme里面：</p>
<p>&ensp; &ensp;3、修改hexo文件夹根目录下的<code>_config.yml</code>（并不是theme里面的某个主题文件夹下的<code>_config.yml</code>）中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。</p>
<p>&ensp; &ensp;4、如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。（建议每次hexo s -g之前都clean一下，养成一个小习惯）</p>
<h3 id="6-4-上传操作"><a href="#6-4-上传操作" class="headerlink" title="6.4 上传操作"></a>6.4 上传操作</h3><p>&ensp; &ensp;1、首先安装一个插件：</p>
<p>&ensp; &ensp;<code>$npm install hexo-deployer-git --save</code></p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/assets/npm.png?versionId=CAEQFxiBgMDA6KCQ7BciIDBlNTM5NmIzMGI3NTRiMDRhMzFhNGUyZGJlYTEzMTE5"></p>
<p>&ensp; &ensp;因为没有这个插件，你在hexo d的时候会出现错误，其它命令不确定，部署这个命令一定要用git bash。</p>
<p>&ensp; &ensp;打开你的git bash，cd到你前面创建的hexo文件夹，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会：</p>
<p>&ensp; &ensp;如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。</p>
<p>&ensp; &ensp;首先，ssh key肯定要配置好。</p>
<p>&ensp; &ensp;其次，配置hexo根目录中的_config.yml中有关deploy的部分：</p>
<p>&ensp; &ensp;正确写法：</p>
<p>&ensp; &ensp;<code>deploy:</code></p>
<p>&ensp; &ensp;<code>type: git</code></p>
<p>&ensp; &ensp;<code>repository: git@github.com:pengzihao166/pengzihao166.github.io.git</code></p>
<p>&ensp; &ensp;<code>branch: master</code></p>
<p>&ensp; &ensp;错误写法：</p>
<p>&ensp; &ensp;<code>deploy:</code></p>
<p>&ensp; &ensp;<code>type: github</code></p>
<p>&ensp; &ensp;<code>repository: https://github.com/pengzihao166/pengzihao166.github.io.git</code></p>
<p>&ensp; &ensp;<code>branch: master</code></p>
<h3 id="6-5-常见hexo命令："><a href="#6-5-常见hexo命令：" class="headerlink" title="6.5 常见hexo命令："></a>6.5 常见hexo命令：</h3><blockquote>
<p>1、hexo new “postName” #新建文章</p>
</blockquote>
<blockquote>
<p>2、hexo new page “pageName” #新建页面</p>
</blockquote>
<blockquote>
<p>3、hexo generate #生成静态页面至public目录=hexo g</p>
</blockquote>
<blockquote>
<p>4、hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）=hexo s</p>
</blockquote>
<blockquote>
<p>5、hexo deploy #部署到GitHub  =  hexo d</p>
</blockquote>
<blockquote>
<p>6、hexo help  # 查看帮助</p>
</blockquote>
<blockquote>
<p>7、hexo version  #查看Hexo的版本   =    hexo -v</p>
</blockquote>
<blockquote>
<p>8、hexo s -g #生成并本地预览</p>
</blockquote>
<blockquote>
<p>9、hexo d -g #生成并上传</p>
</blockquote>
<p>&ensp; &ensp;注意：如果hexo s 失败，可能是你的hexo根目录下的node_modules文件出问题或者你的端口被占用了，可以试试hexo s -p 5000(这个5000可以改成任何你想的端口数字不唯一)，还是不行那就删掉node_modules，然后在hexo的根目录下git bash here，再输入npm install，会自动重新配置node_modules，这样应该就能解决了。</p>
<p>&emsp;小编就因为遇到过这种情况，所以在这里分享一下在写完博客之后，运行命令的时候遇到的问题的解决方案。</p>
<h3 id="6-6-写博客"><a href="#6-6-写博客" class="headerlink" title="6.6 写博客"></a>6.6 写博客</h3><p>&ensp; &ensp;定位到我们的hexo根目录，执行命令：</p>
<blockquote>
<p>hexo new  ‘xxx’ (xxx就是你的博客名字)</p>
</blockquote>
<blockquote>
<p>hexo会帮我们在e:/hexo/source/_posts下生成相关md文件：</p>
</blockquote>
<p>&ensp; &ensp;我们只需要打开这个文件就可以开始写博客了,具体用什么打开md格式的文件进行编写博客，小编这里使用的是Typora（或者vscode也行）兼容md格式，这个大家可以自己使用喜欢的编辑器就行了，没有什么特殊要求，只要能兼容Markdown格式的就行了。</p>
<p>&ensp; &ensp;记住奥，每次写完博客记得，在你的hexo根目录下 git bash here，再进行</p>
<blockquote>
<p>hexo clean</p>
</blockquote>
<blockquote>
<p>hexo s -g</p>
</blockquote>
<p>&ensp; &ensp;进行本地预览要是符合自己想要的样子之后,再进行 </p>
<blockquote>
<p>hexo d</p>
</blockquote>
<p>&ensp; &ensp;最后打开你的<code>http://pengzihao166.github.io</code>(记得把pengzihao166改成你自己的github的用户名)，如果你绑定了域名你也可以直接输入你自己的域名进入一个属于自己的blog。</p>
<h2 id="结束语："><a href="#结束语：" class="headerlink" title="结束语："></a>结束语：</h2><p>&ensp; &ensp;这次运用hexo+git搭建博客，不知道你们是否学会了呢，要是内容含任何的错误知识点，请及时联系小编，或者在下方进行评论提出，方便小编及时修改错误，免得对其他小伙伴的学习造成勿扰，当然有什么观点也可以在评论中表达出来，希望大家可以参与到其中来。</p>
<p>&ensp; &ensp;部分内容转载自<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">小茗同学博客园</a>,如有侵权，请立刻联系小编，进行修改完善。</p>
]]></content>
      <tags>
        <tag>Git+Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>微布开发-二手市场开发思路(小程序+Java后端 尚未完更)</title>
    <url>/2023/08/03/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="小程序端"><a href="#小程序端" class="headerlink" title="小程序端"></a>小程序端</h3><p>categoryBid：二级分类类别的主键id</p>
<p>allList：全部商品列表</p>
<p>sellList：转卖商品列表</p>
<p>askBuyList：求购商品列表</p>
<p>type：一级分类</p>
<h4 id="开发思路如下："><a href="#开发思路如下：" class="headerlink" title="开发思路如下："></a>开发思路如下：</h4><ol>
<li>默认获取全部所有的商品list用于初始化加载页面</li>
<li>滑动一级分类，确认一级分类type类型<ol>
<li>Type = 转卖<ol>
<li>初始化<ol>
<li>默认转卖一级分类的所有商品列表</li>
<li>滑动到二级分类，根据二级分类类型对应的categoryBid拉取列表</li>
</ol>
</li>
<li>下拉刷新<ol>
<li>若为一级分类的所有商品列表，categoryBid = null</li>
<li>若具体到二级分类的具体类型，categoryBid = 对应的二级分类bid</li>
</ol>
</li>
<li>上滑加载<ol>
<li>根据一级分类和二级分类(categoryBid )的类别确定获取什么类型的list并且赋值到allList/sellList/askBuyList</li>
</ol>
</li>
</ol>
</li>
<li>Type = 求购<ol>
<li>初始化<ol>
<li>默认求购一级分类的所有商品列表</li>
<li>滑动到二级分类，根据二级分类类型对应的categoryBid拉取列表</li>
</ol>
</li>
<li>下拉刷新<ol>
<li>若为一级分类的所有商品列表，categoryBid = null</li>
<li>若具体到二级分类的具体类型，categoryBid = 对应的二级分类bid</li>
</ol>
</li>
<li>上滑加载<ol>
<li>根据一级分类和二级分类的类别确定获取什么类型的list并且赋值到allList/sellList/askBuyList</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="Java后端："><a href="#Java后端：" class="headerlink" title="Java后端："></a>Java后端：</h4>]]></content>
      <tags>
        <tag>微布开发思路总结</tag>
      </tags>
  </entry>
  <entry>
    <title>微布开发-微信三方接口文本校验校验开发思路</title>
    <url>/2023/05/27/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%BE%AE%E4%BF%A1%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E6%96%87%E6%9C%AC%E6%A0%A1%E9%AA%8C%E6%A0%A1%E9%AA%8C%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="根据文档要求总结分为以下的情况："><a href="#根据文档要求总结分为以下的情况：" class="headerlink" title="根据文档要求总结分为以下的情况："></a>根据文档要求总结分为以下的情况：</h3><ol>
<li>文本内容正常 (suggest: “pass”, label: 100)：<ol>
<li>情况处理：如果文本内容被判定为正常，可以允许发布该文本内容。</li>
</ol>
</li>
<li>文本内容命中关键词，但不违规 (suggest: “pass”, label: 20006)：<ol>
<li>情况处理：如果文本内容命中自定义关键词但不违规，可以允许发布该文本内容，同时可能根据需要记录命中的关键词和概率信息。</li>
</ol>
</li>
<li>文本内容建议审核 (suggest: “review”)：<ol>
<li>情况处理：如果文本内容被建议进行审核，您可以将该内容设置为待审核状态，让人工审核来决定是否发布该内容。</li>
</ol>
</li>
<li>文本内容命中违规标签 (suggest: “risky”)：<ol>
<li>情况处理：如果文本内容被判定为违规，应禁止发布该内容，并通知用户违规原因。</li>
</ol>
</li>
<li>文本内容属于广告 (label: 10001)：<ol>
<li>情况处理：如果文本内容被判定为广告，应禁止发布该内容，并通知用户不允许发布广告内容。</li>
</ol>
</li>
<li>文本内容属于色情、辱骂、违法犯罪等 (label: 20002, 20003, 20006等)：<ol>
<li>情况处理：如果文本内容被判定为色情、辱骂、违法犯罪等，应禁止发布该内容，并根据需要采取进一步的处理措施，比如记录日志或进行用户封禁等。</li>
</ol>
</li>
</ol>
<h3 id="开发思路如下："><a href="#开发思路如下：" class="headerlink" title="开发思路如下："></a>开发思路如下：</h3><ol>
<li>从Redis中获取到AccessToken</li>
<li>查库获取发布者微信的openid</li>
<li>调用<a href="https://api.weixin.qq.com/wxa/msg_sec_check?access_token=%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%A0%A1%E9%AA%8C%E8%BF%94%E5%9B%9E%E5%8F%82%E6%95%B0">https://api.weixin.qq.com/wxa/msg_sec_check?access_token=接口，校验返回参数</a><ol>
<li>errocode == 0<ol>
<li>获取result对象的suggest参数值并进行比较<ol>
<li>如果文本内容建议审核，则根据实际需求执行人工审核流程，”review”.equals(suggest)</li>
<li>如果文本内容正常或命中关键词但不违规，允许发布，”pass”.equals(suggest)</li>
<li>如果文本内容被判定为违规，禁止发布，并输出违规信息，”risky”.equals(suggest)<ol>
<li>此时可以遍历detail数组，并获取对应的prob如果其中有敏感词汇prob&gt;50就不准发布。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="大致代码逻辑如下："><a href="#大致代码逻辑如下：" class="headerlink" title="大致代码逻辑如下："></a>大致代码逻辑如下：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(String result)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">JSONObject</span> <span class="variable">responseJson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(result);</span><br><span class="line">          <span class="type">int</span> <span class="variable">errcode</span> <span class="operator">=</span> responseJson.getInt(<span class="string">&quot;errcode&quot;</span>);</span><br><span class="line">          <span class="type">String</span> <span class="variable">errmsg</span> <span class="operator">=</span> responseJson.getString(<span class="string">&quot;errmsg&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (errcode == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 获取综合结果信息</span></span><br><span class="line">              <span class="type">JSONObject</span> <span class="variable">resultObject</span> <span class="operator">=</span> responseJson.getJSONObject(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">              <span class="type">String</span> <span class="variable">suggest</span> <span class="operator">=</span> resultObject.getString(<span class="string">&quot;suggest&quot;</span>);</span><br><span class="line">              <span class="type">int</span> <span class="variable">label</span> <span class="operator">=</span> resultObject.getInt(<span class="string">&quot;label&quot;</span>);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 输出综合结果信息</span></span><br><span class="line">              System.out.println(<span class="string">&quot;综合结果：&quot;</span>);</span><br><span class="line">              System.out.println(<span class="string">&quot;建议：&quot;</span> + suggest);</span><br><span class="line">              System.out.println(<span class="string">&quot;标签：&quot;</span> + label);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果文本内容建议审核，则根据实际需求执行人工审核流程</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="string">&quot;review&quot;</span>.equals(suggest)) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;该文本内容建议进行人工审核！&quot;</span>);</span><br><span class="line">                  <span class="comment">// 可以将内容设置为待审核状态，由人工审核决定是否发布</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;pass&quot;</span>.equals(suggest)) &#123;</span><br><span class="line">                  <span class="comment">// 如果文本内容正常或命中关键词但不违规，允许发布</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;文本内容合规，可以发布！&quot;</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;risky&quot;</span>.equals(suggest)) &#123;</span><br><span class="line">                  <span class="comment">// 如果文本内容被判定为违规，禁止发布，并输出违规信息</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;文本内容违规，请修改后重新提交！&quot;</span>);</span><br><span class="line">                  <span class="type">JSONArray</span> <span class="variable">detailArray</span> <span class="operator">=</span> responseJson.getJSONArray(<span class="string">&quot;detail&quot;</span>);</span><br><span class="line">                  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; detailArray.length(); i++) &#123;</span><br><span class="line">                      <span class="type">JSONObject</span> <span class="variable">detailObject</span> <span class="operator">=</span> detailArray.getJSONObject(i);</span><br><span class="line">                      <span class="type">String</span> <span class="variable">strategy</span> <span class="operator">=</span> detailObject.getString(<span class="string">&quot;strategy&quot;</span>);</span><br><span class="line">                      <span class="keyword">if</span> (<span class="string">&quot;keyword&quot;</span>.equals(strategy)) &#123;</span><br><span class="line">                          <span class="type">String</span> <span class="variable">keyword</span> <span class="operator">=</span> detailObject.getString(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">                          <span class="type">int</span> <span class="variable">prob</span> <span class="operator">=</span> detailObject.getInt(<span class="string">&quot;prob&quot;</span>);</span><br><span class="line">                          System.out.println(<span class="string">&quot;命中关键词：&quot;</span> + keyword + <span class="string">&quot;，概率：&quot;</span> + prob);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;未知建议类型：&quot;</span> + suggest);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 输出错误信息</span></span><br><span class="line">              System.out.println(<span class="string">&quot;接口调用失败，错误码：&quot;</span> + errcode + <span class="string">&quot;，错误信息：&quot;</span> + errmsg);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;接口调用失败！&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>微布开发思路总结</tag>
      </tags>
  </entry>
  <entry>
    <title>小八学习git从0到基本运用</title>
    <url>/2021/11/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p style="text-indent:20px;">有一说一，刚刚步入计算机大二的我，这个Github在我的认知里面一直只是一个大牛从中copy代码的网站，我对其的了解也仅仅在于抖音的“黑马程序员”里面的人说的这个网站很多大牛，才会使用。</p>

<p>&emsp;&emsp;就在前几天，我收到了我的学长ConeZhang（名字都不透露了，后面简写：驰哥）给我发的几条信息。</p>
<span id="more"></span>
<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/我的第一篇博客/QQ%E5%9B%BE%E7%89%8720211204214135.jpg?versionId=CAEQFxiBgICF.t.W7BciIDEyZDZhNTYwMDY4YzRmYTliOWE3NDgyOGZkYzBhMWI3">

<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/我的第一篇博客/QQ%E5%9B%BE%E7%89%8720211204214217.jpg?versionId=CAEQFxiBgMCYhuCW7BciIDY5OWFiMDE2NGRiYzRkM2Q4MGNiYjg3M2MzMTI4YTY0">

<p>&emsp;&emsp;看到这些消息，我直接开心的起飞，不知道怎么用语言来形容了，当时内心OS：woc！！这可是同时拿到百度，腾讯，快手sp甚至ssp的offer，最后去了字节的大佬啊，能带上我做项目，什么概念！！我上辈子肯定积了不少德，哈哈哈哈，说到驰哥，真就是机缘巧合，我还记得我第一次跟驰哥有了联系方式居然就在我预科刚入校的时候，因为学校教务系统的密码，忘记了，然后通过多方路径找到了驰哥的联系方式，然后帮我修改了密码，正巧我打算大一选择的就是计算机专业。</p>
<p>&emsp;&emsp;好了好了，言归正传，就在2021-11-26 18：33 驰哥给我发来了消息，要我赶紧这个周末学习完成，收到这个任务，我立刻马上关闭了LOL，开始了Git煎熬之旅。</p>
<h2 id="初入Git"><a href="#初入Git" class="headerlink" title="初入Git"></a>初入Git</h2><h3 id="Git的起源及比较："><a href="#Git的起源及比较：" class="headerlink" title="Git的起源及比较："></a>Git的起源及比较：</h3><p>&emsp;&emsp;我打开了驰哥发给我的学习网站，开始对Git的初步了解，发现原来Linux开发了Git及github网站，而Git与类似网站有不同之处就是，CVS以及SVN都是集中式的版本控制系统，但是Git是分布式的版本系统，但是集中式的系统最大毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要几十分钟，这还不得把人给憋死啊？</p>
<h3 id="Git的安装以及创建远程仓库："><a href="#Git的安装以及创建远程仓库：" class="headerlink" title="Git的安装以及创建远程仓库："></a>Git的安装以及创建远程仓库：</h3><p>&emsp;&emsp;个人觉得真没什么好说的，用大一老师lq老师说的，不会就给我多安装几次就会了，要是电脑出问题了，就重装系统，一举多得，还能自学安装系统，要是看到这个博客的小伙伴，不知道怎么去安装，可以上我b大，或者在<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰老师的网站</a>进行学习，实在还是不会，可以加我的QQ奥。</p>
<h2 id="Git的用法简介："><a href="#Git的用法简介：" class="headerlink" title="Git的用法简介："></a>Git的用法简介：</h2><h3 id="一、创建新的版本库"><a href="#一、创建新的版本库" class="headerlink" title="一、创建新的版本库"></a>一、创建新的版本库</h3><p>&emsp;&emsp;1.打开git bash找到一个非c盘的合适位置，来做创建一个空目录（我以d盘为例，创建一个文件夹learngit）<br>(输入语句里面含$)</p>
<blockquote>
<p>$mkdir /d/learngit</p>
</blockquote>
<blockquote>
<p>$cd /d/learngit</p>
</blockquote>
<blockquote>
<p>$pwd /d/learngit</p>
</blockquote>
<p>2.通过git init命令进行git仓库初始化</p>
<blockquote>
<p>$git init</p>
</blockquote>
<p>Initialized empty Git repository in D:/learngit/.git/</p>
<p>3.通过vi readme.txt创建一个新的文本框</p>
<blockquote>
<p>$vi readme.txt</p>
</blockquote>
<p>4.跳转到编辑界面，按下insert（ins）进行编辑，编辑完成之后按一下esc，再输入:wq进行退出(听我一个正在学Linux系统的室友告诉我，如果文档是只读的话，进行修改了的，就按:wq!进行强制退出)</p>
<p>5.用命令git commit告诉Git，把文件提交到仓库，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<blockquote>
<p>$git commit -m”wrote a readme file “</p>
</blockquote>
<p>[master (root-commit) df7ffd5] wrote a readme file</p>
<p> 1 file changed, 1 insertion(+)</p>
<p> create mode 100644 readme.txt</p>
<h3 id="二、其他基本命令的使用"><a href="#二、其他基本命令的使用" class="headerlink" title="二、其他基本命令的使用"></a>二、其他基本命令的使用</h3><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>&emsp;&emsp;1、git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：</p>
<blockquote>
<p>$ git log –pretty=oneline</p>
</blockquote>
<p>&emsp;&emsp;2、现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：</p>
<blockquote>
<p>$ git reset –hard HEAD^</p>
</blockquote>
<p>&emsp;&emsp;在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>
<p>&emsp;&emsp;3、最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>&emsp;&emsp;办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb…，于是就可以指定回到未来的某个版本：</p>
<blockquote>
<p>$ git reset –hard 1094a</p>
</blockquote>
<p>HEAD is now at 83b0afe append GPL</p>
<p>&emsp;&emsp;现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>&emsp;&emsp;在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</p>
<p>&emsp;&emsp;4、$ git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>
<h4 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h4><p>&emsp;&emsp;1、每次修改，如果不用git add到暂存区，那就不会加入到commit中。</p>
<p>&emsp;&emsp;2、git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：</p>
<blockquote>
<p>xxxxxxxxxx   private static void handleResult(String result) {        if (result != null) {            JSONObject responseJson = new JSONObject(result);            int errcode = responseJson.getInt(“errcode”);            String errmsg = responseJson.getString(“errmsg”);​            if (errcode == 0) {                // 获取综合结果信息                JSONObject resultObject = responseJson.getJSONObject(“result”);                String suggest = resultObject.getString(“suggest”);                int label = resultObject.getInt(“label”);​                // 输出综合结果信息                System.out.println(“综合结果：”);                System.out.println(“建议：” + suggest);                System.out.println(“标签：” + label);​                // 如果文本内容建议审核，则根据实际需求执行人工审核流程                if (“review”.equals(suggest)) {                    System.out.println(“该文本内容建议进行人工审核！”);                    // 可以将内容设置为待审核状态，由人工审核决定是否发布                } else if (“pass”.equals(suggest)) {                    // 如果文本内容正常或命中关键词但不违规，允许发布                    System.out.println(“文本内容合规，可以发布！”);                } else if (“risky”.equals(suggest)) {                    // 如果文本内容被判定为违规，禁止发布，并输出违规信息                    System.out.println(“文本内容违规，请修改后重新提交！”);                    JSONArray detailArray = responseJson.getJSONArray(“detail”);                    for (int i = 0; i &lt; detailArray.length(); i++) {                        JSONObject detailObject = detailArray.getJSONObject(i);                        String strategy = detailObject.getString(“strategy”);                        if (“keyword”.equals(strategy)) {                            String keyword = detailObject.getString(“keyword”);                            int prob = detailObject.getInt(“prob”);                            System.out.println(“命中关键词：” + keyword + “，概率：” + prob);                        }                    }                } else {                    System.out.println(“未知建议类型：” + suggest);                }            } else {                // 输出错误信息                System.out.println(“接口调用失败，错误码：” + errcode + “，错误信息：” + errmsg);            }        } else {            System.out.println(“接口调用失败！”);        }Java</p>
</blockquote>
<p>diff –git a/readme.txt b/readme.txt<br>index 76d770f..a9c5755 100644<br>— a/readme.txt<br>+++ b/readme.txt<br>@@ -1,4 +1,4 @@<br> Git is a distributed version control system.<br> Git is free software distributed under the GPL.<br> Git has a mutable index called stage.<br>-Git tracks changes.<br>+Git tracks changes of files.</p>
<h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p>&emsp;&emsp;1、既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：</p>
<blockquote>
<p>$ git status</p>
</blockquote>
<p>On branch master</p>
<p>Changes not staged for commit:</p>
<p>  (use “git add <file>…” to update what will be committed)</file></p>
<p>  (use “git checkout – <file>…” to discard changes in working directory)</file></p>
<pre><code>modified:   readme.txt
</code></pre>
<p>no changes added to commit (use “git add” and/or “git commit -a”)</p>
<p>你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改：</p>
<blockquote>
<p>$ git checkout – readme.txt</p>
</blockquote>
<p>2、现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：</p>
<p>庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交：</p>
<p>Git同样告诉我们，用命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</file></p>
<blockquote>
<p>$ git reset HEAD readme.txt</p>
</blockquote>
<p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p>
<p>再用git status查看一下，现在暂存区是干净的，工作区有修改：</p>
<p>还记得如何丢弃工作区的修改吗？</p>
<blockquote>
<p>$ git checkout – readme.txt</p>
</blockquote>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>1、一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p>
<blockquote>
<p>$ rm test.txt</p>
</blockquote>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p>
<p>rm之后你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</p>
<blockquote>
<p>$ git rm test.txt</p>
</blockquote>
<p>rm ‘test.txt’</p>
<p>2、切记，在git rm 之后还需要提交commit才能从版本库中被删除</p>
<blockquote>
<p>$ git commit -m “remove test.txt”</p>
</blockquote>
<p>[master d46f35e] remove test.txt</p>
<p> 1 file changed, 1 deletion(-)</p>
<p> delete mode 100644 test.txt<br>现在，文件就从版本库中被删除了。</p>
<p>3、另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：（经实验，如果版本库里面也被rm了就无法恢复了）</p>
<blockquote>
<p>$ git checkout – test.txt</p>
</blockquote>
<h4 id="远程库的使用"><a href="#远程库的使用" class="headerlink" title="远程库的使用"></a>远程库的使用</h4><p>一、添加远程库</p>
<p>具体怎么添加，请小伙伴们，自行百度学习，具体实现就不说了，小编只在这里讲一下添加时候的一些命令：</p>
<p>1、在本次仓里面运行命令：</p>
<blockquote>
<p>$ git remote add origin <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#109;">&#103;&#x69;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#98;&#x2e;&#99;&#111;&#109;</a>:pengzihao166/learngit.git</p>
</blockquote>
<p>注意：把上面的pengzihao166替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>2、下一步，就可以把本地库的所有内容推送到远程库上：</p>
<blockquote>
<p>$ git push -u origin master</p>
</blockquote>
<p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p>
<p>注意：由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>3、从现在起，只要本地作了提交，就可以通过命令：</p>
<blockquote>
<p>$ git push origin master</p>
</blockquote>
<p>二、删除远程库</p>
<p>1、如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm <name>命令。使用前，建议先用git remote -v查看远程库信息：</name></p>
<blockquote>
<p>$ git remote -v<br>origin  <a href="mailto:&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#111;&#x6d;</a>:pengzihao166/learn-git.git (fetch)</p>
</blockquote>
<p>origin  <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#x75;&#98;&#46;&#x63;&#x6f;&#x6d;</a>:pengzihao166/learn-git.git (push)</p>
<p>然后，根据名字删除，比如删除origin：</p>
<blockquote>
<p>$ git remote rm origin</p>
</blockquote>
<p>三、从远程库克隆</p>
<p>1、准备好远程库</p>
<p>2、现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：</p>
<blockquote>
<p>$ git clone <a href="mailto:&#103;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;">&#103;&#105;&#116;&#64;&#103;&#x69;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#109;</a>:pengzihao166/gitskills.git</p>
</blockquote>
<p>注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。</p>
<p>Git支持多种协议，包括https，但ssh协议速度最快。</p>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>一、创建并合并分支</p>
<p>创建命令：</p>
<blockquote>
<p>git switch -c ***</p>
</blockquote>
<p>合并命令：</p>
<blockquote>
<p>git merge ***</p>
</blockquote>
<p>注意：***是你想取的名字</p>
<p>二、分支管理策略</p>
<p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<p>例：</p>
<blockquote>
<p>$ git merge –no-ff -m “merge with no-ff” dev</p>
</blockquote>
<p>合并后，我们用git log看看分支历史：</p>
<blockquote>
<p>$ git log –graph –pretty=oneline –abbrev-commit</p>
</blockquote>
<p>二、bug和feature分支：</p>
<p>这两个分支总体来说用法都一样，就是在不同工作环境下使用的时间不一样，就拿bug来举例好了：</p>
<p>1、当你接到一个修复一个代号101的bug的任务时,当前正在dev上进行的工作还没有提交。</p>
<p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<blockquote>
<p>$ git stash<br>Saved working directory and index state WIP on dev: f52c633 add merge</p>
</blockquote>
<p>2、返回到主分支master之后，再建立一个新的分支issue-101，在此分支上面进行readme.txt文档的修改已知bug（经自己的实验发现一个问题，原来如果vi文件完成之后你使用前面提到的:wq或者wq!或者ZZ命令会发现，你的文件直接被git add了，只需要直接commit）</p>
<blockquote>
<p>$ git add readme.txt </p>
</blockquote>
<blockquote>
<p>$ git commit -m “fix bug 101”</p>
</blockquote>
<p>[issue-101 a1d6694] fix bug 101</p>
<p>1 file changed, 1 insertion(+), 1 deletion(-)</p>
<p>3、再修改bug完成之后，返回到master分支，然后，再进行git merge –no-ff -m “merged bug fix 101” issue-101合并刚刚的issue-101分支修改的bug内容</p>
<p>4、然后就是跳转到先前的Dev分支上面，继续以前的工作，通过git stash list 查找到刚刚git stash存好的工作区的文件，恢复方法如下：<br>     输入git stash list</p>
<pre><code>  $ git stash list

      stash@&#123;0&#125;: WIP on dev:ecd2437add merge

   ①一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；

    另一种方式是用git stash pop，恢复的同时把stash内容也删了：
    
   ②$ git stash apply stash@&#123;0&#125;

      stash@&#123;0&#125;就是list显示的前缀名
</code></pre>
<p>5、同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。</p>
<p>为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支：</p>
<blockquote>
<p>$ git branch</p>
</blockquote>
<ul>
<li><p>dev（此时在dev分支上面）</p>
<p>master</p>
</li>
</ul>
<blockquote>
<p>$ git cherry-pick a1d6694</p>
</blockquote>
<p>[master 1d4b803] fix bug 101</p>
<p> 1 file changed, 1 insertion(+), 1 deletion(-)</p>
<h4 id="标签管理："><a href="#标签管理：" class="headerlink" title="标签管理："></a>标签管理：</h4><p>一、创建标签：</p>
<p>1、直接法：</p>
<blockquote>
<p>$ git branch</p>
</blockquote>
<ul>
<li>dev<br>master<blockquote>
<p>$ git checkout master</p>
</blockquote>
</li>
</ul>
<p>Switched to branch ‘master’</p>
<p>然后，敲命令git tag <name>就可以打一个新标签：</name></p>
<blockquote>
<p>$ git tag v1.0</p>
</blockquote>
<p>可以用命令git tag查看所有标签：</p>
<blockquote>
<p>$ git tag</p>
</blockquote>
<p>v1.0</p>
<p>2、默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：</p>
<blockquote>
<p>$ git log –pretty=oneline –abbrev-commit</p>
</blockquote>
<p>12a631b (HEAD -&gt; master, tag: v1.0, origin/master) </p>
<p>merged bug fix 101</p>
<p>4c805e2 fix bug 101</p>
<p>e1e9c68 merge with no-ff</p>
<p>f52c633 add merge</p>
<p>比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：</p>
<blockquote>
<p>$ git tag v0.9 f52c633</p>
</blockquote>
<p>再用命令git tag查看标签：</p>
<blockquote>
<p>$ git tag</p>
</blockquote>
<p>v0.9</p>
<p>v1.0</p>
<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show <tagname>查看标签信息：</tagname></p>
<blockquote>
<p>$ git show v0.9</p>
</blockquote>
<p>可以看到，v0.9确实打在add merge这次提交上。</p>
<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p>
<blockquote>
<p>$ git tag -a v0.1 -m “version 0.1 released” 1094adb</p>
</blockquote>
<p>用命令git show <tagname>可以看到说明文字：</tagname></p>
<blockquote>
<p>$ git show v0.1\</p>
</blockquote>
<p>二、操作标签</p>
<p>命令git push origin <tagname>可以推送一个本地标签；</tagname></p>
<p>命令git push origin –tags可以推送全部未推送过的本地标签；</p>
<p>命令git tag -d <tagname>可以删除一个本地标签；</tagname></p>
<p>命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</tagname></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&ensp; &ensp;今天的Git命令的使用，就到此结束了，要是有啥疑惑的小伙伴可以去自行百度或者加上我的联系方式，联系我奥。</p>
<p>&ensp; &ensp;部分内容转自<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰老师的网站</a>，如有侵权，请立刻联系小编进行修改完善。</p>
<pre><code>                                                              ---来自一个小白的真实学习笔记
</code></pre>
]]></content>
      <tags>
        <tag>Git+Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>最近的成长</title>
    <url>/2022/07/10/%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%90%E9%95%BF/</url>
    <content><![CDATA[<p>&emsp;&emsp;你好，我是小八，好久不见，不知不觉停更我的<a href="https://xiaobazeo.com/">blog</a>已经将近半年了，不知道的，可能是觉得大二下的我开始颓废了，我可以在这里说NO，你猜错了，我只是最近在闲暇之余花更多的时间在我前面<a href="https://xiaobazeo.com/2022/01/01/2021-backing/">一篇博客</a>提到的项目中——“微布校园”，我们团队开发了一款基于微信生态环境的微信小程序和APP——微布校园，目前也有很多我校大学生在使用我们的产品，而我负责的主要是小程序端开发和Java后端开发，算得上是个前后端啥都干的小菜鸡吧。</p>
<p>&emsp;&emsp;不知不觉，微布校园的诞生已经半年之久了，用户量也达到了我们的预期估计。在这段参与开发的过程中，通过向几个在大厂工作的学长请教，交流，我发现了很多开发过程中需要注意的小问题，而这些也丰富积累了我的开发经验。比如 刚开始学习使用mina框架开发小程序的我过于小白，其实有些icon只需要写一个class改变其样式即可，而我当时却给每个icon单独写了一个class样式，现在想起来都觉得自己真的好蠢啊，hhhhhhh~</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220710223856616.png" alt="小白受教ing"></p>
<p>&emsp;&emsp;还有这样的：当时还记得是因为我们开发的时候，提到了tcp协议，而我又看到过一篇博客说http3.0的TCP被弃用了，就开始了这个话题。。。当时还从计网知识转到了计组的相关探讨，hhhhhhh，而且我才知道一个安卓手机小知识，这里也分享给大家：安卓大多数手机用WiFi给电脑传数据，比用数据线快，因为很多手机接口用的USB2.0协议，虽然协议写的是60M，但一般2.0不超过30M</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220710223300695.png" alt="请教计网相关问题"></p>
<p>&emsp;&emsp;好在我们的不断努力下，微布校园APP和小程序都成功诞生啦~</p>
]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基础篇</title>
    <url>/2023/05/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="TCP-IP网络模型有哪几层？"><a href="#TCP-IP网络模型有哪几层？" class="headerlink" title="TCP/IP网络模型有哪几层？"></a>TCP/IP网络模型有哪几层？</h2><h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><p>&emsp;&emsp;用户直接接触到的就是<strong>应用层</strong>，应用层专注于用户提供应用功能，例如：HTTP、FTP、DNS、Telnet、SMTP等。</p>
<p>&emsp;&emsp;应用层工作在操作系统中得<strong>用户态</strong>，<strong>传输层及以下</strong>则工作在<strong>内核态</strong>。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>&emsp;&emsp;应用层的数据包会传给传输层，传输层是为应用层提供网络支持。传输层的两个协议：<strong>TCP</strong>和<strong>UDP</strong>。</p>
<p>&emsp;&emsp;TCP（传输控制协议），TCP相较于UDP的特性，比如：<strong>流量控制，超时重传，拥塞控制</strong>等，为了保证数据包能可靠的传输给对方。</p>
<p>&emsp;&emsp;UDP只负责发送数据包，<strong>不保证</strong>数据包是否能抵达对方，但是<strong>实时性</strong>相对较好，<strong>传输效率</strong>也较高。如果要实现UDP的可靠传输，可以把TCP的特性在应用层实现。</p>
<p>&emsp;&emsp;应用传输数据过大，传输层的数据包大小超过MSS(TCP最大报文段长度)，需要将数据包分块，如果中途有一个分块丢失或损坏，只需重新发送此分块即可，而不需要发送整个数据包。在TCP协议中，<strong>每个分块称为一个TCP段</strong>（TCP Segment）。</p>
<p>&emsp;&emsp;传输层负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，此时需要用一个编号将应用区分开，这个编号就是端口。例如：Web服务器通常使用80端口，22端口通常是远程登录服务器的端口。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>&emsp;&emsp;实现传输功能的是<strong>网络层</strong>，传输层只是作为数据传输的媒介，帮助应用到应用的通信。</p>
<p>&emsp;&emsp;常见协议是IP协议（Internet Protocol），IP协议会将传输层的报文作为数据部分，再加上IP包头部组装成IP报文，如果IP报文大小超过MTU（一般默认1500Bytes）会<strong>再次进行分片</strong>，得到一个即将发送的到网络的IP报文。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/12.jpg" alt="选自小林coding"></p>
<h4 id="IP协议寻址功能："><a href="#IP协议寻址功能：" class="headerlink" title="IP协议寻址功能："></a>IP协议寻址功能：</h4><p>&emsp;&emsp;由于网络层需要有区分设备的编号，一般使用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分为四段（比如：192.168.100.1），每段8位。由于IPv4地址有设备上限，无法做到一个设备一个IP地址，所以会将IP地址分成两种意义：</p>
<ul>
<li>一个是<strong>网络号</strong>，负责标识该IP地址是属于哪个<strong>子网</strong>的</li>
<li>一个是<strong>主机号</strong>，负责标识<strong>同一子网</strong>下的<strong>不同主机</strong></li>
</ul>
<p>此时需要<strong>子网掩码</strong>才能计算出IP地址的网络号和主机号，比如：10.100.122.0/24，后面的/24表示就是255.255.255.0子网掩码，255.255.255.0二进制就是11111111-11111111-11111111-00000000，24个1，为了简化子网掩码的表示，就会用/24代替255.255.255.0</p>
<p><strong>网络号</strong>将 10.100.122.2 和 255.255.255.0 <strong>按位与运算</strong>。</p>
<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/16.jpg" alt="取自小林coding"></p>
<p><strong>主机号：</strong>将 255.255.255.0 <strong>取反</strong>后与IP地址进行进行<strong>按位与运算</strong>。</p>
<p>在寻址过程中，先匹配相同的网络号（表示要找到同一个子网），才会去找对应的主机号。</p>
<h4 id="IP协议路由功能"><a href="#IP协议路由功能" class="headerlink" title="IP协议路由功能"></a>IP协议路由功能</h4><p>当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p>
<p>IP协议的寻址是告诉我们去往下一个目的地朝哪个方向走，路由是根据下一个目的地选择路径。</p>
<h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>网络接口层会在IP头部的前面加上MAC头部，并封装成数据帧发送到网络上。网络接口层主要是为网络层提供链路级别传输的服务，负责以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来表示网络上的设备。</p>
<p>MAC头部是以以太网的头部，包含了接收方和发送方的MAC地址等信息，可以通过ARP协议获取对方的MAC地址。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络接口层的传输单位是帧，IP的传输单位是包，TCP层传输单位是段，HTTP传输单位是消息或报文，每一层的封装格式如下：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="取自小林coding"></p>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈wx和wss</title>
    <url>/2023/02/02/%E8%B0%88%E8%B0%88wx%E5%92%8Cwss/</url>
    <content><![CDATA[<h2 id="了解WS和WSS"><a href="#了解WS和WSS" class="headerlink" title="了解WS和WSS"></a>了解WS和WSS</h2><p>&emsp;WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。</p>
<p>&emsp;WebSocket建立在TCP之上，同HTTP一样通过TCP来传输数据，但是它和HTTP最大不同是：WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/Client Agent都能主动的向对方发送或接收数据，就像Socket一样；WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。</p>
<p>&emsp;WSS（Web Socket Secure）是WebSocket的加密版本。WS一般默认是80端口，而WSS默认是443端口，大多数网站用的就是80和433端口。（在高防防护过程中，80和433端口的网站是需要备案才可以接入国内的。）</p>
<p>&emsp;WS体现形式：<strong>TCP+WS AS WS 。</strong></p>
<p>&emsp;WSS体现形式：<strong>TCP+TLS+WS AS WS。</strong></p>
<p>&emsp;服务器网址就是 URL。</p>
<h2 id="WS-WSS出现的原因"><a href="#WS-WSS出现的原因" class="headerlink" title="WS/WSS出现的原因"></a>WS/WSS出现的原因</h2><p>&emsp;目前很多应用要求服务端有能力进行实时推送能力（例如直播间聊天室），以往很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。</p>
<p>​    这种传统的模式带来很明显的缺点，即浏览器需要不断地向服务器发出请求，但是HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽资源。</p>
<p>​    此时，WebSocket协议的出现，能更好地节省服务器资源和带宽，并且能够更实时地进行通讯。WebSocket实现了浏览器与服务器全双工（full-duplex）通信，允许服务器主动发送信息给客户端。</p>
<h2 id="WS特点"><a href="#WS特点" class="headerlink" title="WS特点"></a>WS特点</h2><ul>
<li>建立在 TCP 协议之上，服务端实现容易；</li>
<li>与 HTTP 协议有良好的兼容性，握手时不容易被屏蔽，可以通过各种 HTTP 代理服务器；</li>
<li>数据轻量，实时通讯；</li>
<li>可以发送文本和二进制数据；</li>
<li>不限制同源，客户端可以与任意服务器端进行通讯。</li>
</ul>
<h2 id="和http-https的关系"><a href="#和http-https的关系" class="headerlink" title="和http/https的关系"></a>和http/https的关系</h2><p>按照标准来是有如下对应关系的：</p>
<ul>
<li>http -&gt; new WebSocket(‘ws://xxx’)</li>
<li>https -&gt; new WebSocket(‘wss://xxx’)</li>
</ul>
<p>在https下应该使用wss协议做安全链接，且wss下不支持ip地址的写法，写成域名形式。</p>
]]></content>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-七牛云测试开发实习一二面</title>
    <url>/2023/08/02/%E9%9D%A2%E7%BB%8F-%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%BA%8C%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="微布校园的分工如何？"><a href="#微布校园的分工如何？" class="headerlink" title="微布校园的分工如何？"></a>微布校园的分工如何？</h3><h3 id="在开发过程中学到了什么？遇到了什么难的问题？"><a href="#在开发过程中学到了什么？遇到了什么难的问题？" class="headerlink" title="在开发过程中学到了什么？遇到了什么难的问题？"></a>在开发过程中学到了什么？遇到了什么难的问题？</h3><h3 id="如何解决缓存雪崩、缓存与数据库一致性问题？"><a href="#如何解决缓存雪崩、缓存与数据库一致性问题？" class="headerlink" title="如何解决缓存雪崩、缓存与数据库一致性问题？"></a>如何解决缓存雪崩、缓存与数据库一致性问题？</h3><h3 id="查询响应速度从超时响应加快到900ms-1s是如何实现的？"><a href="#查询响应速度从超时响应加快到900ms-1s是如何实现的？" class="headerlink" title="查询响应速度从超时响应加快到900ms~1s是如何实现的？"></a>查询响应速度从超时响应加快到900ms~1s是如何实现的？</h3><h3 id="讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）"><a href="#讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）" class="headerlink" title="讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）"></a>讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）</h3><h3 id="使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。"><a href="#使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。" class="headerlink" title="使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。"></a>使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。</h3><h3 id="Redis在哪一部分用的比较多？"><a href="#Redis在哪一部分用的比较多？" class="headerlink" title="Redis在哪一部分用的比较多？"></a>Redis在哪一部分用的比较多？</h3><h3 id="讲一下http的三次握手、四次挥手？"><a href="#讲一下http的三次握手、四次挥手？" class="headerlink" title="讲一下http的三次握手、四次挥手？"></a>讲一下http的三次握手、四次挥手？</h3><h3 id="为什么要进行四次挥手？"><a href="#为什么要进行四次挥手？" class="headerlink" title="为什么要进行四次挥手？"></a>为什么要进行四次挥手？</h3><h3 id="介绍一下udp和tcp之间的区别"><a href="#介绍一下udp和tcp之间的区别" class="headerlink" title="介绍一下udp和tcp之间的区别"></a>介绍一下udp和tcp之间的区别</h3><h3 id="什么时候用UDP？什么时候用TCP？"><a href="#什么时候用UDP？什么时候用TCP？" class="headerlink" title="什么时候用UDP？什么时候用TCP？"></a>什么时候用UDP？什么时候用TCP？</h3><h3 id="介绍一下对HTTP的理解"><a href="#介绍一下对HTTP的理解" class="headerlink" title="介绍一下对HTTP的理解"></a>介绍一下对HTTP的理解</h3><h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><h3 id="介绍一下token"><a href="#介绍一下token" class="headerlink" title="介绍一下token"></a>介绍一下token</h3><h3 id="讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？"><a href="#讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？" class="headerlink" title="讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？"></a>讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？</h3><h3 id="介绍一下Redis的数据类型和持久化"><a href="#介绍一下Redis的数据类型和持久化" class="headerlink" title="介绍一下Redis的数据类型和持久化"></a>介绍一下Redis的数据类型和持久化</h3><h3 id="如何通过Redis实现分布式锁？"><a href="#如何通过Redis实现分布式锁？" class="headerlink" title="如何通过Redis实现分布式锁？"></a>如何通过Redis实现分布式锁？</h3><h3 id="Redis的淘汰策略有哪些？"><a href="#Redis的淘汰策略有哪些？" class="headerlink" title="Redis的淘汰策略有哪些？"></a>Redis的淘汰策略有哪些？</h3><h3 id="介绍一下对多线程的理解"><a href="#介绍一下对多线程的理解" class="headerlink" title="介绍一下对多线程的理解"></a>介绍一下对多线程的理解</h3><h3 id="什么是线程池、为什么要使用线程池？"><a href="#什么是线程池、为什么要使用线程池？" class="headerlink" title="什么是线程池、为什么要使用线程池？"></a>什么是线程池、为什么要使用线程池？</h3><h3 id="Java的异常有哪些？如何捕获异常？"><a href="#Java的异常有哪些？如何捕获异常？" class="headerlink" title="Java的异常有哪些？如何捕获异常？"></a>Java的异常有哪些？如何捕获异常？</h3><h3 id="对文件的上传、下载分别有哪些测试功能点？"><a href="#对文件的上传、下载分别有哪些测试功能点？" class="headerlink" title="对文件的上传、下载分别有哪些测试功能点？"></a>对文件的上传、下载分别有哪些测试功能点？</h3><h3 id="算法题：把两个无序的数组合并成一个有序的数组"><a href="#算法题：把两个无序的数组合并成一个有序的数组" class="headerlink" title="算法题：把两个无序的数组合并成一个有序的数组"></a>算法题：把两个无序的数组合并成一个有序的数组</h3><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><h3 id="为什么要选择面试测试开发这个岗位？"><a href="#为什么要选择面试测试开发这个岗位？" class="headerlink" title="为什么要选择面试测试开发这个岗位？"></a>为什么要选择面试测试开发这个岗位？</h3><h3 id="你觉得测开需要学习些什么方面的东西？"><a href="#你觉得测开需要学习些什么方面的东西？" class="headerlink" title="你觉得测开需要学习些什么方面的东西？"></a>你觉得测开需要学习些什么方面的东西？</h3><h3 id="netty和直接裸写socket有什么区别？"><a href="#netty和直接裸写socket有什么区别？" class="headerlink" title="netty和直接裸写socket有什么区别？"></a>netty和直接裸写socket有什么区别？</h3><h3 id="什么是NIO？"><a href="#什么是NIO？" class="headerlink" title="什么是NIO？"></a>什么是NIO？</h3><h3 id="为什么IO多路复用比多线程更高效？"><a href="#为什么IO多路复用比多线程更高效？" class="headerlink" title="为什么IO多路复用比多线程更高效？"></a>为什么IO多路复用比多线程更高效？</h3><h3 id="Redis是单线程还是多线程的？为什么是单线程还能这么高效？"><a href="#Redis是单线程还是多线程的？为什么是单线程还能这么高效？" class="headerlink" title="Redis是单线程还是多线程的？为什么是单线程还能这么高效？"></a>Redis是单线程还是多线程的？为什么是单线程还能这么高效？</h3><h3 id="在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？"><a href="#在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？" class="headerlink" title="在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？"></a>在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？</h3><h3 id="使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）"><a href="#使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）" class="headerlink" title="使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）"></a>使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）</h3><h3 id="netty的广播怎么实现的？"><a href="#netty的广播怎么实现的？" class="headerlink" title="netty的广播怎么实现的？"></a>netty的广播怎么实现的？</h3><h3 id="如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？"><a href="#如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？" class="headerlink" title="如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？"></a>如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？</h3><h3 id="如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？"><a href="#如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？" class="headerlink" title="如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？"></a>如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？</h3><h3 id="介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？"><a href="#介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？" class="headerlink" title="介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？"></a>介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？</h3><h3 id="说几个Maven的常用命令"><a href="#说几个Maven的常用命令" class="headerlink" title="说几个Maven的常用命令"></a>说几个Maven的常用命令</h3><h3 id="常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）"><a href="#常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）" class="headerlink" title="常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）"></a>常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）</h3><h3 id="怎么实现多线程之间的同步操作？-主线程开启10个任务，-等这10个任务并发结束之后，再执行其他的任务应该怎么实现？"><a href="#怎么实现多线程之间的同步操作？-主线程开启10个任务，-等这10个任务并发结束之后，再执行其他的任务应该怎么实现？" class="headerlink" title="怎么实现多线程之间的同步操作？ 主线程开启10个任务， 等这10个任务并发结束之后，再执行其他的任务应该怎么实现？"></a>怎么实现多线程之间的同步操作？ 主线程开启10个任务， 等这10个任务并发结束之后，再执行其他的任务应该怎么实现？</h3><h3 id="Java的新特性（介绍的Java8的新特性）"><a href="#Java的新特性（介绍的Java8的新特性）" class="headerlink" title="Java的新特性（介绍的Java8的新特性）"></a>Java的新特性（介绍的Java8的新特性）</h3><h3 id="编码：实现a，b两个线程顺序交替执行"><a href="#编码：实现a，b两个线程顺序交替执行" class="headerlink" title="编码：实现a，b两个线程顺序交替执行"></a>编码：实现a，b两个线程顺序交替执行</h3>]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>法大大Java实习 2023.4.6</title>
    <url>/2023/04/06/%E9%9D%A2%E7%BB%8F-%E6%B3%95%E5%A4%A7%E5%A4%A7Java%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E6%B3%95%E5%A4%A7%E5%A4%A7(2023.4.6).png" alt="法大大(2023.4.6)"></p>
<h2 id="总结：（答得不是很完善的地方总结一下）"><a href="#总结：（答得不是很完善的地方总结一下）" class="headerlink" title="总结：（答得不是很完善的地方总结一下）"></a>总结：（答得不是很完善的地方总结一下）</h2><h3 id="接口和抽象类的共同点和区别："><a href="#接口和抽象类的共同点和区别：" class="headerlink" title="接口和抽象类的共同点和区别："></a>接口和抽象类的共同点和区别：</h3><p><strong>共同点：</strong> </p>
<ul>
<li>不可以被实例化</li>
<li>可以包含抽象方法</li>
<li>可以有默认的实现方法</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>接口对类的行为进行约束，实现某接口已经拥有了的具体行为，抽象类代码复用，强调的是从属关系</li>
<li>接口的成员变量只能用public static final修饰且不可修改并初始化，抽象类默认是default类型，可以在子类被重新定义且重新赋值</li>
<li>一个类只能继承一个抽象类（单继承），可实现多个接口。</li>
</ul>
<h3 id="和-equals-方法"><a href="#和-equals-方法" class="headerlink" title="== 和 equals()方法"></a>== 和 equals()方法</h3><p><strong>== 两种情况：</strong></p>
<ul>
<li>对于基本数据类型，直接比较值的大小</li>
<li>对于引用类型，比较对象的内存地址</li>
</ul>
<p><strong>equals（）方法：</strong></p>
<p>比较对象是否相等，即对象的内存地址是否相等，一般也分为两种情况</p>
<ul>
<li>重写了，一般比较两个对象的成员属性是否相等</li>
<li>未重写，比较的该类型的对象是否相等</li>
</ul>
<h3 id="try-catch-finally方法"><a href="#try-catch-finally方法" class="headerlink" title="try-catch-finally方法"></a>try-catch-finally方法</h3><ul>
<li>如果在catch中return了，那么finally里面的逻辑会在return之前被执行。</li>
<li>如果catch和finally都有return，那么catch的return会被忽略，</li>
<li>因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</li>
<li>finally一般用于资源回收、比如线程、数据库资源回收的情况</li>
</ul>
<h3 id="HashMap和HashSet区别"><a href="#HashMap和HashSet区别" class="headerlink" title="HashMap和HashSet区别"></a>HashMap和HashSet区别</h3><ul>
<li>前者实现了Map接口，后者实现了Set接口</li>
<li>HashSet底层是HashMap实现存储的</li>
</ul>
<h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><ul>
<li>前者继承了AbstractMap类，后者继承了Dictionary类</li>
<li>HashMap线程不安全，HashTable线程安全</li>
<li>contains不一样，HashMap没有contains方法只有containsValue和containsKey方法，但是HashTable这三个方法都有</li>
<li>key-value是否能为null，HashMap 都可以为null，HashTable都不可以null，否则就是空指针异常</li>
<li>获取hashCode方法不一样</li>
</ul>
<p>&emsp;&emsp;HashMap先调用hashCode获取到了hash值之后，再与右移16位的hash值相异或获取hash值。</p>
<p>&emsp;&emsp;HashTable直接通过hashCode方法获取</p>
<ul>
<li>解决hash冲突方法不一样</li>
</ul>
<p>&emsp;&emsp;HashMap通过数组+链表/红黑树，如果链表长度大于8，变成红黑树，若链表长度后面小于6，转回链表格式</p>
<p>&emsp;&emsp;HashTable只有链表存储</p>
<h3 id="项目介绍："><a href="#项目介绍：" class="headerlink" title="项目介绍："></a>项目介绍：</h3><p>因为主要是自己写的、在redis那一块也比较熟悉，也自己解决了缓存雪崩的问题，后面也解决了缓存和数据库一致性问题，但是面试的时候忘记提了，可能提了会更加加分~</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>面经-万物心选php开发实习</title>
    <url>/2023/07/25/%E9%9D%A2%E7%BB%8F-%E4%B8%87%E7%89%A9%E5%BF%83%E9%80%89php%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="实习项目的监听字段是基于什么实现的？"><a href="#实习项目的监听字段是基于什么实现的？" class="headerlink" title="实习项目的监听字段是基于什么实现的？"></a>实习项目的监听字段是基于什么实现的？</h2><p>前端进行某个字段变更之后，后端提供接口，将修改后的数据打入消息队列，服务端作为消费者进行监听判断某个字段是否等于某个值然后进行对应的业务逻辑操作。</p>
<h2 id="通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）"><a href="#通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）" class="headerlink" title="通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）"></a>通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）</h2><p>通过业务id来保证，业务id作为锁的key，当消费信息的时候，把工单id作为key去申请锁，如果成功拿到了锁，说明此时不存在竞争关系，如果当前进程被阻塞了，说明有进程对该数据进行了消费。</p>
<p>不过后面发现如果有两个并发的线程的时候，被阻塞的业务后面拿到了还是可能会造成重复消费，于是又加了一层缓存，缓存已经消费了的业务id，用来表示是否被消费过，也就是保证业务的幂等性。</p>
<h2 id="当时为什么考虑到设置一个重试机制降低消费的失败率？"><a href="#当时为什么考虑到设置一个重试机制降低消费的失败率？" class="headerlink" title="当时为什么考虑到设置一个重试机制降低消费的失败率？"></a>当时为什么考虑到设置一个重试机制降低消费的失败率？</h2><p>当初实现合同是临时合同的时候，要删除销售合同的主从表，因为当时是两个表，涉及到了一个同步操作，即先删除主表之后再删除从表的操作，要保证事务的一致性和原子性，可能两个删除操作会有一个或者两个操作均失败的情况，就设计了这个重试机制，如果其中一个操作失败就进行事务回滚，然后将两个同步操作打入重试的队列中进行一次重试。</p>
<h2 id="有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）"><a href="#有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）" class="headerlink" title="有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）"></a>有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）</h2><p><strong>避免消费失败的措施：</strong></p>
<ol>
<li>失败重试机制</li>
<li>死信队列</li>
<li>消息超时机制：避免因为一个消息阻塞导致后续的所有消息超时</li>
<li>负载均衡：如果是集群分布式服务，可以通过负载均衡算法分配给多个消费者。</li>
<li>消息确认机制：当消费者消费成功之后，发送确认信号给消息队列，表示消息处理成功，如果消费者在一定时间内没有返回确认信号，消息队列就重新分发消息给其他的消费者进行消费。</li>
</ol>
<p><strong>避免重复消费的措施：</strong></p>
<ol>
<li>实现幂等性：即相同的多个操作所产生的影响与仅执行一次的操作所产生的影响相同。确保相同的消息被多次发送之后，只会被处理一次。</li>
<li>消息确认机制：消息队列消费者消费之后会给生产者发送一个确认信号告诉已经消费信息成功，如果在一定时间内没有发送确认消息，消息队列就会认为此消息未被成功消费，会将该消息重新发送给消费者。</li>
<li>消费者限流：在高并发的场景中，为了消费者过度消费，就会在一定时间内只允许消费者消费一定数量的消息，以避免被过度消费而导致的重复消费。</li>
</ol>
<h2 id="如何解决数据库offset超过10000时失效的问题？"><a href="#如何解决数据库offset超过10000时失效的问题？" class="headerlink" title="如何解决数据库offset超过10000时失效的问题？"></a>如何解决数据库offset超过10000时失效的问题？</h2><p>通过分页查询的方式，偏移量超过一万的情况下，我们可以通过limit的分页查询机制，一直查到第10001条数据的主键id，然后从此id开始进一步根据条件查询需要获取的数据。</p>
<h2 id="为什么offset超过10000会查询不到数据呢？"><a href="#为什么offset超过10000会查询不到数据呢？" class="headerlink" title="为什么offset超过10000会查询不到数据呢？"></a>为什么offset超过10000会查询不到数据呢？</h2><p>OFFSET工作原理是通过全表扫描，先查询所有匹配的记录，然后再跳过指定数量的记录，如果偏移量特别大，数据库可能会需要一次性加载大量数据到内存中，会导致内存不足的问题。</p>
<h2 id="实习时候的成长经历"><a href="#实习时候的成长经历" class="headerlink" title="实习时候的成长经历"></a>实习时候的成长经历</h2><p>1、有一次出现过一次消息队列重复消费的情况，当时情况是两个不同的测试环境，做相同业务消费时消费了两次，然后查代码一直也没有查到原因，就去看配置环境，原来是当时运维那边部署消息队列，两个环境都部署到了一个队列上面，没有做环境隔离。。。</p>
<p>2、在</p>
<h2 id="JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？"><a href="#JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？" class="headerlink" title="JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？"></a>JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？</h2><p><strong>业务及校验流程：</strong></p>
<p>用户通过学号+教务密码向Java后端发起请求，然后Java后端调用Python的服务进行校验账号密码是否正确，如果正确就会向前端返回一个token，客户端将Token保存在本地缓存之中，方便以后在一些业务操作的时候，都会从本地缓存中获取Token并将其放在Http请求的Header中发送请求，服务端获取到请求之后从Http的header里面获取token，并通过服务端保存的密匙进行重新生成新的signature和客户端发过来的token的signature进行比较确认token是否有效，再从payload部分获取相关用户信息进行进一步身份校验。</p>
<p>每次服务端在校验token有效的时候会根据payload的签发token时间+超时时间，当离过期时间只有1天的时候，就会重新签发一个Token给前端。</p>
<p><strong>Token存放位置：</strong></p>
<p>HTTP的Header部分。</p>
<h2 id="Java为什么需要垃圾回收机制呢？"><a href="#Java为什么需要垃圾回收机制呢？" class="headerlink" title="Java为什么需要垃圾回收机制呢？"></a>Java为什么需要垃圾回收机制呢？</h2><p>主要是为了管理内存，自动释放不再使用的对象，以避免内存泄漏和提高程序性能。</p>
<h2 id="什么情况下会出现资源的浪费（内存泄漏）？"><a href="#什么情况下会出现资源的浪费（内存泄漏）？" class="headerlink" title="什么情况下会出现资源的浪费（内存泄漏）？"></a>什么情况下会出现资源的浪费（内存泄漏）？</h2><p>1、长期存活的对象占用过多内存，就是长生命周期对象持有短生命周期的引用导致部分短生命周期的对象一直没有被释放，进而积累过多的情况下出现内存泄漏的问题。</p>
<p>2、各种连接：比如数据库连接、网络连接，对于这些连接操作都需要在不使用的时候进行关闭操作，垃圾回收期才会进行回收。</p>
<p>3、变量作用域不合理：比如要对一个msg进行保存操作，但是msg定义成一个成员变量，然后通过receiveMsg()方法进行相关保存业务逻辑操作，但是因为msg是成员变量，生命周期和类的生命周期一样，所以导致存储操作完成之后，msg还没有被回收释放，可能就会导致内存泄漏。</p>
<h2 id="创建了一个String类型的数据什么时候会被垃圾回收机制回收？"><a href="#创建了一个String类型的数据什么时候会被垃圾回收机制回收？" class="headerlink" title="创建了一个String类型的数据什么时候会被垃圾回收机制回收？"></a>创建了一个String类型的数据什么时候会被垃圾回收机制回收？</h2><p>1、对象不再引用。</p>
<p>2、对象引用被显式设置为null。</p>
<p>3、对象的引用超出作用域：在一个方法内部创建的，那么在这个方法执行完之后就会被收回。</p>
<p>3、垃圾回收机制触发：Java虚拟机判断系统内存不足就会触发此机制，尝试回收不再被使用的对象。</p>
<h2 id="了解哪些垃圾回收算法并介绍一下"><a href="#了解哪些垃圾回收算法并介绍一下" class="headerlink" title="了解哪些垃圾回收算法并介绍一下"></a>了解哪些垃圾回收算法并介绍一下</h2><p><strong>标记-清除算法：</strong></p>
<p>首先标记处所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p>
<p>导致的问题：</p>
<p>1、标记清除的过程效率都不高</p>
<p>2、标记清除后会产生大量不连续的内存碎片。</p>
<p><strong>复制算法：</strong></p>
<p>将内存空间分为两半，每次使用其中的一块，当这块使用完之后，将这块还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</p>
<p>导致的问题：</p>
<p>1、可用内存变小。</p>
<p>2、不适合老年代，如果存活对象数量大，复制性能会比较差。</p>
<p><strong>标记-整理算法：</strong></p>
<p>标记不需要回收的对象，然后将没有标记的对象统一向一端移动，然后直接清理掉端边界以外的内存。</p>
<p>导致问题：</p>
<p>只适合老年代回收频率较低的场景</p>
<p><strong>分代收集算法：</strong></p>
<p>根据不同对象的生命周期将内存分为几块。一般将Java堆分为新生代和老年代，可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如：新生代中，每次都会有大量对象死去，可以选择<strong>复制算法</strong>，只需要付出少量对象的复制成本就可以完成垃圾收集。而对于老年代生命周期较长，存活率较高，可以选择<strong>标记-清除算法</strong>或者<strong>标记-整理算法</strong>实现。</p>
<h2 id="垃圾回收机制为什么要分新生代和老年代呢？"><a href="#垃圾回收机制为什么要分新生代和老年代呢？" class="headerlink" title="垃圾回收机制为什么要分新生代和老年代呢？"></a>垃圾回收机制为什么要分新生代和老年代呢？</h2><p>根据不同对象的生命周期将内存分为几块。一般将Java堆分为新生代和老年代，可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<h2 id="为什么新生代和老年代不放在一起进行回收呢？"><a href="#为什么新生代和老年代不放在一起进行回收呢？" class="headerlink" title="为什么新生代和老年代不放在一起进行回收呢？"></a>为什么新生代和老年代不放在一起进行回收呢？</h2><p>1、不同对象生命周期：可以根据不同的生命周期对象采用不同的回收策略</p>
<p>2、不同回收算法：一般新生代会采用复制算法清除，因为可以标记较少的对象复制到另一块内存上面去，然后一次性清理整个区域，效率较高，对于老年代生命周期长且存活率高，就可以采用标记-整理或者标记-删除的办法，将不需要回收的对象进行标记，然后直接删除没有标记的即可。</p>
<p>3、避免频繁回收老年代：混在一起会导致老年代频繁的回收，降低系统的性能。</p>
<h2 id="数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？"><a href="#数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？" class="headerlink" title="数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？"></a>数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？</h2><ul>
<li>数组访问效率比链表高，因为链表通常是动态扩容的，每次的动态调整都会带来一定的开销以及维护指针等，所以访问效率较低。</li>
<li>链表能灵活进行动态扩容或缩容，但是数组一旦确定大小就不能进行扩容和缩容操作了。</li>
<li>链表有丰富的api可以直接动态进行增删查改，而数组是一个固定长度的数组，只能按下标访问其中的元素，不具备动态增删的能力。</li>
<li>链表只能存储对象（对于基本数据类型可以采用包装类进行存储），但是数组既可以存储对象也可以存储基本数据类型。</li>
<li>链表可以通过泛型保证类型安全，但是数组不可以。</li>
</ul>
<h2 id="有没有一个数据结构可以访问元素时间是O-1-，又可以灵活的调整他的容量大小？"><a href="#有没有一个数据结构可以访问元素时间是O-1-，又可以灵活的调整他的容量大小？" class="headerlink" title="有没有一个数据结构可以访问元素时间是O(1)，又可以灵活的调整他的容量大小？"></a>有没有一个数据结构可以访问元素时间是O(1)，又可以灵活的调整他的容量大小？</h2><p>哈希表可以将key映射到存储位置来实现快速访问，使用哈希函数将键转换成索引，然后将值存在对应索引的位置，在理想情况下，能够在O（1）情况下根据键找到对应的值。哈希表具有灵活的扩容机制，当哈希表中元素过多的时候就会自动扩容，重新分配更大的空间。</p>
<h2 id="HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）"><a href="#HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）" class="headerlink" title="HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）"></a>HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）</h2><p>hashmap是基于数组+链表/红黑树的数据结构来具体实现的，首先hashmap产生哈希冲突的时候会判断链表的长度是否大于8，如果大于的话就会转换成红黑树（此时进入红黑树转换的函数的时候，会判断数组的长度是否大于64，如果数组长度小于64，就不会转换成红黑树，而是选择扩容的机制解决哈希冲突）</p>
<p>选择红黑树的原因：</p>
<p>1、如果是<strong>二叉查询树</strong>比较极端的情况下，当子节点都比父节点大或者小的时候，二叉查找树又会退化成链表，此时时间复杂度又是O(n)。</p>
<p>2、如果是<strong>平衡二叉树（AVL）</strong>，因为它每个节点的左子树和右子树的高度差至多等于1，如果大于1了就会通过左旋或者右旋的方式，使其复杂度一直维持在O(logN)，但是因为这个左旋和右旋的原因，导致插入数据的时候需要消耗大量的时间。</p>
<h2 id="场景题：现在有路由器a-b-c-d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？"><a href="#场景题：现在有路由器a-b-c-d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？" class="headerlink" title="场景题：现在有路由器a,b,c,d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？"></a>场景题：现在有路由器a,b,c,d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？</h2><p>在IP层遇到循环路由的情况下，数据包会被丢弃。IP协议是一种无连接的、不可靠的协议，它不会主动检查循环路由或处理数据包的循环传递。</p>
<p>为了防止数据包在网络中无限循环，网络管理员通常会配置路由器使用一些防循环机制，比如距离矢量路由协议中的Split Horizon技术，或链路状态路由协议中的Reverse Path Forwarding（RPF）检查。这些机制有助于检测和避免数据包在网络中形成循环路径。</p>
<p>但是，即使配置了防循环机制，由于网络的复杂性和问题可能的多样性，有时候循环路由问题仍然可能发生。在这种情况下，IP层不会继续无限传递数据包，而是丢弃它，从而避免对网络产生更严重的影响。丢弃数据包是为了确保网络中的数据传输是可靠和有效的，即使牺牲了某些数据包。</p>
<h2 id="Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？"><a href="#Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？" class="headerlink" title="Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？"></a>Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？</h2><p>stat的基本单位是块，也就是byte。转换成可识别的大小的话，通过1 kb = 1024byte实现。</p>
<p>可以通过ls -lh</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>快手测开 2023 - 7 - 11</title>
    <url>/2023/07/23/%E9%9D%A2%E7%BB%8F-%E5%BF%AB%E6%89%8B%E6%B5%8B%E5%BC%80%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="简单介绍一下二手市场整体的架构，数据流的实现？"><a href="#简单介绍一下二手市场整体的架构，数据流的实现？" class="headerlink" title="简单介绍一下二手市场整体的架构，数据流的实现？"></a>简单介绍一下二手市场整体的架构，数据流的实现？</h2><p><strong>整体架构：</strong></p>
<ol>
<li>持久层和缓存的选型<ol>
<li>MySQL作为持久层：<ol>
<li>支持复杂条件数据查询：在二手市场中，用户会根据自身需求筛选不同的条件进行各种复杂的查询，例如按照不同条件筛选商品等，MySQL提供丰富的查询语言和索引支持，能够高效查询相关数据。</li>
<li>结构化数据存储：二手市场涉及大量的结构化数据，例如：用户信息，商品信息等。而MySQL是关系型数据库，适合存储和管理结构化数据，提供事务支持，保证数据的一致性和完整性。</li>
</ol>
</li>
<li>Redis作为缓存：<ol>
<li>二手市场是多读少写的场景，用户会频繁的浏览商品，但是对商品的修改变更有限，所以可以将物品信息添加至Redis中有效减轻MySQL的读取压力，提高系统的响应和性能。</li>
</ol>
</li>
</ol>
</li>
<li>服务的拆分方式</li>
</ol>
<p>暂时因为是单体架构，没有钱去购买太多的服务器，所以服务暂时没有进行具体的划分，如果要进行划分的话我觉得可以划分成以下几种服务：</p>
<ol>
<li><p>用户服务：主要是对用户的身份信息进行认证和鉴权。</p>
</li>
<li><p>UGC消息通知：可以处理二手市场发布、编辑商品信息后，通过邮件、消息推送的方式告知用户。</p>
</li>
<li><p>商品信息服务：负责二手商品信息的发布、编辑、删除、搜索等功能。</p>
</li>
<li><p>缓存服务：应对二手市场这种读大于写的场景，可以将最新的50条商品信息放入系统缓存中，优化用户查看商品的体验。</p>
</li>
<li><p>支付服务：支付服务负责处理用户的支付请求，与第三方支付平台进行交互，并确保支付的安全性和可靠性。</p>
</li>
<li><p>文件服务：用于处理用户上传的图片、视频。</p>
</li>
<li><p>服务容灾和负载均衡方式</p>
<ol>
<li>服务容灾：<ol>
<li>定期对系统的数据进行备份</li>
<li>定期检查维护服务器的实例，修复代码BUG等</li>
</ol>
</li>
<li>负载均衡：<ol>
<li>CDN服务：将静态资源（图片、视频等）放置在内容分发网络中，加快资源加载速度，减少服务器负载</li>
<li>缓存数据，使用缓存减轻服务器负担，提高响应速度</li>
<li>反向代理：通过Nginx反向代理服务实现负载均衡，等后面有多台服务器之后将请求分发给不同的服务器，提高服务可扩展性。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>数据流实现：</strong></p>
<ol>
<li>用户上传商品：<ol>
<li>用户在应用中填写商品信息，并上传相关照片</li>
<li>上传的用户信息和照片URL被发送到服务器中进行处理和存储</li>
<li>服务器对传过来的数据进行数据库存储，并生成一个唯一ID</li>
</ol>
</li>
<li>商品展示和搜索：<ol>
<li>其他用户访问二手市场时，前端向后端请求商品数据</li>
<li>后端从数据库中获取数据列表，并返回给前端</li>
<li>用户可以根据自身的需求条件查询特定的商品，前端将搜索条件发送给后端，后端根据条件查询数据库并返回匹配的商品信息。</li>
</ol>
</li>
<li>商品详情获取：<ol>
<li>当用户点击某个商品的详情信息之后，前端发送请求，传递对应的商品ID给后端</li>
<li>后端根据商品ID在数据库中搜索并返回具体商品信息给前端展示</li>
</ol>
</li>
</ol>
<h2 id="如果检索某个具体商品是如何实现检索的？"><a href="#如果检索某个具体商品是如何实现检索的？" class="headerlink" title="如果检索某个具体商品是如何实现检索的？"></a>如果检索某个具体商品是如何实现检索的？</h2><h2 id="查询的时候如何避免慢查询？"><a href="#查询的时候如何避免慢查询？" class="headerlink" title="查询的时候如何避免慢查询？"></a>查询的时候如何避免慢查询？</h2><ul>
<li>索引优化，将经常用到的字段创建索引（除去经常更新的字段、重复度很高的字段、数据量较少的情况），比如单列索引和联合索引，从而避免全表扫描。</li>
<li>分页查询：对于返回大量的数据查询，使用分页查询的方式，限制返回的数据量，避免一次返回大量的数据导致查询速率很慢。</li>
<li>缓存查询：对于一些比较查询比较频繁的数据可以使用缓存来避免每次都进行数据库查询。</li>
<li>合理设计数据库的表结构：比如说说评论查询，二级评论可以通过添加一个masterId字段(对应的说说id)来快速定位到此二级评论是归属于哪条说说之下。</li>
</ul>
<h2 id="如何正确的创建索引？（即：什么时候创建索引？）"><a href="#如何正确的创建索引？（即：什么时候创建索引？）" class="headerlink" title="如何正确的创建索引？（即：什么时候创建索引？）"></a>如何正确的创建索引？（即：什么时候创建索引？）</h2><ul>
<li>字段具有唯一性限制，即重复度很低，且不是经常修改的字段</li>
<li>经常用于where子句查询</li>
<li>经常用于group by 或者 order by查询</li>
<li>表的数据量比较多的情况</li>
</ul>
<h2 id="二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？"><a href="#二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？" class="headerlink" title="二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？"></a>二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？</h2><ol>
<li>正确、错误、空物品查询</li>
<li>物品大小写查询</li>
<li>高并发查询</li>
<li>过滤项查询</li>
<li>物品状态查询</li>
<li>安全性测试：比如SQL注入</li>
<li>边界值测试：比如输入极限情况下，很长的字符串验证系统是否能正确处理。</li>
</ol>
<h2 id="后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？"><a href="#后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？" class="headerlink" title="后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？"></a>后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？</h2><ol>
<li>统计性能的方式：<ol>
<li>日志记录</li>
<li>性能监控工具的使用：比如New Relic、Prometheus等</li>
<li>负载测试，模拟大量并发请求，观察系统的响应情况和性能指标。</li>
</ol>
</li>
<li>有，限流操作如下：<ol>
<li>固定窗口计时器：设置一个固定时间窗口，例如</li>
</ol>
</li>
</ol>
<h2 id="HashMap、HashSet、HashTable的区别？"><a href="#HashMap、HashSet、HashTable的区别？" class="headerlink" title="HashMap、HashSet、HashTable的区别？"></a>HashMap、HashSet、HashTable的区别？</h2><p><strong>HashMap和HashTable区别：</strong></p>
<ul>
<li>线程是否安全：HashMap是非线程安全，HashTable是线程安全（通过synchronized修饰实现）。</li>
<li>效率：由于HashMap线程不安全，HashMap比HashTable效率高，但是HashTable几乎被淘汰，平时一般不会用HashTable。</li>
<li>键值对存值问题：HashMap是可存null键和null值，HashTable不允许有null键和null值，否则会抛出异常NPE。</li>
<li>初始容量大小和每次扩充容量大小不同：HashTable初始化容量是11，每次扩容就是2n+1，HashMap初始化容量是16，每次扩容就是原来的2n倍。</li>
<li>底层数据结构：HashMap是<strong>数组+<strong><strong>链表</strong></strong>/红黑树</strong>实现，在解决哈希冲突时，当链表长度大于阈值（默认为8），将链表转化成红黑树（将链表转化成红黑树之前，如果数组长度小于64就会进行数组扩容，而不是转换成红黑树），以减少搜索时间，而HashTable是<strong>数组+链表</strong>的形式实现。</li>
</ul>
<p><strong>HashMap和<strong><strong>HashSet</strong></strong>的区别：</strong></p>
<ul>
<li>HashMap实现Map接口，HashSet实现Set接口。</li>
<li>HashMap存储键值对，HashSet只存储对象。</li>
<li>HashMap通过put方法添加元素，HashSet通过add()向Set中添加元素。</li>
<li>HashMap使用Key计算hashcode，HashSet使用成员对象计算hashcode值。</li>
</ul>
<h2 id="HashMap是线程的安全的吗？介绍一下ConcurrentHashMap"><a href="#HashMap是线程的安全的吗？介绍一下ConcurrentHashMap" class="headerlink" title="HashMap是线程的安全的吗？介绍一下ConcurrentHashMap"></a>HashMap是线程的安全的吗？介绍一下ConcurrentHashMap</h2><p>线程<strong>不安全</strong>，因为多线程情况下，HashMap进行键值对存值的时候，可能会因为分配到一个桶里面造成数据覆盖的风险，比如线程1，2同时进行put操作，此时正好发生了hash冲突，线程1执行完hash冲突判断之后，时间片耗尽挂起，此时线程2进行hash冲突判断并对数据插入到链表中，后面等线程1重新获取到时间片，进行插入操作就会覆盖掉线程插入的数据。</p>
<p><strong>ConcuurentHashMap：</strong></p>
<p>Java8以上数据结构是Node数组+链表/红黑树，哈希冲突时当链表长度大于一定长度时，链表就会转换成红黑树。</p>
<h2 id="接口和抽象类的区别？"><a href="#接口和抽象类的区别？" class="headerlink" title="接口和抽象类的区别？"></a>接口和抽象类的区别？</h2><ul>
<li>接口是对类的行为进行约束，实现了某个接口就是已经拥有了具体的行为，抽象类是代码复用，强调的是类的从属关系。</li>
<li>接口的成员变量只能用public static final修饰且不可修改和初始化，抽象类的成员变量默认为default类型，可以在子类被重新赋值定义。</li>
<li>一个类可以实现多个接口但是只能继承一个父类。</li>
</ul>
<h2 id="如果某个网页打不开了，排查手段有哪些？"><a href="#如果某个网页打不开了，排查手段有哪些？" class="headerlink" title="如果某个网页打不开了，排查手段有哪些？"></a>如果某个网页打不开了，排查手段有哪些？</h2><h2 id="Linux中查看主目录下以-log结尾的文件？"><a href="#Linux中查看主目录下以-log结尾的文件？" class="headerlink" title="Linux中查看主目录下以.log结尾的文件？"></a>Linux中查看主目录下以.log结尾的文件？</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /path/to/home/directory -<span class="built_in">type</span> f -name <span class="string">&quot;*.log&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>find</code>：命令本身，用于查找文件和目录。</li>
<li><code>/path/to/home/directory</code>：替换为你要查找的主目录的路径。例如，如果你要在当前用户的主目录下查找，可以使用<code>~</code>代替这个路径。</li>
<li><code>-type f</code>：表示只查找普通文件，不包括目录等其他类型的文件。</li>
<li><code>-name &quot;*.log&quot;</code>：表示查找文件名以<code>.log</code>结尾的文件。<code>*.log</code>是通配符，表示匹配所有以<code>.log</code>结尾的文件名。</li>
</ul>
<h2 id="如何查询某个日志的内容？"><a href="#如何查询某个日志的内容？" class="headerlink" title="如何查询某个日志的内容？"></a>如何查询某个日志的内容？</h2><ul>
<li>Cat</li>
<li>Head</li>
<li>Tail</li>
<li>Less</li>
<li>More</li>
</ul>
<h2 id="比较一下less命令和more命令的区别？"><a href="#比较一下less命令和more命令的区别？" class="headerlink" title="比较一下less命令和more命令的区别？"></a>比较一下less命令和more命令的区别？</h2><ul>
<li>less支持前后翻页，more只支持向后翻页</li>
<li>less是根据要展示的内容加载到内存中，加快读取速度，more是将整个文件内容全部加载到内存中，可能会导致崩溃</li>
</ul>
<h2 id="算法题：力扣平衡字符串问题"><a href="#算法题：力扣平衡字符串问题" class="headerlink" title="算法题：力扣平衡字符串问题"></a>算法题：力扣平衡字符串问题</h2>]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>滴滴golang后端实习 2023 - 07 - 04</title>
    <url>/2023/07/23/%E9%9D%A2%E7%BB%8F-%E6%BB%B4%E6%BB%B4Golang%E5%AE%9E%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="HTTP有哪些请求方式？"><a href="#HTTP有哪些请求方式？" class="headerlink" title="HTTP有哪些请求方式？"></a>HTTP有哪些请求方式？</h2><ul>
<li>PUT：将数据存储在服务器，覆盖指定URL，常用于更新资源</li>
<li>GET：从服务器获取数据，GET请求是幂等的，即多次请求相同的URL会返回相同的结果</li>
<li>POST：向服务器提交数据，通常用于向服务器发送数据，比如提交表单</li>
<li>DELETE：从服务器删除指定的URL资源。</li>
<li>HEAD：类似于GET请求，但服务器只返回头部信息，不返回实际数据。主要用于检查资源的元数据，例如确认资源是否存在或最后修改日期等。</li>
<li>OPTIONS：获取目标URL支持的请求方法信息。用于查询服务器支持哪些HTTP方法。</li>
<li>PATCH：用于对资源进行局部更新，更新指定的字段而不是像PUT一样更新整个资源。</li>
<li>TRACE：用于目标服务器上执行一个消息环回测试，主要用于诊断。</li>
<li>CONNECT：用于代理服务器请求，通常用于建立代理服务器的隧道。</li>
</ul>
<h2 id="POST和GET的使用场景及区别？"><a href="#POST和GET的使用场景及区别？" class="headerlink" title="POST和GET的使用场景及区别？"></a>POST和GET的使用场景及区别？</h2><p>POST主要用于客户端向服务端提交数据的时候使用，GET主要用于客户端向服务端获取请求的时候使用。</p>
<p>POST和GET实际上没有什么区别，如果硬要说有区别可见如下：</p>
<ul>
<li>GET方法产生一个数据包，POST方法产生两个数据包。<ul>
<li>GET方法会将header和data一并发给服务器，服务器响应200。</li>
<li>POST方法会先发送header给服务器，等服务器返回100之后发送data给服务器，然后服务器响应200。此方法在网络差的情况下，会稍微好一点，因为分两次发可能丢包率会小一些。（POST请求，数据包Firefox只会发一次）</li>
</ul>
</li>
<li>GET请求URL传递的参数会有长度限制，POST没有</li>
<li>GET请求传递参数放在URL中，POST放在Body部分</li>
<li>GET请求只接受ASCII字符，POST无限制</li>
<li>GET请求比POST更不安全，因为参数会外漏在URL，所以不能传递敏感信息。</li>
</ul>
<h2 id="Token在HTTP请求的时候会放在什么位置？"><a href="#Token在HTTP请求的时候会放在什么位置？" class="headerlink" title="Token在HTTP请求的时候会放在什么位置？"></a>Token在HTTP请求的时候会放在什么位置？</h2><p>一般存在header里面的Authorization字段，Java获取的此字段信息的代码一般如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取Authorization头的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorizationHeader</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        System.out.println(authorizationHeader);</span><br><span class="line"></span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？"><a href="#GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？" class="headerlink" title="GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？"></a>GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？</h2><ol>
<li>有长度限制。</li>
<li>不是HTTP本身限制了这个URL长度，一般是指定的浏览器或者服务器对它进行了长度的限制，超过一定的限制，服务器可能会直接返回错误或者截断URL，发生错误的请求。</li>
<li>解决URL超长问题方法如下：<ol>
<li>采取POST请求，因为POST请求对数据传输的长度没有限制</li>
<li>分割请求，如果传输的数据量很大，可以分割成很多小的请求分批次进行数据发送，然后服务端进行整合。</li>
<li>避免GET请求传输大量的数据。</li>
<li>压缩URL参数：通过将GET请求的URL参数进行压缩，转换成Base64来压缩参数，减少URL长度。</li>
</ol>
</li>
</ol>
<h2 id="介绍一下对Spring的理解"><a href="#介绍一下对Spring的理解" class="headerlink" title="介绍一下对Spring的理解"></a>介绍一下对Spring的理解</h2><p>是一款开源的轻量级开发框架，是多个模块的集合，比如：Spring IOC、Spring AOP等。</p>
<ol>
<li>SpringIOC（DI）</li>
<li>SpringAOP</li>
<li>可以整合其他技术开发</li>
</ol>
<h2 id="Spring、SpringMVC、SpringleBoot的区别"><a href="#Spring、SpringMVC、SpringleBoot的区别" class="headerlink" title="Spring、SpringMVC、SpringleBoot的区别"></a>Spring、SpringMVC、SpringleBoot的区别</h2><ul>
<li>Spring的核心模块就是Spring-Core（主要负责SpringIOC容器的依赖注入的支持），Spring其他所有功能都依赖此模块（包括SpringMVC）。</li>
<li>SpringMVC是Spring中得一个模块，主要赋予Spring快速构建MVC架构的Web程序能力，MVC（Model、View、Controller），其核心思想就是将业务逻辑、数据处理、视图显示分离来组织代码。</li>
<li>SpringBoot只是简化了配置，减少配置文件（比如xml文件、Java显示配置，开箱即用）</li>
</ul>
<h2 id="解释一下SpringIOC、SpringAOP"><a href="#解释一下SpringIOC、SpringAOP" class="headerlink" title="解释一下SpringIOC、SpringAOP"></a>解释一下SpringIOC、SpringAOP</h2><p><strong>Spring</strong> <strong>IOC<strong><strong>（</strong></strong>inversion of control<strong><strong>，</strong></strong>控制反转****）</strong></p>
<p>是一种设计思想，其思想就是把原本在程序创建对象的控制权，统一交给SpringIOC容器去管理，控制：创建对象实例的权利，反转：控制权交给Spring框架、IOC容器去管理。</p>
<p>有了SpringIOC之后，我们只需要直接从容器中获取对象即可，而对象的创建是交给SpringIOC容器去创建管理的。</p>
<p>实现方式：</p>
<p>1、从配置元数据获取DI的业务POJO（配置元数据：xml、Configuration、注解等）</p>
<p>2、将业务POJO形成BeanDefinition注入到Spring Container中</p>
<p>3、使用方通过AppllicationContext从SpringContainer中获取即可</p>
<p><strong>Spring AOP（Aspect Object Programming，<strong><strong>面向切面编程</strong></strong>）</strong></p>
<p>就是把公共逻辑抽出来，让开发者更加专注于业务逻辑开发。AOP是一种设计思想，是OOP的补充，OOP是面向类和对象的，但是AOP是面向不同切面的，一个切面可以横跨多个类和对象去操作，极大的提高了开发效率。</p>
<p>比如一个订单的创建，大致流程是：</p>
<p>1、权限校验</p>
<p>2、事务管理</p>
<p>3、创建订单</p>
<p>4、日志管理</p>
<p>使用AOP思想就可以把这四个步骤当作四个切面，让开发者专注于第三个切面，其他三个切面则使用基础的通用逻辑统一交给AOP封装管理。</p>
<h2 id="SpringAOP是如何实现的？"><a href="#SpringAOP是如何实现的？" class="headerlink" title="SpringAOP是如何实现的？"></a>SpringAOP是如何实现的？</h2><p>AOP实现原理：</p>
<p>AOP实现有两种方式，一种是Java原生的动态代理，一种是基于cglib的动态代理。默认的一般是原生的JDK的动态代理，但是这种代理方式无法代理没有接口的类，此时就会使用cglib代理这个没有接口实现的类。</p>
<h2 id="Sql注入攻击是什么？SQL注入是怎么产生的？"><a href="#Sql注入攻击是什么？SQL注入是怎么产生的？" class="headerlink" title="Sql注入攻击是什么？SQL注入是怎么产生的？"></a>Sql注入攻击是什么？SQL注入是怎么产生的？</h2><p><strong>SQL注入攻击****：</strong>针对使用SQL进行数据查询和操作的应用程序，基本原理是通过在用户输入的数据中插入恶意的SQL代码，从而让应用程序执行未经授权的数据库操作或者或者泄露敏感信息。</p>
<p>比如SQL = select * from user where username = ‘#{username}’ and password = ‘#{password}’，攻击者在用户名框或者密码输入框中输入恶意的SQL代码：<code>&#39; OR 1 = 1 --</code> 就会变成<code>select * from user where username = &#39;&#39; or 1 = 1  --&#39;and password=&#39;&#39;</code> ，此时<code>-- &#39; and password = &#39;&#39;</code> 已经被注释掉了实际上就是<code>select * from user where username = &#39;&#39; or 1 = 1;</code> 此时就会将所有用户的数据信息全部返回给前端。</p>
<p><strong>SQL注入的产生</strong></p>
<p>1、参数未校验，用户不正确的输入</p>
<p>2、特殊字符未转义，例如：=、–这种类型的符号</p>
<h2 id="什么时候需要创建索引？"><a href="#什么时候需要创建索引？" class="headerlink" title="什么时候需要创建索引？"></a>什么时候需要创建索引？</h2><ul>
<li>字段具有唯一性限制</li>
<li>经常用于where子句查询的字段</li>
<li>经常用于group by 和 order by查询的字段</li>
</ul>
<h2 id="为什么索引如果重复度比较高的时候会对数据库产生一定的压力？"><a href="#为什么索引如果重复度比较高的时候会对数据库产生一定的压力？" class="headerlink" title="为什么索引如果重复度比较高的时候会对数据库产生一定的压力？"></a>为什么索引如果重复度比较高的时候会对数据库产生一定的压力？</h2><ul>
<li>导致页分裂，占用物理空间大：每次数据更新的话，会导致索引进行重新排序，甚至造成页分裂的问题，导致索引查询效率下降，也会在一定程度上造成空间不必要的浪费。</li>
<li>维护成本高：索引重复度比较高也会导致索引字段大小很大，维护空间和时间成本就会变大，占用一定的冗余物理空间</li>
<li>查询效率低：索引重复度比较高可能会匹配到多个符合条件的索引项，进而增加查询的开销，导致查询效率下降。</li>
<li>内存消耗大：如果是5.7的版本，由于MySQL的索引缓存存在的原因，索引重复度高，索引大小也会变大，需要更多的内存去存储这些数据，高内存可能会导致服务器崩溃。</li>
</ul>
<h2 id="创建联合索引失效的情况"><a href="#创建联合索引失效的情况" class="headerlink" title="创建联合索引失效的情况"></a>创建联合索引失效的情况</h2><p>当where子句查询或者order by或者group by查询的时候没有遵循最左匹配原则则会导致查询时联合索引部分失效。</p>
<p>比如:创建索引(a,b,c)，此时<code>select * from user where a = 1 and b = 1 and c = 1;</code>此时均用到了联合索引。</p>
<p>若改成<code>select * from user where a = 1 and b &gt; 1 and c = 1;</code>此时用到了索引的只有a,b，因为索引查询是先对a进行排序，在a相等的情况下，对b再进行排序，最后在b相同的情况下对c进行排序，此时因为b &gt; 1无法直接定位到从哪个索引列开始顺序查询，也就是说对c再进行排序的话无法进一步提高查询速率，所以只有a，b用到了联合索引。</p>
<blockquote>
<p>一条查询语句的顺序是from -&gt; where -&gt; group by -&gt; Having -&gt; select -&gt; order by</p>
</blockquote>
<h2 id="如果有一个联合索引-a-b-c-，如果where子句查询只有a-1-and-c-1，能不能实现走-a-b-c-这个索引查询？"><a href="#如果有一个联合索引-a-b-c-，如果where子句查询只有a-1-and-c-1，能不能实现走-a-b-c-这个索引查询？" class="headerlink" title="如果有一个联合索引(a,b,c)，如果where子句查询只有a = 1 and c = 1，能不能实现走(a,b,c)这个索引查询？"></a>如果有一个联合索引(a,b,c)，如果where子句查询只有a = 1 and c = 1，能不能实现走(a,b,c)这个索引查询？</h2><p>1、如果能够修改a,b,c联合索引的顺序的话，就可以实现，比如改成<code>(a,c,b)</code> 因为联合索引遵循<strong>最左匹配原则</strong>，即先对a排序，在a相同的情况下，对c排序，在c相同的情况下再对b进行排序，最终形成索引B+树。</p>
<p>2、如果不可以修改联合索引的顺序，那么将无法实现走a,b,c形成的联合索引查询，此时只有a = 1能走到联合索引。</p>
<h2 id="目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？"><a href="#目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？" class="headerlink" title="目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？"></a>目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？</h2><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> age , sex , count<span class="comment">(*) from user group by age , sex;</span></span><br><span class="line"><span class="comment">select age , count(*)</span> <span class="keyword">from</span> user <span class="keyword">group</span> <span class="keyword">by</span> age<span class="punctuation">;</span> </span><br></pre></td></tr></table></figure>

<h2 id="有两个集合List如何快速找出相同的元素？"><a href="#有两个集合List如何快速找出相同的元素？" class="headerlink" title="有两个集合List如何快速找出相同的元素？"></a>有两个集合List如何快速找出相同的元素？</h2><p>思路大致如下：</p>
<ol>
<li>创建并初始化两个List类型的链表</li>
<li>将两个List类型的列表转换成HashSet类型</li>
<li>使用HashSet自带的取交集方法<code>set1.retainAll(set2)</code> ，此时set1中保存的就是原set1和set2的交集，即两个集合相同的元素。</li>
</ol>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindCommonElements</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例数据</span></span><br><span class="line">        List&lt;Integer&gt; list1 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用HashSet找出相同元素</span></span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list1);</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list2);</span><br><span class="line"></span><br><span class="line">        set1.retainAll(set2); <span class="comment">// 保留set1中与set2的交集</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set1); <span class="comment">// 输出：[3, 4, 5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构：哈希如何使用？"><a href="#数据结构：哈希如何使用？" class="headerlink" title="数据结构：哈希如何使用？"></a>数据结构：哈希如何使用？</h2><p>「哈希表 Hash Table」通过建立键 <code>key</code> 与值 <code>value</code> 之间的映射，实现高效的元素查询。具体而言，我们向哈希表输入一个 <code>key</code> ，则可以在O(1)时间内获取对应的 <code>value</code> 。</p>
<p>详情见下：</p>
<p><a href="https://www.hello-algo.com/chapter_hashing/hash_map/">哈希表（Hello算法）</a></p>
<h2 id="有一个集合Set怎么批量删除部分元素？"><a href="#有一个集合Set怎么批量删除部分元素？" class="headerlink" title="有一个集合Set怎么批量删除部分元素？"></a>有一个集合Set怎么批量删除部分元素？</h2><p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoveElementsFromSet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 原始Set</span></span><br><span class="line">        Set&lt;Integer&gt; originalSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        originalSet.add(<span class="number">1</span>);</span><br><span class="line">        originalSet.add(<span class="number">2</span>);</span><br><span class="line">        originalSet.add(<span class="number">3</span>);</span><br><span class="line">        originalSet.add(<span class="number">4</span>);</span><br><span class="line">        originalSet.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要删除的元素集合</span></span><br><span class="line">        Set&lt;Integer&gt; elementsToRemove = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        elementsToRemove.add(<span class="number">3</span>);</span><br><span class="line">        elementsToRemove.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 批量删除部分元素</span></span><br><span class="line">        originalSet.removeAll(elementsToRemove);</span><br><span class="line"></span><br><span class="line">        System.out.println(originalSet); <span class="comment">// 输出：[1, 2, 4]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Linux查询一个日志文件的关键字？查询某个关键字的前后500行？"><a href="#Linux查询一个日志文件的关键字？查询某个关键字的前后500行？" class="headerlink" title="Linux查询一个日志文件的关键字？查询某个关键字的前后500行？"></a>Linux查询一个日志文件的关键字？查询某个关键字的前后500行？</h2><p>查询日志文件的某个关键字可以使用grep命令实现，例如:grep ‘关键字’ filePath</p>
<p>查询某个关键字的前后500行：grep -AB 500或者 grep -C 500（-C == -AB）</p>
<h2 id="怎么保证MySQL和Redis的一致性问题"><a href="#怎么保证MySQL和Redis的一致性问题" class="headerlink" title="怎么保证MySQL和Redis的一致性问题"></a>怎么保证MySQL和Redis的一致性问题</h2><p>读请求：先读缓存，如果缓存失效或不存在就让先获取到互斥锁的线程查数据库并回写缓存，让后续的请求直接都缓存即可</p>
<p>写请求：先更新数据库，再删缓存即可（此时可能会出现删缓存失败的场景，可以通过消息队列的方式，采取重试机制，如果删除缓存失败，则通过消息队列再进行一次删除缓存的操作，如果删除成功，则把消息队列里面的删除缓存操作删除即可，避免重复消费，造成不必要的资源浪费）</p>
<h2 id="价格类型的数据Java用什么存储？"><a href="#价格类型的数据Java用什么存储？" class="headerlink" title="价格类型的数据Java用什么存储？"></a>价格类型的数据Java用什么存储？</h2><p>1、BigDecimal（使用String类型的进行转换，才不会导致精度丢失)</p>
<p>2、整数存储（比如：3.14存为314）</p>
<p>3、自定义存储方式，数据库一个字段存整数，一个字段存小数</p>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
</search>
