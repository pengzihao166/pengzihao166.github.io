<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HUT菜鸟小八的博客</title>
  
  
  <link href="http://xiaobazeo.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaobazeo.github.io/"/>
  <updated>2023-08-18T08:59:44.945Z</updated>
  <id>http://xiaobazeo.github.io/</id>
  
  <author>
    <name>xiaoba</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode-k个一组翻转链表</title>
    <link href="http://xiaobazeo.github.io/2023/08/18/leetcode-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://xiaobazeo.github.io/2023/08/18/leetcode-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2023-08-18T08:36:29.000Z</published>
    <updated>2023-08-18T08:59:44.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/reverse_ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/reverse_ex2.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[3,2,1,4,5]</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ul><li>局部翻转</li><li>k &gt; 剩余局部链表长度时，这部分链表无需翻转</li></ul><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li><p>初始化</p><p><code>ListNode dummy = new ListNode(0,head);</code></p></li><li><p>设置指针实现局部翻转</p><p><code>ListNode pre = dummy,end = dummy</code></p></li><li><p>end.next != null 则遍历链表</p><ol><li><p>根据k确定第一组局部链表的尾部指针</p><p><code>for(int i = 0; i &lt; k &amp;&amp; end != null; i++) end = end.next;</code></p><p>此时<code>end == null</code>时，说明剩余的局部链表长度小于k，直接跳出循环无需翻转链表。</p></li><li><p>确定局部链表起始位置及下一组的起始位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start = pre.next;</span><br><span class="line">next = end.next;</span><br></pre></td></tr></table></figure></li><li><p>断开end的后续链表，并调用翻转函数使pre.next连接翻转后的链表。</p><p><code>pre.next = reverse(start);</code></p></li><li><p>重新连接被翻转和未翻转的部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start.next = next;<span class="comment">//连接后面未翻转的链表</span></span><br><span class="line">pre = next;<span class="comment">//重置pre和end指针开始新的一轮链表组的翻转</span></span><br><span class="line">end = pre;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>返回dummy后面所有已经翻转的链表</p></li></ol><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy, end = dummy;</span><br><span class="line">        <span class="keyword">while</span>(end.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="literal">null</span>; i++)&#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> end.next;</span><br><span class="line">            end.next = <span class="literal">null</span>; </span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line">            end = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;给你链表的头节点 &lt;code&gt;head&lt;/code&gt; ，每 &lt;code&gt;k&lt;/code&gt; 个节点一组进行翻转，请你返</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>面经-借钱包交易平台Java开发实习</title>
    <link href="http://xiaobazeo.github.io/2023/08/10/%E9%9D%A2%E7%BB%8F-%E5%80%9F%E9%92%B1%E5%8C%85%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0Java%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/"/>
    <id>http://xiaobazeo.github.io/2023/08/10/%E9%9D%A2%E7%BB%8F-%E5%80%9F%E9%92%B1%E5%8C%85%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0Java%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/</id>
    <published>2023-08-10T05:14:54.000Z</published>
    <updated>2023-08-18T12:46:41.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如果对于jdk版本升级，对于jvm的一些参数修改有哪些？"><a href="#如果对于jdk版本升级，对于jvm的一些参数修改有哪些？" class="headerlink" title="如果对于jdk版本升级，对于jvm的一些参数修改有哪些？"></a>如果对于jdk版本升级，对于jvm的一些参数修改有哪些？</h2><ol><li>-Xmx 和 -Xms：这些参数用于设置 JVM 的最大堆内存和初始堆内存大小。在 JDK 版本升级后，由于可能存在新的特性或改进，建议重新评估应用程序的内存需求，并相应地调整这些参数。</li><li>-XX:NewRatio 和 -XX:SurvivorRatio：这些参数用于调整新生代（Young Generation）和老年代（Old Generation）的比例和新生代中 Eden 区和 Survivor 区的比例。在 JDK 版本升级后，新的默认比例可能会有所变化，可能需要重新设置这些参数以优化垃圾回收性能。</li><li>-XX:+UseConcMarkSweepGC 和 -XX:+UseG1GC 等：这些参数用于选择不同的垃圾回收器。随着 JDK 版本的升级，可能会引入新的垃圾回收器或对现有的回收器进行优化，因此需要根据应用程序的特性和需求选择合适的垃圾回收器和相应的参数。</li><li>-XX:MaxMetaspaceSize：在 JDK 8 及之前的版本中，用于设置永久代（Permanent Generation）的最大大小。但从 JDK 8 开始，永久代被移除，取而代之的是 Metaspace。因此，在 JDK 版本升级后，如果之前使用了永久代的参数，需要调整为 Metaspace 相关的参数。</li><li>其他新的 -XX 开头的参数：随着 JDK 版本的升级，可能会引入新的 JVM 参数，用于控制新的特性或优化性能。因此，在升级后应该查阅新的文档，了解这些新参数的用法和影响，并根据需要进行配置。</li></ol><h2 id="介绍包装类和基本数据类型的自动拆箱和自动装箱"><a href="#介绍包装类和基本数据类型的自动拆箱和自动装箱" class="headerlink" title="介绍包装类和基本数据类型的自动拆箱和自动装箱?"></a>介绍包装类和基本数据类型的自动拆箱和自动装箱?</h2><p>自动装箱：将基本数据类型转换成对应的包装类型</p><p>自动拆箱：将包装类型转换成对应的基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//装箱  Integer.valueOf(10);</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;<span class="comment">//拆箱   n = i.intValue();</span></span><br></pre></td></tr></table></figure><h2 id="什么常见场景会自动触发自动装箱和自动拆箱？"><a href="#什么常见场景会自动触发自动装箱和自动拆箱？" class="headerlink" title="什么常见场景会自动触发自动装箱和自动拆箱？"></a>什么常见场景会自动触发自动装箱和自动拆箱？</h2><p>自动装箱场景：</p><ul><li>将基本数据类型赋值给对应的包装类型，比如:Integer i = 10;</li><li>将基本数据类型作为参数赋值给接受包装类型的方法。</li></ul><p>自动拆箱场景：</p><ul><li>将包装类型赋值给对应的基本数据类型，比如<code>Integer i = 10; int n = i;</code></li><li>将包装类型作为参数赋值给接受对应基本数据类型的方法。</li></ul><h2 id="对于Integer类型的数据进行比较大小需要注意哪些问题？"><a href="#对于Integer类型的数据进行比较大小需要注意哪些问题？" class="headerlink" title="对于Integer类型的数据进行比较大小需要注意哪些问题？"></a>对于Integer类型的数据进行比较大小需要注意哪些问题？</h2><p>1、比较大小：使用equals方法，因为equals方法比较的是对象的值，而==比较的是对象的引用地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">n == i; <span class="comment">// YES</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">a == b;<span class="comment">//NO，因为Integer会缓存-128-127的对象，此时==号比较的是a和b的引用地址，但是此时a和b的值不在此缓存范围内，会重新创建两个不同的引用，进行引用地址的比较。</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">c == d;<span class="comment">//NO</span></span><br><span class="line">c.equals(d);<span class="comment">//YES</span></span><br></pre></td></tr></table></figure><p>2、尽量避免频繁的拆箱装箱，频繁的拆装箱会造成一些不必要的资源损耗。</p><p>3、避免空指针异常：如果包装类型定义了null，此时进行自动拆箱的时候会抛出NPE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n= <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n;<span class="comment">//会抛出NPE,NullPointException</span></span><br></pre></td></tr></table></figure><h2 id="为什么是选择equals方法去比较Integer这一类包装类类型的数据？"><a href="#为什么是选择equals方法去比较Integer这一类包装类类型的数据？" class="headerlink" title="为什么是选择equals方法去比较Integer这一类包装类类型的数据？"></a>为什么是选择equals方法去比较Integer这一类包装类类型的数据？</h2><p>使用==号的时候，如果Integer是通过<code>创建对象或者自动装箱的数据在-128~127的范围就会返回false</code>，==比较的是两个Integer对象的引用地址，如果出现刚刚所述的两种情况，是因为他们此时的所属对象的引用地址不一样导致的。</p><p>而使用equals方法比较的是两个对象之间的值，而不是引用地址。</p><h2 id="在重写一个对象的时候为什么要重写equals-以及hashcode-？"><a href="#在重写一个对象的时候为什么要重写equals-以及hashcode-？" class="headerlink" title="在重写一个对象的时候为什么要重写equals()以及hashcode()？"></a>在重写一个对象的时候为什么要重写equals()以及hashcode()？</h2><p>因为两个相等的对象的hashCode必须相等，不然如果重写了equals方法而没有重写hashCode方法的话可能会出现equals方法判断两个对象相等，但是其hashCode不相等的情况。</p><h2 id="hashmap如何解决哈希碰撞-哈希冲突-问题？"><a href="#hashmap如何解决哈希碰撞-哈希冲突-问题？" class="headerlink" title="hashmap如何解决哈希碰撞(哈希冲突)问题？"></a>hashmap如何解决哈希碰撞(哈希冲突)问题？</h2><h2 id="hashmap在存放一个键值对的时候过程是怎么样的？"><a href="#hashmap在存放一个键值对的时候过程是怎么样的？" class="headerlink" title="hashmap在存放一个键值对的时候过程是怎么样的？"></a>hashmap在存放一个键值对的时候过程是怎么样的？</h2><p>1、对键进行hash计算来确定键值存放的位置</p><p>2、通过取模运算找到具体存储哈希键值对的位置即桶</p><p>3、将键值对存储在对应的桶中，如果产生了哈希冲突就会作为一个节点存入到链表或者红黑树的头部。</p><h2 id="当hashmap转换成红黑树后什么情况下会转回链表？"><a href="#当hashmap转换成红黑树后什么情况下会转回链表？" class="headerlink" title="当hashmap转换成红黑树后什么情况下会转回链表？"></a>当hashmap转换成红黑树后什么情况下会转回链表？</h2><p>当红黑树的节点数小于等于6的时候，会转回链表的形式进行键值对的存储，因为hashCode符合泊松分布，哈希冲突造成链表长度等于6的情况比较高，且红黑树维护节点开销会比链表维护所需开销大，如果是长度等于7的情况的话，可能会导致频繁的链表和红黑树的转换开销和资源浪费。</p><blockquote><p><strong>为什么是<strong><strong>链表</strong></strong>等于8的时候转？</strong></p><p>因为经过统计，当hashCode遵循泊松分布时，因为哈希冲突造成桶的链表长度大于等于8的概率只有0.00000006，所以根据数学推算决定当链表长度等于8时转换成红黑树。而且转换成红黑树之后的维护开销会比链表高很多，所以不会随随便便进行红黑树和链表之间的互相转换。</p></blockquote><h2 id="常见集合list、map、set、queue之间的区别"><a href="#常见集合list、map、set、queue之间的区别" class="headerlink" title="常见集合list、map、set、queue之间的区别"></a>常见集合list、map、set、queue之间的区别</h2><p>list：元素有序，可重复</p><p>set：元素无序，不可重复</p><p>map：以key-value方式存储，key无序、不可重复，value无序、可重复，每个键最多映射到一个值。</p><p>queue：元素有序，可重复。</p><h2 id="关于构建一个线程池我们需要配置的核心参数有哪些？"><a href="#关于构建一个线程池我们需要配置的核心参数有哪些？" class="headerlink" title="关于构建一个线程池我们需要配置的核心参数有哪些？"></a>关于构建一个线程池我们需要配置的核心参数有哪些？</h2><p><strong><code>ThreadPoolExecutor</code></strong> <strong>3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code></strong> <strong>:</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code></strong> <strong>:</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>****:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。</li></ul><h2 id="InnoDB的索引数据结构是什么？介绍一下b-树"><a href="#InnoDB的索引数据结构是什么？介绍一下b-树" class="headerlink" title="InnoDB的索引数据结构是什么？介绍一下b+树"></a>InnoDB的索引数据结构是什么？介绍一下b+树</h2><p>B+树</p><ul><li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。</li><li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li><li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</li></ul><h2 id="为什么B-树千万级别在MySQL只有3-4层？"><a href="#为什么B-树千万级别在MySQL只有3-4层？" class="headerlink" title="为什么B+树千万级别在MySQL只有3-4层？"></a>为什么B+树千万级别在MySQL只有3-4层？</h2><p>非叶子结点一般只有键+指针，也就是8+6 = 14byte，那么一个非叶子结点可以存储的键+指针个数是16<em>1024/14=1170个单元数，如果一条记录是1k，那么一个节点能存16条记录，那么两层的B+树就是16 * 1170=18720条记录，3层的话就是16</em>1170*1170=2190w+条记录。</p><h2 id="Innodb的默认隔离事务级别是什么？什么是可重复读？"><a href="#Innodb的默认隔离事务级别是什么？什么是可重复读？" class="headerlink" title="Innodb的默认隔离事务级别是什么？什么是可重复读？"></a>Innodb的默认隔离事务级别是什么？什么是可重复读？</h2><p>可重复读。</p><p>指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的</p><h2 id="在可重复读的事务隔离级别下，什么场景下会出现幻读的情况？"><a href="#在可重复读的事务隔离级别下，什么场景下会出现幻读的情况？" class="headerlink" title="在可重复读的事务隔离级别下，什么场景下会出现幻读的情况？"></a>在可重复读的事务隔离级别下，什么场景下会出现幻读的情况？</h2><p>场景一（针对快照读）：</p><p>以下表为例：</p><p><img src="https://qazbc6jrkh1.feishu.cn/space/api/box/stream/download/asynccode/?code=YThkOTc3ZDZmNzg5ZDgxNTdmYjQxNzExNDNjN2YyMWJfOTdGNnVRc2NCY0xPSGpTa2pNVWo3VDJKS1I3WTI2b0FfVG9rZW46Tzg0eWJQUVpHb0tNYTZ4TnVYRGM0dktGbkRiXzE2OTIzNjI3NDU6MTY5MjM2NjM0NV9WNA" alt="img"></p><p>事务A执行查询id = 5的记录，此时表中没有此记录，所以查不出来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#事务A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>此时事务B添加一条id = 5的记录，并提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#事务B</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t_stu <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;小美&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>此时，<strong>事务A更新id=5的记录，并查询id=5的记录，此时就能看到事务B插入的记录。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 事务 A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> t_stu <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;小林coding&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)<span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 小林coding   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>时序图如下：</p><p><img src="https://qazbc6jrkh1.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQ2YmI5MDJlMjEwNDY0MDNlN2JmYmYzM2RkOTQ1M2NfUHVJbTIybHFoWHNnVEwxMFdjdmNOZU5oUk5CU05mdFlfVG9rZW46Q2xWOGJnczV6b1o5bk14OG1Za2NaQ1h1blVlXzE2OTIzNjI3NDU6MTY5MjM2NjM0NV9WNA" alt="img"></p><p>场景二（针对当前读）：</p><ul><li>T1时刻，事务A先执行了快照读语句:select * from t_test where id &gt; 100 得到了 3 条记录;</li><li>T2时刻，事务B插入了一条id = 200的记录并提交</li><li>T3时刻，事务A执行当前读：select * from t_test where id &gt; 100;就会得到4条记录</li></ul><h2 id="Maven添加资源包的时候，如何操作？"><a href="#Maven添加资源包的时候，如何操作？" class="headerlink" title="Maven添加资源包的时候，如何操作？"></a>Maven添加资源包的时候，如何操作？</h2><p>在Maven项目中添加资源包（例如配置文件、图像文件、文本文件等）通常涉及以下步骤：</p><ol><li><p><strong>创建资源文件夹</strong>：</p><p>在项目的源代码目录（src/main/java）旁边创建一个资源文件夹，通常命名为”resources”，这是Maven默认的资源文件夹。</p></li><li><p><strong>将资源文件放入资源文件夹</strong>：</p><p>将您的资源文件（例如配置文件、图像等）放入刚刚创建的”resources”文件夹中。</p></li><li><p><strong>更新项目配置文件（pom.xml）</strong>：</p><p>打开项目的<code>pom.xml</code>文件，并在<code>&lt;build&gt;</code>标签下的<code>&lt;resources&gt;</code>标签中配置资源文件夹。示例如下：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 可选：可以配置&lt;filtering&gt;标签来进行资源文件中的属性替换 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可以添加多个&lt;resource&gt;标签来包含多个资源文件夹 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   此配置告诉Maven在构建项目时将资源文件夹中的内容包含在生成的JAR或WAR文件中。</p><ol start="4"><li><p><strong>运行<strong><strong>Maven</strong></strong>构建命令</strong>：</p><p>打开终端或命令提示符，进入项目根目录，然后运行以下命令来执行Maven构建：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><p>   或者如果只需要将资源添加到生成的JAR或WAR中，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn resources:resources</span><br></pre></td></tr></table></figure><ol start="5"><li><p><strong>访问资源文件</strong>：</p><p>在Java代码中，您可以使用类加载器来访问位于资源文件夹中的资源文件。例如，使用以下代码来加载资源文件：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;path/to/resource.file&quot;</span>);</span><br></pre></td></tr></table></figure><p>   其中，<code>path/to/resource.file</code>是资源文件在资源文件夹中的相对路径。</p><h2 id="Maven的常用命令有哪些？"><a href="#Maven的常用命令有哪些？" class="headerlink" title="Maven的常用命令有哪些？"></a>Maven的常用命令有哪些？</h2><h2 id="缓存雪崩、缓存和数据库一致性问题的解决方案？"><a href="#缓存雪崩、缓存和数据库一致性问题的解决方案？" class="headerlink" title="缓存雪崩、缓存和数据库一致性问题的解决方案？"></a>缓存雪崩、缓存和数据库一致性问题的解决方案？</h2><h2 id="如果此时使用的是cookie-session机制，而且是分布式系统的话，怎么实现用户鉴权问题？"><a href="#如果此时使用的是cookie-session机制，而且是分布式系统的话，怎么实现用户鉴权问题？" class="headerlink" title="如果此时使用的是cookie-session机制，而且是分布式系统的话，怎么实现用户鉴权问题？"></a>如果此时使用的是cookie-session机制，而且是分布式系统的话，怎么实现用户鉴权问题？</h2><p>1、SSO单点登录</p><p>2、集中式Session存储</p><h2 id="微布校园有遇到一些比较棘手的问题吗？如果出现问题，如何排查问题？"><a href="#微布校园有遇到一些比较棘手的问题吗？如果出现问题，如何排查问题？" class="headerlink" title="微布校园有遇到一些比较棘手的问题吗？如果出现问题，如何排查问题？"></a>微布校园有遇到一些比较棘手的问题吗？如果出现问题，如何排查问题？</h2><h2 id="当时是什么情况因为kafka挂了导致整个服务全部挂了？"><a href="#当时是什么情况因为kafka挂了导致整个服务全部挂了？" class="headerlink" title="当时是什么情况因为kafka挂了导致整个服务全部挂了？"></a>当时是什么情况因为kafka挂了导致整个服务全部挂了？</h2><h2 id="对于整个技术栈哪些组件有过深入的了解？"><a href="#对于整个技术栈哪些组件有过深入的了解？" class="headerlink" title="对于整个技术栈哪些组件有过深入的了解？"></a>对于整个技术栈哪些组件有过深入的了解？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如果对于jdk版本升级，对于jvm的一些参数修改有哪些？&quot;&gt;&lt;a href=&quot;#如果对于jdk版本升级，对于jvm的一些参数修改有哪些？&quot; class=&quot;headerlink&quot; title=&quot;如果对于jdk版本升级，对于jvm的一些参数修改有哪些？&quot;&gt;&lt;/a&gt;如果</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>微布开发-实现说说审核发布机制(暂未完成)</title>
    <link href="http://xiaobazeo.github.io/2023/08/09/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%AE%9E%E7%8E%B0%E8%AF%B4%E8%AF%B4%E5%AE%A1%E6%A0%B8%E5%8F%91%E5%B8%83%E6%9C%BA%E5%88%B6/"/>
    <id>http://xiaobazeo.github.io/2023/08/09/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%AE%9E%E7%8E%B0%E8%AF%B4%E8%AF%B4%E5%AE%A1%E6%A0%B8%E5%8F%91%E5%B8%83%E6%9C%BA%E5%88%B6/</id>
    <published>2023-08-09T08:04:28.000Z</published>
    <updated>2023-08-09T08:05:03.504Z</updated>
    
    <content type="html"><![CDATA[<h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h3><p>调用微信三方接口进行图片/视频安全校验，由于微信的视频/图片校验结果是异步返回到服务端的接口，所以需要将附有照片或者视频的说说审核通过之后再将说说发布到论坛中。</p><h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><p>1、如何标识所有图片/视频审核完成之后再发布呢？</p><p>因为每次向微信的接口发送请求的时候，会对每张照片的审核都会有一个任务id(trace_id)，根据这个traceid映射对应的is_valid（标识是否校验通过）和talkbid（说说的主键id）字段来标识</p><p>2、是需要通过Redis缓存标识，还是MySQL创建新的表或者新的字段标识？</p><ol><li>单独拉一张表出来存储图片url和trace_id的关系，然后用一个is_valid字段根据微信接口异步返回的结果标识判断是否校验通过，如果校验通过is_valid就变成1，还在校验过程中或者校验未通过就标识0。</li><li>使用Redis通过设置超时时间来使标识自动淘汰，释放内存空间</li><li>在说说表添加一个trace_id字段，存储每张照片的trace_id，并用逗号分隔开，每次微信异步返回结果之后如果审核通过就把trace_id和返回过来的trace_id部分删除，否则就不删除，同时判断此时trace_id字段是否为空，如果等于空值了，那么就说明全部校验通过了、然后将说说详情中的is_delete(说说软删标识)字段设为0，展示到社区论坛中。</li></ol><p>3、以上标识方法会有什么问题呢？为什么最终选用对说说详情表添加字段的方式进行标识呢？</p><p>第一种方法，需要单独创建一个表，会占用一定的磁盘空间，以及MySQL需要花费更大的空间进行维护造成一定的资源浪费。</p><p>第二种方法，Redis是基于内存的一种缓存数据库，如果当有大量的io操作的时候，就会占用内存空间，这个时候很可能会出现Redis崩盘的情况，甚至说Redis宕机，因为微布校园现在是单体架构，暂时无解，只能放弃这个想法了。</p><p>第三种方法，毕竟只是添加一个字段，MySQL的维护成本相对第一种就比较低了，对于第二种方案，数据的读取，MySQL 通常会使用缓冲池（Buffer Pool）来管理数据在内存中的存储。数据会根据需要从磁盘加载到缓冲池中，并且在查询时尽量从缓冲池中读取数据，从而避免频繁的磁盘 I/O 操作。如果数据在缓冲池中已经存在，查询时可以直接从内存中读取，这比从磁盘读取要快得多。反正在读取的时候，要用缓冲池的机制将数据放到内存中，再从缓冲池中读取数据，这样相对单独用Redis去维护标识会好很多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;业务场景：&quot;&gt;&lt;a href=&quot;#业务场景：&quot; class=&quot;headerlink&quot; title=&quot;业务场景：&quot;&gt;&lt;/a&gt;业务场景：&lt;/h3&gt;&lt;p&gt;调用微信三方接口进行图片/视频安全校验，由于微信的视频/图片校验结果是异步返回到服务端的接口，所以需要将附有照片或者</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>微布开发-优化UGC消息拉取响应速度</title>
    <link href="http://xiaobazeo.github.io/2023/08/09/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%BC%98%E5%8C%96UGC%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6/"/>
    <id>http://xiaobazeo.github.io/2023/08/09/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%BC%98%E5%8C%96UGC%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6/</id>
    <published>2023-08-09T05:06:18.000Z</published>
    <updated>2023-08-09T06:04:19.009Z</updated>
    
    <content type="html"><![CDATA[<h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a><strong>业务场景：</strong></h3><p>小程序端消息通知tab页中点赞通知列表、新粉丝通知列表、评论通知列表等UGC消息接口响应速度高达7s左右，经排查问题优化之后响应时间从7s优化至200ms以内，效果展示图如下：</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/21e92934251b02be0db37da32b9fb0d.png" alt="21e92934251b02be0db37da32b9fb0d"></p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/04311382a71018148382f9092cfdc5f.png" alt="04311382a71018148382f9092cfdc5f"></p><h3 id="问题分析及排查："><a href="#问题分析及排查：" class="headerlink" title="问题分析及排查："></a><strong>问题分析及排查：</strong></h3><p>1、索引问题？</p><p>刚开始以为是数据量太大且没有添加索引导致查询速度很慢从而导致接口反映速度很慢，但是一看数据量也不是很大，而且也有通过添加索引（是通过receiverBid（接受者的主键id）创建）的手段，并且通过<code>explain</code>语句分析我所写的语句走了索引，因此排除索引问题。</p><p>2、业务逻辑代码问题？</p><p>后面去查看业务代码、发现业务代码中除了分页查询UGC消息列表、还有一个同步的修改UGC消息读取状态的操作，也就是当用户拉取了UGC消息之后，将未读的记录转变成已读状态，一看到这里发现是两个同步操作，就赶紧通过<strong>打日志的方式</strong>判断查询操作和修改操作所耗时间，来进一步确定究竟是哪里出了问题，查看日志发现真的是因为修改操作耗时太多（为什么MySQL写操作比读操作慢？）导致的，那既然这样，我当时就想到了两个思路，1、通过一个事务来进行批量的修改操作，不过还是采取同步，但是我感觉这样如果批量同步修改的话，如果修改的数据太多，可能效率没太大提升，于是第二个想法就是在批量操作的基础上采用异步的方式，让这个修改操作打入kafka中异步化，进一步提高接口响应速率。</p><p>3、如果异步修改操作失败怎么办？根据什么判断失败？</p><p>可以根据Mybatis的Example类update方法返回的int值进行判断，如果大于0说明操作成功如果小于0则采取重试机制，重新打入kafka进行重新消费。</p><h3 id="开发思路："><a href="#开发思路：" class="headerlink" title="开发思路："></a>开发思路：</h3><p>1、根据前端穿过来的参数进行查询UGC消息列表操作，并筛选出status字段是UNREAD状态的记录传给kafka生产者的业务逻辑方法。</p><p>2、编写kafka生产者将修改操作的消息写入kafka，并编写消费者对这个消息进行消费。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;业务场景：&quot;&gt;&lt;a href=&quot;#业务场景：&quot; class=&quot;headerlink&quot; title=&quot;业务场景：&quot;&gt;&lt;/a&gt;&lt;strong&gt;业务场景：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;小程序端消息通知tab页中点赞通知列表、新粉丝通知列表、评论通知列表等UGC消息接</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>微布开发-将说说记录的图片url单独提出来用一个表存储的设计</title>
    <link href="http://xiaobazeo.github.io/2023/08/07/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%B0%86%E8%AF%B4%E8%AF%B4%E8%AE%B0%E5%BD%95%E7%9A%84%E5%9B%BE%E7%89%87url%E5%8D%95%E7%8B%AC%E6%8F%90%E5%87%BA%E6%9D%A5%E7%94%A8%E4%B8%80%E4%B8%AA%E8%A1%A8%E5%AD%98%E5%82%A8/"/>
    <id>http://xiaobazeo.github.io/2023/08/07/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%B0%86%E8%AF%B4%E8%AF%B4%E8%AE%B0%E5%BD%95%E7%9A%84%E5%9B%BE%E7%89%87url%E5%8D%95%E7%8B%AC%E6%8F%90%E5%87%BA%E6%9D%A5%E7%94%A8%E4%B8%80%E4%B8%AA%E8%A1%A8%E5%AD%98%E5%82%A8/</id>
    <published>2023-08-06T16:52:22.000Z</published>
    <updated>2023-08-07T10:15:28.303Z</updated>
    
    <content type="html"><![CDATA[<p>这样的目的是为了后续方便说说附带的图片进行修改以及调用三方接口校验图片是否违规。</p><p><strong>大概表设计如下：</strong></p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/622ed5483de15a276879cab129b21cb.png" alt="622ed5483de15a276879cab129b21cb"></p><p><strong>怎么转移说说表的pics字段的<strong><strong>url</strong></strong>到新的y_talk_images字段呢？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> y_talk_images (talk_bid, images_url, user_bid, trace_id, is_valid, is_delete, create_time)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    bid,</span><br><span class="line">    SUBSTRING_INDEX(SUBSTRING_INDEX(pics, <span class="string">&#x27;,&#x27;</span>, numbers.n), <span class="string">&#x27;,&#x27;</span>, <span class="number">-1</span>) <span class="keyword">AS</span> images_url,</span><br><span class="line">    y_talk.user_bid,</span><br><span class="line">    <span class="keyword">NULL</span> <span class="keyword">AS</span> trace_id,</span><br><span class="line">    <span class="number">1</span> <span class="keyword">AS</span> is_valid,</span><br><span class="line">    <span class="number">0</span> <span class="keyword">AS</span> is_delete,</span><br><span class="line">    y_talk.create_time <span class="comment">-- 使用此图片对应的说说创建时间作为创建时间</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="number">1</span> n <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">2</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">3</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">4</span></span><br><span class="line">     <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">5</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">6</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">7</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">8</span></span><br><span class="line">     <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">9</span>) numbers</span><br><span class="line"><span class="keyword">JOIN</span> y_talk <span class="keyword">ON</span> <span class="keyword">CHAR_LENGTH</span>(pics) <span class="operator">-</span> <span class="keyword">CHAR_LENGTH</span>(REPLACE(pics, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) <span class="operator">&gt;=</span> numbers.n <span class="operator">-</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    pics <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> pics <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>创建y_talk_images表的<strong><strong>SQL</strong></strong>语句：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> y_talk_images (</span><br><span class="line">id <span class="type">INT</span> ( <span class="number">11</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">image_bid <span class="type">VARCHAR</span> ( <span class="number">255</span> ) COMMENT <span class="string">&#x27;图片的主键id&#x27;</span>,</span><br><span class="line">talk_bid <span class="type">VARCHAR</span> ( <span class="number">255</span> ) COMMENT <span class="string">&#x27;此图片对应的说说的主键id&#x27;</span>,</span><br><span class="line">images_url <span class="type">VARCHAR</span> ( <span class="number">1024</span> ) COMMENT <span class="string">&#x27;图片的url&#x27;</span>,</span><br><span class="line">user_bid <span class="type">VARCHAR</span> ( <span class="number">255</span> ) COMMENT <span class="string">&#x27;发布者的主键id&#x27;</span>,</span><br><span class="line">open_id <span class="type">VARCHAR</span> ( <span class="number">255</span> ) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;微信id&#x27;</span>,</span><br><span class="line">trace_id <span class="type">VARCHAR</span> ( <span class="number">50</span> ) COMMENT <span class="string">&#x27;每张照片微信接口校验时返回的任务id&#x27;</span>,</span><br><span class="line">is_valid <span class="type">INT</span> ( <span class="number">1</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;是否通过校验，0待审核，1审核通过，2审核不通过&#x27;</span>,</span><br><span class="line">is_delete <span class="type">INT</span> ( <span class="number">1</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;图片url是否被软删除&#x27;</span>,</span><br><span class="line">create_time datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY ( `id` ) <span class="keyword">USING</span> BTREE </span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这样的目的是为了后续方便说说附带的图片进行修改以及调用三方接口校验图片是否违规。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大概表设计如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pengzihao166.oss-cn-beijing.aliyuncs.c</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>微布开发-上传多张图片控制上传顺序</title>
    <link href="http://xiaobazeo.github.io/2023/08/04/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%B8%8A%E4%BC%A0%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%BC%A0%E9%A1%BA%E5%BA%8F/"/>
    <id>http://xiaobazeo.github.io/2023/08/04/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%B8%8A%E4%BC%A0%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%BC%A0%E9%A1%BA%E5%BA%8F/</id>
    <published>2023-08-04T07:58:14.000Z</published>
    <updated>2023-08-04T07:58:34.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开发思路："><a href="#开发思路：" class="headerlink" title="开发思路："></a>开发思路：</h3><p>串行上传：在前端逐个上传图片，并等待上一个图片上传成功后再上传下一个图片，以保持上传顺序。</p><blockquote><p>刚开始开发是通过一个for循环依次上传，没有考虑到可能因为图片大小、网络等原因导致后端返回的url顺序不一致，可以理解成多并发上传的时候而导致的顺序问题</p></blockquote><h3 id="代码大致实现："><a href="#代码大致实现：" class="headerlink" title="代码大致实现："></a>代码大致实现：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">uploadAllPics</span>(<span class="params">selectedImages, index</span>) &#123;</span><br><span class="line"><span class="comment">//fileListPicStorage 和fileList 都是用于展示组件的时候用的，主要就是存储上传之后的图片url</span></span><br><span class="line">  <span class="keyword">const</span> &#123; fileListPicStorage = [] &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="keyword">const</span> &#123; fileList = [] &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= selectedImages.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 所有图片上传完成</span></span><br><span class="line">      <span class="title function_">resolve</span>()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(selectedImages)</span><br><span class="line">    <span class="keyword">const</span> image = selectedImages[index]</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(image)</span><br><span class="line">    wx.<span class="title function_">uploadFile</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: app.<span class="property">globalData</span>.<span class="property">url</span> + app.<span class="property">globalData</span>.<span class="property">apiVersion</span> + <span class="string">&#x27;/upload&#x27;</span>, <span class="comment">// 替换成后端上传接口的URL</span></span><br><span class="line">      <span class="attr">filePath</span>: image.<span class="property">url</span>, <span class="comment">// 图片文件的本地路径</span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;file&#x27;</span>, <span class="comment">// 后端接收图片的字段名</span></span><br><span class="line">      <span class="attr">header</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span>,</span><br><span class="line">        <span class="attr">token</span>: wx.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;token&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 图片上传成功后的处理</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;图片上传成功&#x27;</span>, res)</span><br><span class="line">        <span class="keyword">let</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(res.<span class="property">data</span>)</span><br><span class="line">        fileList.<span class="title function_">push</span>(data.<span class="property">data</span>.<span class="property">result</span>)</span><br><span class="line">        fileListPicStorage.<span class="title function_">push</span>(&#123;</span><br><span class="line">          <span class="attr">url</span>:</span><br><span class="line">            <span class="string">&#x27;******&#x27;</span> +<span class="comment">//****代表图片url的前半部分，因为后端返回的都是后半部分url，需要前端自己补上前半部分的url</span></span><br><span class="line">            data.<span class="property">data</span>.<span class="property">result</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; fileList, fileListPicStorage &#125;)</span><br><span class="line">        <span class="comment">// 继续上传下一张图片</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">uploadAllPics</span>(selectedImages, index + <span class="number">1</span>)</span><br><span class="line">          .<span class="title function_">then</span>(resolve)</span><br><span class="line">          .<span class="title function_">catch</span>(reject)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">fail</span>: <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理上传失败情况</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;图片上传失败&#x27;</span>, error)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续上传下一张图片</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">uploadAllPics</span>(selectedImages, index + <span class="number">1</span>)</span><br><span class="line">          .<span class="title function_">then</span>(resolve)</span><br><span class="line">          .<span class="title function_">catch</span>(reject)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//选择照片就上传9张照片</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">afterRead</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  app.<span class="title function_">showLoading</span>(<span class="string">&#x27;图片上传中&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">//获取照片本地位置的文件数组</span></span><br><span class="line">  <span class="comment">//console.log(event)</span></span><br><span class="line">  <span class="keyword">const</span> &#123; file &#125; = event.<span class="property">detail</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(file)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//选择完并点击确认之后开始上传图片</span></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadAllPics</span>(file, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有图片上传完成&#x27;</span>)</span><br><span class="line">    wx.<span class="title function_">hideLoading</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;图片上传失败&#x27;</span>, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;开发思路：&quot;&gt;&lt;a href=&quot;#开发思路：&quot; class=&quot;headerlink&quot; title=&quot;开发思路：&quot;&gt;&lt;/a&gt;开发思路：&lt;/h3&gt;&lt;p&gt;串行上传：在前端逐个上传图片，并等待上一个图片上传成功后再上传下一个图片，以保持上传顺序。&lt;/p&gt;
&lt;blockqu</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>面经-北森后端开发实习一面(线程安全和锁未完成)</title>
    <link href="http://xiaobazeo.github.io/2023/08/03/%E9%9D%A2%E7%BB%8F-%E5%8C%97%E6%A3%AE%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/"/>
    <id>http://xiaobazeo.github.io/2023/08/03/%E9%9D%A2%E7%BB%8F-%E5%8C%97%E6%A3%AE%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/</id>
    <published>2023-08-02T17:05:15.000Z</published>
    <updated>2023-08-09T04:52:57.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么离开了法大大实习？"><a href="#为什么离开了法大大实习？" class="headerlink" title="为什么离开了法大大实习？"></a>为什么离开了法大大实习？</h3><p>阿巴阿巴阿巴。。。。。</p><h3 id="为什么当时要用kafka进行UGC消息推送？业务场景是什么？"><a href="#为什么当时要用kafka进行UGC消息推送？业务场景是什么？" class="headerlink" title="为什么当时要用kafka进行UGC消息推送？业务场景是什么？"></a>为什么当时要用kafka进行UGC消息推送？业务场景是什么？</h3><p><strong>原因：</strong></p><ol><li>kakfa是一个高吞吐、低延迟的消息队列，UGC消息需要实时推送给其他用户，比如评论、点赞等，因此kafka可以确保消息被快速处理，从而提供更好的实时性和用户体验。</li><li>因为kafka 的可靠性比较高、消息会被持久化在磁盘上，确保消息不会丢失。</li><li>因为kafka可以支持多个消费组和分区，UGC在高并发的情况下需要处理大量的消息，而kafka可以轻松应对高负载和大规模的UGC</li><li>解耦异步，主要是因为异步的特性，不会因为同步处理的方式导致主线程阻塞，导致性能下降。使用消息队列，可以将这些操作封装成消息，放入消息队列中，异步处理这些操作，不影响主线程的执行，提高系统性能和响应速度。</li></ol><h3 id="kafka的生产和消费逻辑？"><a href="#kafka的生产和消费逻辑？" class="headerlink" title="kafka的生产和消费逻辑？"></a>kafka的生产和消费逻辑？</h3><p>生产实现逻辑：</p><p>1、连接到kafka集群，创建一个producer</p><p>2、生产者通过producer对象将消息发送到指定的topic。消息可以包含键和值，键可以帮助消息路由到特定的分区，如果没有特定的key就会通过自带的负载均衡机制选择一个分区。</p><p>3、通过key实现分区，指定了键的话将使用哈希函数映射到对应的分区，保证相同键的消息将始终被写入相同的分区，从而也可以保持消息的顺序。</p><p>4、生产者发送消息也会把消息持久化到磁盘，即使消息被消费，他也会根据kafka的配置的保留时间内保留在磁盘中。</p><p>消费实现逻辑：</p><p>1、消费者连接到kafka集群，创建一个consumer对象，并订阅一个或者多个主题</p><p>2、消费者使用consumer从指定的主题中拉取消息，其中消费者可以选择从分区的起始位置开始消费或者从上次消费的偏移量继续消费。</p><p>3、进行消息分配的时候，由于每个topic可能有多个partition，多个消费者可以同时消费同一个topic不同的partition，实现负载均衡和并行处理。（这时候可能会有一个问题，一个消费者组可以消费同一个分区吗？为什么每个分区只能被消费者组中的一个消费者消费？一个消费组可以同时消费不同的分区吗？）</p><h3 id="当时开发的过程中，kafka采用的路由分区策略是什么？"><a href="#当时开发的过程中，kafka采用的路由分区策略是什么？" class="headerlink" title="当时开发的过程中，kafka采用的路由分区策略是什么？"></a>当时开发的过程中，kafka采用的路由分区策略是什么？</h3><p>使用的默认的分区策略</p><p>就是会使用消息的key进行哈希，然后根据哈希值对分区总数取模得到一个分区号，将消息路由到对应的分区。这样就可以保证具有相同key的消息被写入同一个分区，保证消息有序。</p><h3 id="kafka如何保证顺序消费？"><a href="#kafka如何保证顺序消费？" class="headerlink" title="kafka如何保证顺序消费？"></a>kafka如何保证顺序消费？</h3><p>保证相关消息都发送到同一个分区这样就可以保证有序了，即通过一个partition消费对应的消息，因为生产者发送消息的时候，消息会逐一添加到该partition的日志中，并会分配一个唯一的offset，以保证从此offset开始进行消息的消费，从而保证消息顺序的有序性。</p><h3 id="如果kafka消息阻塞的话怎么处理？"><a href="#如果kafka消息阻塞的话怎么处理？" class="headerlink" title="如果kafka消息阻塞的话怎么处理？"></a>如果kafka消息阻塞的话怎么处理？</h3><p><strong>生产者角度：</strong></p><p>可能是因为生产者的生产速率太快导致，超过了消费者的消费能力，可以通过控制生产者的生产速率来适配消费者的处理速率</p><p><strong>消费者角度：</strong></p><p>可以创建多个消费者组或消费者实例，对不同的topic下不同的partition进行消费，但是最好是一个partition只被一个消费者消费，但一个消费者可以消费多个partition。</p><p><strong>硬件存储问题：</strong></p><p>由于存储空间满了，导致消息无法写入，因此消费者也无法进行消费，清空一定的磁盘空间即可。</p><h3 id="kafka是怎么保证主从副本的数据一致性？"><a href="#kafka是怎么保证主从副本的数据一致性？" class="headerlink" title="kafka是怎么保证主从副本的数据一致性？"></a>kafka是怎么保证主从副本的数据一致性？</h3><p>1、生产者向kafka的主副本发送消息，主副本会将消息追加到日志里面，进行持久化操作，并将消息分发给从副本。</p><p>2、从副本会周期性从主副本拉取数据保存到自己的本地log以保证同步。</p><p>3、ISR机制（最重要的一点）：Kafka会维护一个ISR的集合，它保存了相对主副本实时同步的从副本，如果某个从副本没有跟上主副本的进度，就会被移出ISR机制，直到它后面又跟上主副本的进度之后才会回到ISR集合中。</p><p>4、当所有ISR的从副本都确认收到了消息，这时候主副本就会把消息标记为已提交，意味着消息写入了足够多的副本中，确保数据的可靠性。</p><h3 id="如果主副本没了、这时候会怎么选择从副本？"><a href="#如果主副本没了、这时候会怎么选择从副本？" class="headerlink" title="如果主副本没了、这时候会怎么选择从副本？"></a>如果主副本没了、这时候会怎么选择从副本？</h3><p>会从ISR中同步的从副本选择作为主副本，然后此时被选举成为主副本的副本就会同步消息到其他的从副本中，来保证数据同步和备份。</p><h3 id="消息丢失的场景有哪些？以及怎么去解决这个问题？"><a href="#消息丢失的场景有哪些？以及怎么去解决这个问题？" class="headerlink" title="消息丢失的场景有哪些？以及怎么去解决这个问题？"></a>消息丢失的场景有哪些？以及怎么去解决这个问题？</h3><ul><li>生产者丢失消息<ul><li>生产者使用producer.send方法的时候，因为这个方法是异步的，会立即返回，如果此时出现了网络波动就会出现消息丢失的情况，导致Broker并没有接收到生产者发过来的消息</li></ul></li><li>Kafka Broker 服务端丢失消息<ul><li>如果因为leader broker宕机了触发选举过程，集群选举了一个落后的leader之后就会出现消息丢失的情况。</li><li>由于broker持久化消息需要先通过写入页缓存，再从页缓存写入磁盘，即通过异步批量刷盘的方式写入磁盘，也就是说需要消息达到一定的量和时间间隔才会去刷盘，具体的刷盘操作一般是由操作系统调度，如果刷盘之前导致broker宕机了也会出现消息丢失的情况。</li></ul></li><li>消费者丢失消息<ul><li>拉取消息之后，先提交offset，后处理消息：如果处理消息的时候突然宕机或者处理错误，但是此时offset又已经提交，等消费者重启恢复之后，就会从offset的下一个开始消费，之前未处理完的消息就会不再做处理，这时候对于消费者来说就是消息丢失了。</li><li>拉取消息之后，先处理消息，再提交offset：如果消息已经处理好了，但是要提交offset的时候突然宕机了，这时候重启服务，就会出现消费者会重新拉取上次消费了的消息进行再次消费的情况，此时会出现重复消费的情况或者直接丢失消息。</li></ul></li></ul><h3 id="有没有调用过一些三方接口？怎么实现的？"><a href="#有没有调用过一些三方接口？怎么实现的？" class="headerlink" title="有没有调用过一些三方接口？怎么实现的？"></a>有没有调用过一些三方接口？怎么实现的？</h3><p>1、文本审核内容审核</p><p>2、音视频内容审核</p><h3 id="对于微信接口的AccessToken怎么处理那个有效时间无效问题？"><a href="#对于微信接口的AccessToken怎么处理那个有效时间无效问题？" class="headerlink" title="对于微信接口的AccessToken怎么处理那个有效时间无效问题？"></a>对于微信接口的AccessToken怎么处理那个有效时间无效问题？</h3><p>定时刷新，将对应的AccessToken存在Redis里面，每次需要使用的时候，先从缓存中找，如果缓存中的东西失效了，那么就重新获取一次token进行令牌刷新并存在Redis里面，但是存取的时间是6000s，防止处理事务处理过程中出现失效的情况。</p><h3 id="如果服务器CPU或者内存满了怎么分析？"><a href="#如果服务器CPU或者内存满了怎么分析？" class="headerlink" title="如果服务器CPU或者内存满了怎么分析？"></a>如果服务器CPU或者内存满了怎么分析？</h3><p>1、使用监控工具确定是什么资源占用率高</p><p>2、使用系统工具查看占用cpu高的进程</p><p>3、查看日志找到异常或者错误信息，来定位具体是什么地方导致线程阻塞从而导致的cpu飙升，并及时优化代码。</p><h3 id="对于高并发问题，要怎么处理数据的一致性问题以及保证线程安全？"><a href="#对于高并发问题，要怎么处理数据的一致性问题以及保证线程安全？" class="headerlink" title="对于高并发问题，要怎么处理数据的一致性问题以及保证线程安全？"></a>对于高并发问题，要怎么处理数据的一致性问题以及保证线程安全？</h3><p><strong>解决方案：</strong></p><ul><li>使用并发容器，如ConcurrentHashMap，它是线程安全的数据结构，可用于高并发场景。</li><li>通过分布式锁的方式，保证数据一致性，确保在同一时间只有一个线程可以访问共享资源。</li><li>根据业务需求，设置合适的数据库隔离级别，如读未提交、读已提交、可重复读、串行化，以保证数据的一致性和隔离性。</li></ul><h3 id="常用的锁有哪些？"><a href="#常用的锁有哪些？" class="headerlink" title="常用的锁有哪些？"></a>常用的锁有哪些？</h3><h3 id="介绍一下互斥锁、自旋锁"><a href="#介绍一下互斥锁、自旋锁" class="headerlink" title="介绍一下互斥锁、自旋锁"></a>介绍一下互斥锁、自旋锁</h3><p>互斥锁：用于保护共享资源，同一时间只允许一个线程访问共享资源，其他线程需要等待锁的释放。</p><h3 id="Redis的Set扩容机制如何实现？"><a href="#Redis的Set扩容机制如何实现？" class="headerlink" title="Redis的Set扩容机制如何实现？"></a>Redis的Set扩容机制如何实现？</h3><p>1、当Set元素数量达到一定的阈值的时候，创建新的哈希表</p><p>2、Redis会逐一将原来哈希表的元素根据新的哈希映射函数分配到新的哈希表中</p><p>3、更新指针，这个指针指向的是存储哈希表的内存地址，以便在扩容过程中可以正确地切换到新的哈希表。</p><h3 id="介绍一下hashmap以及如何解决哈希冲突的？"><a href="#介绍一下hashmap以及如何解决哈希冲突的？" class="headerlink" title="介绍一下hashmap以及如何解决哈希冲突的？"></a>介绍一下hashmap以及如何解决哈希冲突的？</h3><p>问烂了、已经不想打字了，补充几个其他相关的题</p><h4 id="为什么hashmap要在红黑树节点小于等于6的时候转回链表？"><a href="#为什么hashmap要在红黑树节点小于等于6的时候转回链表？" class="headerlink" title="为什么hashmap要在红黑树节点小于等于6的时候转回链表？"></a>为什么hashmap要在红黑树节点小于等于6的时候转回链表？</h4><ul><li>最主要的原因是因为节点数小于等于6的时候，链表和红黑树查询平均时间复杂度几乎一样，都是O（n），在性能差异不大的情况下，红黑树的维护成本远远大于链表的维护成本。</li><li>根据概率论的泊松分布，造成哈希冲突导致桶的的链表长度等于6的概率很大，而查询的平均复杂度和红黑树一样，在同等效率下选择开销更小的链表结构。</li></ul><h4 id="为什么hashmap负载因子是0-75？"><a href="#为什么hashmap负载因子是0-75？" class="headerlink" title="为什么hashmap负载因子是0.75？"></a>为什么hashmap负载因子是0.75？</h4><p>1、避免频繁扩容带来的性能损失</p><p>2、提高空间利用率，负载因子 = 存储的元素数量 / 哈希表可存储元素的总数量</p><p>3、较小的负载因子能够减少哈希冲突，提高性能，这也是经验之谈。</p><h4 id="哈希扩容的时候，是根据什么来扩容的？"><a href="#哈希扩容的时候，是根据什么来扩容的？" class="headerlink" title="哈希扩容的时候，是根据什么来扩容的？"></a>哈希扩容的时候，是根据什么来扩容的？</h4><p>元素数量 / 哈希表的容量与负载因子进行比较，</p><h3 id="索引失效有哪些？"><a href="#索引失效有哪些？" class="headerlink" title="索引失效有哪些？"></a>索引失效有哪些？</h3><p>6种，左右模糊或左模糊，对索引使用函数，对索引隐式类型转换（查询的时候数据类型转换，实际上会用到函数CAST），对索引进行表达式计算(where id + 1 = 10不行)，联合索引非左匹配原则，where子句有OR</p><p>对索引使用函数，对索引隐式类型转换（查询的时候数据类型转换，实际上会用到函数CAST），对索引进行表达式计算(where id + 1 = 10不行)，这三种造成失效的原因就是索引存的是原始的值，而不是使用函数或者通过计算得到的新的值，如果建立对某个字段使用函数或者计算的索引来解决这个问题。例如建立索引<code>alter table t_user add key idx_name_length ((length(name)));</code></p><h3 id="介绍一些JWT，比较一下和Cookie-Session的区别？"><a href="#介绍一些JWT，比较一下和Cookie-Session的区别？" class="headerlink" title="介绍一些JWT，比较一下和Cookie-Session的区别？"></a>介绍一些JWT，比较一下和Cookie-Session的区别？</h3><p>阿巴阿巴阿巴。。。。。</p><h3 id="JWT是怎么解决防篡改问题的？"><a href="#JWT是怎么解决防篡改问题的？" class="headerlink" title="JWT是怎么解决防篡改问题的？"></a>JWT是怎么解决防篡改问题的？</h3><p>阿巴阿巴阿巴。。。。。</p><h3 id="介绍一下如何判断死亡对象的方法以及垃圾收集算法"><a href="#介绍一下如何判断死亡对象的方法以及垃圾收集算法" class="headerlink" title="介绍一下如何判断死亡对象的方法以及垃圾收集算法"></a>介绍一下如何判断死亡对象的方法以及垃圾收集算法</h3><p><strong>判断对象死亡的方法：</strong></p><ol><li>引用计数法：当被引用了就计数+1，引用失效就-1，当计数器的值==0就说明此对象已经死亡。</li><li>可达性分析算法：如果某个对象不能有一条路径到达GC ROOTS，如果没有的话，就说明这个对象已经死亡，有的话就说明，这个对象没有死亡。</li></ol><blockquote><p>这个时候实际上只能表示对象可以回收了，但是不一定代表着一定会回收，宣布一个对象死亡，要进行两次标记，可达性分析算法中不可达对象就会先第一次被标记并进行一次筛选，筛选条件就是此对象是否有必要执行finalize()，如果finalize()方法没有被覆盖，或者被虚拟栈调用过了，就会被认为没有必要被执行。被判定需要执行的对象就会被放入一个队列进行二次标记，除非这个对象跟引用链上的任何一个对象建立关联，否则就会被回收。</p></blockquote><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><blockquote><p><strong>简介</strong></p><ul><li>进程：计算机正在运行的一个程序实例，比如打开微信</li><li>线程：又称轻量级进程，多个线程可以在同一个进程中同时执行，并且共享进程的资源比如：内存空间、网络连接等，举例：你打开的微信就有一个线程专门用来拉取别人发你的最新的消息。</li></ul></blockquote><ol><li>一个进程可以产生多个线程，多个进程间共享堆和方法区，每个线程自己独立的程序计数器、虚拟机栈和本地方法栈。</li><li>进程线程最大的不同就是各进程是独立的，而线程不一定因为同一进程中的线程极有可能会相互影响。</li><li>线程执行开销小，不利于资源的管理和保护但是进程相反。</li></ol><h3 id="介绍一下协程（不会）"><a href="#介绍一下协程（不会）" class="headerlink" title="介绍一下协程（不会）"></a>介绍一下协程（不会）</h3><p>协程是相较于线程更加轻量级的一种执行单位，协程通常不会被内核调度所以协程切换不会涉及内核级的上下文切换，核心思想就是可以暂停和回复的执行单元，一个可以在某一个点挂起，然后执行权交给其他协程，等其他协程执行完毕之后可以恢复，从挂起的地方继续执行。</p><p>协程的并行数也受限于CPU的核心数，多个协程在同一线程中交替执行，充分利用了单线程的资源。但协程并发的时候可以通过调度器来控制哪个协程何时执行。</p><h3 id="平时怎么学习的？"><a href="#平时怎么学习的？" class="headerlink" title="平时怎么学习的？"></a>平时怎么学习的？</h3><p>阿巴阿巴阿巴阿巴阿巴阿巴。。。</p><h3 id="了不了解ElasticSearch？（并不了解）"><a href="#了不了解ElasticSearch？（并不了解）" class="headerlink" title="了不了解ElasticSearch？（并不了解）"></a>了不了解ElasticSearch？（并不了解）</h3><p>所以无解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么离开了法大大实习？&quot;&gt;&lt;a href=&quot;#为什么离开了法大大实习？&quot; class=&quot;headerlink&quot; title=&quot;为什么离开了法大大实习？&quot;&gt;&lt;/a&gt;为什么离开了法大大实习？&lt;/h3&gt;&lt;p&gt;阿巴阿巴阿巴。。。。。&lt;/p&gt;
&lt;h3 id=&quot;为什么当时要</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面经-七牛云测试开发实习一二面</title>
    <link href="http://xiaobazeo.github.io/2023/08/02/%E9%9D%A2%E7%BB%8F-%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%BA%8C%E9%9D%A2/"/>
    <id>http://xiaobazeo.github.io/2023/08/02/%E9%9D%A2%E7%BB%8F-%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%BA%8C%E9%9D%A2/</id>
    <published>2023-08-02T03:37:32.000Z</published>
    <updated>2023-08-02T03:48:32.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="微布校园的分工如何？"><a href="#微布校园的分工如何？" class="headerlink" title="微布校园的分工如何？"></a>微布校园的分工如何？</h3><h3 id="在开发过程中学到了什么？遇到了什么难的问题？"><a href="#在开发过程中学到了什么？遇到了什么难的问题？" class="headerlink" title="在开发过程中学到了什么？遇到了什么难的问题？"></a>在开发过程中学到了什么？遇到了什么难的问题？</h3><h3 id="如何解决缓存雪崩、缓存与数据库一致性问题？"><a href="#如何解决缓存雪崩、缓存与数据库一致性问题？" class="headerlink" title="如何解决缓存雪崩、缓存与数据库一致性问题？"></a>如何解决缓存雪崩、缓存与数据库一致性问题？</h3><h3 id="查询响应速度从超时响应加快到900ms-1s是如何实现的？"><a href="#查询响应速度从超时响应加快到900ms-1s是如何实现的？" class="headerlink" title="查询响应速度从超时响应加快到900ms~1s是如何实现的？"></a>查询响应速度从超时响应加快到900ms~1s是如何实现的？</h3><h3 id="讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）"><a href="#讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）" class="headerlink" title="讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）"></a>讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）</h3><h3 id="使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。"><a href="#使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。" class="headerlink" title="使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。"></a>使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。</h3><h3 id="Redis在哪一部分用的比较多？"><a href="#Redis在哪一部分用的比较多？" class="headerlink" title="Redis在哪一部分用的比较多？"></a>Redis在哪一部分用的比较多？</h3><h3 id="讲一下http的三次握手、四次挥手？"><a href="#讲一下http的三次握手、四次挥手？" class="headerlink" title="讲一下http的三次握手、四次挥手？"></a>讲一下http的三次握手、四次挥手？</h3><h3 id="为什么要进行四次挥手？"><a href="#为什么要进行四次挥手？" class="headerlink" title="为什么要进行四次挥手？"></a>为什么要进行四次挥手？</h3><h3 id="介绍一下udp和tcp之间的区别"><a href="#介绍一下udp和tcp之间的区别" class="headerlink" title="介绍一下udp和tcp之间的区别"></a>介绍一下udp和tcp之间的区别</h3><h3 id="什么时候用UDP？什么时候用TCP？"><a href="#什么时候用UDP？什么时候用TCP？" class="headerlink" title="什么时候用UDP？什么时候用TCP？"></a>什么时候用UDP？什么时候用TCP？</h3><h3 id="介绍一下对HTTP的理解"><a href="#介绍一下对HTTP的理解" class="headerlink" title="介绍一下对HTTP的理解"></a>介绍一下对HTTP的理解</h3><h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><h3 id="介绍一下token"><a href="#介绍一下token" class="headerlink" title="介绍一下token"></a>介绍一下token</h3><h3 id="讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？"><a href="#讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？" class="headerlink" title="讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？"></a>讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？</h3><h3 id="介绍一下Redis的数据类型和持久化"><a href="#介绍一下Redis的数据类型和持久化" class="headerlink" title="介绍一下Redis的数据类型和持久化"></a>介绍一下Redis的数据类型和持久化</h3><h3 id="如何通过Redis实现分布式锁？"><a href="#如何通过Redis实现分布式锁？" class="headerlink" title="如何通过Redis实现分布式锁？"></a>如何通过Redis实现分布式锁？</h3><h3 id="Redis的淘汰策略有哪些？"><a href="#Redis的淘汰策略有哪些？" class="headerlink" title="Redis的淘汰策略有哪些？"></a>Redis的淘汰策略有哪些？</h3><h3 id="介绍一下对多线程的理解"><a href="#介绍一下对多线程的理解" class="headerlink" title="介绍一下对多线程的理解"></a>介绍一下对多线程的理解</h3><h3 id="什么是线程池、为什么要使用线程池？"><a href="#什么是线程池、为什么要使用线程池？" class="headerlink" title="什么是线程池、为什么要使用线程池？"></a>什么是线程池、为什么要使用线程池？</h3><h3 id="Java的异常有哪些？如何捕获异常？"><a href="#Java的异常有哪些？如何捕获异常？" class="headerlink" title="Java的异常有哪些？如何捕获异常？"></a>Java的异常有哪些？如何捕获异常？</h3><h3 id="对文件的上传、下载分别有哪些测试功能点？"><a href="#对文件的上传、下载分别有哪些测试功能点？" class="headerlink" title="对文件的上传、下载分别有哪些测试功能点？"></a>对文件的上传、下载分别有哪些测试功能点？</h3><h3 id="算法题：把两个无序的数组合并成一个有序的数组"><a href="#算法题：把两个无序的数组合并成一个有序的数组" class="headerlink" title="算法题：把两个无序的数组合并成一个有序的数组"></a>算法题：把两个无序的数组合并成一个有序的数组</h3><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><h3 id="为什么要选择面试测试开发这个岗位？"><a href="#为什么要选择面试测试开发这个岗位？" class="headerlink" title="为什么要选择面试测试开发这个岗位？"></a>为什么要选择面试测试开发这个岗位？</h3><h3 id="你觉得测开需要学习些什么方面的东西？"><a href="#你觉得测开需要学习些什么方面的东西？" class="headerlink" title="你觉得测开需要学习些什么方面的东西？"></a>你觉得测开需要学习些什么方面的东西？</h3><h3 id="netty和直接裸写socket有什么区别？"><a href="#netty和直接裸写socket有什么区别？" class="headerlink" title="netty和直接裸写socket有什么区别？"></a>netty和直接裸写socket有什么区别？</h3><h3 id="什么是NIO？"><a href="#什么是NIO？" class="headerlink" title="什么是NIO？"></a>什么是NIO？</h3><h3 id="为什么IO多路复用比多线程更高效？"><a href="#为什么IO多路复用比多线程更高效？" class="headerlink" title="为什么IO多路复用比多线程更高效？"></a>为什么IO多路复用比多线程更高效？</h3><h3 id="Redis是单线程还是多线程的？为什么是单线程还能这么高效？"><a href="#Redis是单线程还是多线程的？为什么是单线程还能这么高效？" class="headerlink" title="Redis是单线程还是多线程的？为什么是单线程还能这么高效？"></a>Redis是单线程还是多线程的？为什么是单线程还能这么高效？</h3><h3 id="在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？"><a href="#在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？" class="headerlink" title="在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？"></a>在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？</h3><h3 id="使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）"><a href="#使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）" class="headerlink" title="使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）"></a>使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）</h3><h3 id="netty的广播怎么实现的？"><a href="#netty的广播怎么实现的？" class="headerlink" title="netty的广播怎么实现的？"></a>netty的广播怎么实现的？</h3><h3 id="如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？"><a href="#如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？" class="headerlink" title="如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？"></a>如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？</h3><h3 id="如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？"><a href="#如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？" class="headerlink" title="如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？"></a>如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？</h3><h3 id="介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？"><a href="#介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？" class="headerlink" title="介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？"></a>介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？</h3><h3 id="说几个Maven的常用命令"><a href="#说几个Maven的常用命令" class="headerlink" title="说几个Maven的常用命令"></a>说几个Maven的常用命令</h3><h3 id="常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）"><a href="#常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）" class="headerlink" title="常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）"></a>常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）</h3><h3 id="怎么实现多线程之间的同步操作？-主线程开启10个任务，-等这10个任务并发结束之后，再执行其他的任务应该怎么实现？"><a href="#怎么实现多线程之间的同步操作？-主线程开启10个任务，-等这10个任务并发结束之后，再执行其他的任务应该怎么实现？" class="headerlink" title="怎么实现多线程之间的同步操作？ 主线程开启10个任务， 等这10个任务并发结束之后，再执行其他的任务应该怎么实现？"></a>怎么实现多线程之间的同步操作？ 主线程开启10个任务， 等这10个任务并发结束之后，再执行其他的任务应该怎么实现？</h3><h3 id="Java的新特性（介绍的Java8的新特性）"><a href="#Java的新特性（介绍的Java8的新特性）" class="headerlink" title="Java的新特性（介绍的Java8的新特性）"></a>Java的新特性（介绍的Java8的新特性）</h3><h3 id="编码：实现a，b两个线程顺序交替执行"><a href="#编码：实现a，b两个线程顺序交替执行" class="headerlink" title="编码：实现a，b两个线程顺序交替执行"></a>编码：实现a，b两个线程顺序交替执行</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h2&gt;&lt;h3 id=&quot;微布校园的分工如何？&quot;&gt;&lt;a href=&quot;#微布校园的分工如何？&quot; class=&quot;headerlink&quot; title=&quot;微布校园的</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面经-万物心选php开发实习</title>
    <link href="http://xiaobazeo.github.io/2023/07/25/%E9%9D%A2%E7%BB%8F-%E4%B8%87%E7%89%A9%E5%BF%83%E9%80%89php%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/"/>
    <id>http://xiaobazeo.github.io/2023/07/25/%E9%9D%A2%E7%BB%8F-%E4%B8%87%E7%89%A9%E5%BF%83%E9%80%89php%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/</id>
    <published>2023-07-25T08:13:52.000Z</published>
    <updated>2023-07-31T05:33:35.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实习项目的监听字段是基于什么实现的？"><a href="#实习项目的监听字段是基于什么实现的？" class="headerlink" title="实习项目的监听字段是基于什么实现的？"></a>实习项目的监听字段是基于什么实现的？</h2><p>前端进行某个字段变更之后，后端提供接口，将修改后的数据打入消息队列，服务端作为消费者进行监听判断某个字段是否等于某个值然后进行对应的业务逻辑操作。</p><h2 id="通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）"><a href="#通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）" class="headerlink" title="通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）"></a>通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）</h2><p>通过业务id来保证，业务id作为锁的key，当消费信息的时候，把工单id作为key去申请锁，如果成功拿到了锁，说明此时不存在竞争关系，如果当前进程被阻塞了，说明有进程对该数据进行了消费。</p><p>不过后面发现如果有两个并发的线程的时候，被阻塞的业务后面拿到了还是可能会造成重复消费，于是又加了一层缓存，缓存已经消费了的业务id，用来表示是否被消费过，也就是保证业务的幂等性。</p><h2 id="当时为什么考虑到设置一个重试机制降低消费的失败率？"><a href="#当时为什么考虑到设置一个重试机制降低消费的失败率？" class="headerlink" title="当时为什么考虑到设置一个重试机制降低消费的失败率？"></a>当时为什么考虑到设置一个重试机制降低消费的失败率？</h2><p>当初实现合同是临时合同的时候，要删除销售合同的主从表，因为当时是两个表，涉及到了一个同步操作，即先删除主表之后再删除从表的操作，要保证事务的一致性和原子性，可能两个删除操作会有一个或者两个操作均失败的情况，就设计了这个重试机制，如果其中一个操作失败就进行事务回滚，然后将两个同步操作打入重试的队列中进行一次重试。</p><h2 id="有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）"><a href="#有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）" class="headerlink" title="有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）"></a>有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）</h2><p><strong>避免消费失败的措施：</strong></p><ol><li>失败重试机制</li><li>死信队列</li><li>消息超时机制：避免因为一个消息阻塞导致后续的所有消息超时</li><li>负载均衡：如果是集群分布式服务，可以通过负载均衡算法分配给多个消费者。</li><li>消息确认机制：当消费者消费成功之后，发送确认信号给消息队列，表示消息处理成功，如果消费者在一定时间内没有返回确认信号，消息队列就重新分发消息给其他的消费者进行消费。</li></ol><p><strong>避免重复消费的措施：</strong></p><ol><li>实现幂等性：即相同的多个操作所产生的影响与仅执行一次的操作所产生的影响相同。确保相同的消息被多次发送之后，只会被处理一次。</li><li>消息确认机制：消息队列消费者消费之后会给生产者发送一个确认信号告诉已经消费信息成功，如果在一定时间内没有发送确认消息，消息队列就会认为此消息未被成功消费，会将该消息重新发送给消费者。</li><li>消费者限流：在高并发的场景中，为了消费者过度消费，就会在一定时间内只允许消费者消费一定数量的消息，以避免被过度消费而导致的重复消费。</li></ol><h2 id="如何解决数据库offset超过10000时失效的问题？"><a href="#如何解决数据库offset超过10000时失效的问题？" class="headerlink" title="如何解决数据库offset超过10000时失效的问题？"></a>如何解决数据库offset超过10000时失效的问题？</h2><p>通过分页查询的方式，偏移量超过一万的情况下，我们可以通过limit的分页查询机制，一直查到第10001条数据的主键id，然后从此id开始进一步根据条件查询需要获取的数据。</p><h2 id="为什么offset超过10000会查询不到数据呢？"><a href="#为什么offset超过10000会查询不到数据呢？" class="headerlink" title="为什么offset超过10000会查询不到数据呢？"></a>为什么offset超过10000会查询不到数据呢？</h2><p>OFFSET工作原理是通过全表扫描，先查询所有匹配的记录，然后再跳过指定数量的记录，如果偏移量特别大，数据库可能会需要一次性加载大量数据到内存中，会导致内存不足的问题。</p><h2 id="实习时候的成长经历"><a href="#实习时候的成长经历" class="headerlink" title="实习时候的成长经历"></a>实习时候的成长经历</h2><p>1、有一次出现过一次消息队列重复消费的情况，当时情况是两个不同的测试环境，做相同业务消费时消费了两次，然后查代码一直也没有查到原因，就去看配置环境，原来是当时运维那边部署消息队列，两个环境都部署到了一个队列上面，没有做环境隔离。。。</p><p>2、在</p><h2 id="JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？"><a href="#JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？" class="headerlink" title="JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？"></a>JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？</h2><p><strong>业务及校验流程：</strong></p><p>用户通过学号+教务密码向Java后端发起请求，然后Java后端调用Python的服务进行校验账号密码是否正确，如果正确就会向前端返回一个token，客户端将Token保存在本地缓存之中，方便以后在一些业务操作的时候，都会从本地缓存中获取Token并将其放在Http请求的Header中发送请求，服务端获取到请求之后从Http的header里面获取token，并通过服务端保存的密匙进行重新生成新的signature和客户端发过来的token的signature进行比较确认token是否有效，再从payload部分获取相关用户信息进行进一步身份校验。</p><p>每次服务端在校验token有效的时候会根据payload的签发token时间+超时时间，当离过期时间只有1天的时候，就会重新签发一个Token给前端。</p><p><strong>Token存放位置：</strong></p><p>HTTP的Header部分。</p><h2 id="Java为什么需要垃圾回收机制呢？"><a href="#Java为什么需要垃圾回收机制呢？" class="headerlink" title="Java为什么需要垃圾回收机制呢？"></a>Java为什么需要垃圾回收机制呢？</h2><p>主要是为了管理内存，自动释放不再使用的对象，以避免内存泄漏和提高程序性能。</p><h2 id="什么情况下会出现资源的浪费（内存泄漏）？"><a href="#什么情况下会出现资源的浪费（内存泄漏）？" class="headerlink" title="什么情况下会出现资源的浪费（内存泄漏）？"></a>什么情况下会出现资源的浪费（内存泄漏）？</h2><p>1、长期存活的对象占用过多内存，就是长生命周期对象持有短生命周期的引用导致部分短生命周期的对象一直没有被释放，进而积累过多的情况下出现内存泄漏的问题。</p><p>2、各种连接：比如数据库连接、网络连接，对于这些连接操作都需要在不使用的时候进行关闭操作，垃圾回收期才会进行回收。</p><p>3、变量作用域不合理：比如要对一个msg进行保存操作，但是msg定义成一个成员变量，然后通过receiveMsg()方法进行相关保存业务逻辑操作，但是因为msg是成员变量，生命周期和类的生命周期一样，所以导致存储操作完成之后，msg还没有被回收释放，可能就会导致内存泄漏。</p><h2 id="创建了一个String类型的数据什么时候会被垃圾回收机制回收？"><a href="#创建了一个String类型的数据什么时候会被垃圾回收机制回收？" class="headerlink" title="创建了一个String类型的数据什么时候会被垃圾回收机制回收？"></a>创建了一个String类型的数据什么时候会被垃圾回收机制回收？</h2><p>1、对象不再引用。</p><p>2、对象引用被显式设置为null。</p><p>3、对象的引用超出作用域：在一个方法内部创建的，那么在这个方法执行完之后就会被收回。</p><p>3、垃圾回收机制触发：Java虚拟机判断系统内存不足就会触发此机制，尝试回收不再被使用的对象。</p><h2 id="了解哪些垃圾回收算法并介绍一下"><a href="#了解哪些垃圾回收算法并介绍一下" class="headerlink" title="了解哪些垃圾回收算法并介绍一下"></a>了解哪些垃圾回收算法并介绍一下</h2><p><strong>标记-清除算法：</strong></p><p>首先标记处所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p><p>导致的问题：</p><p>1、标记清除的过程效率都不高</p><p>2、标记清除后会产生大量不连续的内存碎片。</p><p><strong>复制算法：</strong></p><p>将内存空间分为两半，每次使用其中的一块，当这块使用完之后，将这块还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</p><p>导致的问题：</p><p>1、可用内存变小。</p><p>2、不适合老年代，如果存活对象数量大，复制性能会比较差。</p><p><strong>标记-整理算法：</strong></p><p>标记不需要回收的对象，然后将没有标记的对象统一向一端移动，然后直接清理掉端边界以外的内存。</p><p>导致问题：</p><p>只适合老年代回收频率较低的场景</p><p><strong>分代收集算法：</strong></p><p>根据不同对象的生命周期将内存分为几块。一般将Java堆分为新生代和老年代，可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如：新生代中，每次都会有大量对象死去，可以选择<strong>复制算法</strong>，只需要付出少量对象的复制成本就可以完成垃圾收集。而对于老年代生命周期较长，存活率较高，可以选择<strong>标记-清除算法</strong>或者<strong>标记-整理算法</strong>实现。</p><h2 id="垃圾回收机制为什么要分新生代和老年代呢？"><a href="#垃圾回收机制为什么要分新生代和老年代呢？" class="headerlink" title="垃圾回收机制为什么要分新生代和老年代呢？"></a>垃圾回收机制为什么要分新生代和老年代呢？</h2><p>根据不同对象的生命周期将内存分为几块。一般将Java堆分为新生代和老年代，可以根据各个年代的特点选择合适的垃圾收集算法。</p><h2 id="为什么新生代和老年代不放在一起进行回收呢？"><a href="#为什么新生代和老年代不放在一起进行回收呢？" class="headerlink" title="为什么新生代和老年代不放在一起进行回收呢？"></a>为什么新生代和老年代不放在一起进行回收呢？</h2><p>1、不同对象生命周期：可以根据不同的生命周期对象采用不同的回收策略</p><p>2、不同回收算法：一般新生代会采用复制算法清除，因为可以标记较少的对象复制到另一块内存上面去，然后一次性清理整个区域，效率较高，对于老年代生命周期长且存活率高，就可以采用标记-整理或者标记-删除的办法，将不需要回收的对象进行标记，然后直接删除没有标记的即可。</p><p>3、避免频繁回收老年代：混在一起会导致老年代频繁的回收，降低系统的性能。</p><h2 id="数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？"><a href="#数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？" class="headerlink" title="数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？"></a>数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？</h2><ul><li>数组访问效率比链表高，因为链表通常是动态扩容的，每次的动态调整都会带来一定的开销以及维护指针等，所以访问效率较低。</li><li>链表能灵活进行动态扩容或缩容，但是数组一旦确定大小就不能进行扩容和缩容操作了。</li><li>链表有丰富的api可以直接动态进行增删查改，而数组是一个固定长度的数组，只能按下标访问其中的元素，不具备动态增删的能力。</li><li>链表只能存储对象（对于基本数据类型可以采用包装类进行存储），但是数组既可以存储对象也可以存储基本数据类型。</li><li>链表可以通过泛型保证类型安全，但是数组不可以。</li></ul><h2 id="有没有一个数据结构可以访问元素时间是O-1-，又可以灵活的调整他的容量大小？"><a href="#有没有一个数据结构可以访问元素时间是O-1-，又可以灵活的调整他的容量大小？" class="headerlink" title="有没有一个数据结构可以访问元素时间是O(1)，又可以灵活的调整他的容量大小？"></a>有没有一个数据结构可以访问元素时间是O(1)，又可以灵活的调整他的容量大小？</h2><p>哈希表可以将key映射到存储位置来实现快速访问，使用哈希函数将键转换成索引，然后将值存在对应索引的位置，在理想情况下，能够在O（1）情况下根据键找到对应的值。哈希表具有灵活的扩容机制，当哈希表中元素过多的时候就会自动扩容，重新分配更大的空间。</p><h2 id="HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）"><a href="#HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）" class="headerlink" title="HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）"></a>HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）</h2><p>hashmap是基于数组+链表/红黑树的数据结构来具体实现的，首先hashmap产生哈希冲突的时候会判断链表的长度是否大于8，如果大于的话就会转换成红黑树（此时进入红黑树转换的函数的时候，会判断数组的长度是否大于64，如果数组长度小于64，就不会转换成红黑树，而是选择扩容的机制解决哈希冲突）</p><p>选择红黑树的原因：</p><p>1、如果是<strong>二叉查询树</strong>比较极端的情况下，当子节点都比父节点大或者小的时候，二叉查找树又会退化成链表，此时时间复杂度又是O(n)。</p><p>2、如果是<strong>平衡二叉树（AVL）</strong>，因为它每个节点的左子树和右子树的高度差至多等于1，如果大于1了就会通过左旋或者右旋的方式，使其复杂度一直维持在O(logN)，但是因为这个左旋和右旋的原因，导致插入数据的时候需要消耗大量的时间。</p><h2 id="场景题：现在有路由器a-b-c-d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？"><a href="#场景题：现在有路由器a-b-c-d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？" class="headerlink" title="场景题：现在有路由器a,b,c,d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？"></a>场景题：现在有路由器a,b,c,d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？</h2><p>在IP层遇到循环路由的情况下，数据包会被丢弃。IP协议是一种无连接的、不可靠的协议，它不会主动检查循环路由或处理数据包的循环传递。</p><p>为了防止数据包在网络中无限循环，网络管理员通常会配置路由器使用一些防循环机制，比如距离矢量路由协议中的Split Horizon技术，或链路状态路由协议中的Reverse Path Forwarding（RPF）检查。这些机制有助于检测和避免数据包在网络中形成循环路径。</p><p>但是，即使配置了防循环机制，由于网络的复杂性和问题可能的多样性，有时候循环路由问题仍然可能发生。在这种情况下，IP层不会继续无限传递数据包，而是丢弃它，从而避免对网络产生更严重的影响。丢弃数据包是为了确保网络中的数据传输是可靠和有效的，即使牺牲了某些数据包。</p><h2 id="Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？"><a href="#Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？" class="headerlink" title="Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？"></a>Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？</h2><p>stat的基本单位是块，也就是byte。转换成可识别的大小的话，通过1 kb = 1024byte实现。</p><p>可以通过ls -lh</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实习项目的监听字段是基于什么实现的？&quot;&gt;&lt;a href=&quot;#实习项目的监听字段是基于什么实现的？&quot; class=&quot;headerlink&quot; title=&quot;实习项目的监听字段是基于什么实现的？&quot;&gt;&lt;/a&gt;实习项目的监听字段是基于什么实现的？&lt;/h2&gt;&lt;p&gt;前端进行某个</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>快手测开 2023 - 7 - 11</title>
    <link href="http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E5%BF%AB%E6%89%8B%E6%B5%8B%E5%BC%80%E5%AE%9E%E4%B9%A0/"/>
    <id>http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E5%BF%AB%E6%89%8B%E6%B5%8B%E5%BC%80%E5%AE%9E%E4%B9%A0/</id>
    <published>2023-07-23T06:50:54.000Z</published>
    <updated>2023-07-31T05:33:15.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍一下二手市场整体的架构，数据流的实现？"><a href="#简单介绍一下二手市场整体的架构，数据流的实现？" class="headerlink" title="简单介绍一下二手市场整体的架构，数据流的实现？"></a>简单介绍一下二手市场整体的架构，数据流的实现？</h2><p><strong>整体架构：</strong></p><ol><li>持久层和缓存的选型<ol><li>MySQL作为持久层：<ol><li>支持复杂条件数据查询：在二手市场中，用户会根据自身需求筛选不同的条件进行各种复杂的查询，例如按照不同条件筛选商品等，MySQL提供丰富的查询语言和索引支持，能够高效查询相关数据。</li><li>结构化数据存储：二手市场涉及大量的结构化数据，例如：用户信息，商品信息等。而MySQL是关系型数据库，适合存储和管理结构化数据，提供事务支持，保证数据的一致性和完整性。</li></ol></li><li>Redis作为缓存：<ol><li>二手市场是多读少写的场景，用户会频繁的浏览商品，但是对商品的修改变更有限，所以可以将物品信息添加至Redis中有效减轻MySQL的读取压力，提高系统的响应和性能。</li></ol></li></ol></li><li>服务的拆分方式</li></ol><p>暂时因为是单体架构，没有钱去购买太多的服务器，所以服务暂时没有进行具体的划分，如果要进行划分的话我觉得可以划分成以下几种服务：</p><ol><li><p>用户服务：主要是对用户的身份信息进行认证和鉴权。</p></li><li><p>UGC消息通知：可以处理二手市场发布、编辑商品信息后，通过邮件、消息推送的方式告知用户。</p></li><li><p>商品信息服务：负责二手商品信息的发布、编辑、删除、搜索等功能。</p></li><li><p>缓存服务：应对二手市场这种读大于写的场景，可以将最新的50条商品信息放入系统缓存中，优化用户查看商品的体验。</p></li><li><p>支付服务：支付服务负责处理用户的支付请求，与第三方支付平台进行交互，并确保支付的安全性和可靠性。</p></li><li><p>文件服务：用于处理用户上传的图片、视频。</p></li><li><p>服务容灾和负载均衡方式</p><ol><li>服务容灾：<ol><li>定期对系统的数据进行备份</li><li>定期检查维护服务器的实例，修复代码BUG等</li></ol></li><li>负载均衡：<ol><li>CDN服务：将静态资源（图片、视频等）放置在内容分发网络中，加快资源加载速度，减少服务器负载</li><li>缓存数据，使用缓存减轻服务器负担，提高响应速度</li><li>反向代理：通过Nginx反向代理服务实现负载均衡，等后面有多台服务器之后将请求分发给不同的服务器，提高服务可扩展性。</li></ol></li></ol></li></ol><p><strong>数据流实现：</strong></p><ol><li>用户上传商品：<ol><li>用户在应用中填写商品信息，并上传相关照片</li><li>上传的用户信息和照片URL被发送到服务器中进行处理和存储</li><li>服务器对传过来的数据进行数据库存储，并生成一个唯一ID</li></ol></li><li>商品展示和搜索：<ol><li>其他用户访问二手市场时，前端向后端请求商品数据</li><li>后端从数据库中获取数据列表，并返回给前端</li><li>用户可以根据自身的需求条件查询特定的商品，前端将搜索条件发送给后端，后端根据条件查询数据库并返回匹配的商品信息。</li></ol></li><li>商品详情获取：<ol><li>当用户点击某个商品的详情信息之后，前端发送请求，传递对应的商品ID给后端</li><li>后端根据商品ID在数据库中搜索并返回具体商品信息给前端展示</li></ol></li></ol><h2 id="如果检索某个具体商品是如何实现检索的？"><a href="#如果检索某个具体商品是如何实现检索的？" class="headerlink" title="如果检索某个具体商品是如何实现检索的？"></a>如果检索某个具体商品是如何实现检索的？</h2><h2 id="查询的时候如何避免慢查询？"><a href="#查询的时候如何避免慢查询？" class="headerlink" title="查询的时候如何避免慢查询？"></a>查询的时候如何避免慢查询？</h2><ul><li>索引优化，将经常用到的字段创建索引（除去经常更新的字段、重复度很高的字段、数据量较少的情况），比如单列索引和联合索引，从而避免全表扫描。</li><li>分页查询：对于返回大量的数据查询，使用分页查询的方式，限制返回的数据量，避免一次返回大量的数据导致查询速率很慢。</li><li>缓存查询：对于一些比较查询比较频繁的数据可以使用缓存来避免每次都进行数据库查询。</li><li>合理设计数据库的表结构：比如说说评论查询，二级评论可以通过添加一个masterId字段(对应的说说id)来快速定位到此二级评论是归属于哪条说说之下。</li></ul><h2 id="如何正确的创建索引？（即：什么时候创建索引？）"><a href="#如何正确的创建索引？（即：什么时候创建索引？）" class="headerlink" title="如何正确的创建索引？（即：什么时候创建索引？）"></a>如何正确的创建索引？（即：什么时候创建索引？）</h2><ul><li>字段具有唯一性限制，即重复度很低，且不是经常修改的字段</li><li>经常用于where子句查询</li><li>经常用于group by 或者 order by查询</li><li>表的数据量比较多的情况</li></ul><h2 id="二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？"><a href="#二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？" class="headerlink" title="二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？"></a>二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？</h2><ol><li>正确、错误、空物品查询</li><li>物品大小写查询</li><li>高并发查询</li><li>过滤项查询</li><li>物品状态查询</li><li>安全性测试：比如SQL注入</li><li>边界值测试：比如输入极限情况下，很长的字符串验证系统是否能正确处理。</li></ol><h2 id="后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？"><a href="#后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？" class="headerlink" title="后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？"></a>后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？</h2><ol><li>统计性能的方式：<ol><li>日志记录</li><li>性能监控工具的使用：比如New Relic、Prometheus等</li><li>负载测试，模拟大量并发请求，观察系统的响应情况和性能指标。</li></ol></li><li>有，限流操作如下：<ol><li>固定窗口计时器：设置一个固定时间窗口，例如</li></ol></li></ol><h2 id="HashMap、HashSet、HashTable的区别？"><a href="#HashMap、HashSet、HashTable的区别？" class="headerlink" title="HashMap、HashSet、HashTable的区别？"></a>HashMap、HashSet、HashTable的区别？</h2><p><strong>HashMap和HashTable区别：</strong></p><ul><li>线程是否安全：HashMap是非线程安全，HashTable是线程安全（通过synchronized修饰实现）。</li><li>效率：由于HashMap线程不安全，HashMap比HashTable效率高，但是HashTable几乎被淘汰，平时一般不会用HashTable。</li><li>键值对存值问题：HashMap是可存null键和null值，HashTable不允许有null键和null值，否则会抛出异常NPE。</li><li>初始容量大小和每次扩充容量大小不同：HashTable初始化容量是11，每次扩容就是2n+1，HashMap初始化容量是16，每次扩容就是原来的2n倍。</li><li>底层数据结构：HashMap是<strong>数组+<strong><strong>链表</strong></strong>/红黑树</strong>实现，在解决哈希冲突时，当链表长度大于阈值（默认为8），将链表转化成红黑树（将链表转化成红黑树之前，如果数组长度小于64就会进行数组扩容，而不是转换成红黑树），以减少搜索时间，而HashTable是<strong>数组+链表</strong>的形式实现。</li></ul><p><strong>HashMap和<strong><strong>HashSet</strong></strong>的区别：</strong></p><ul><li>HashMap实现Map接口，HashSet实现Set接口。</li><li>HashMap存储键值对，HashSet只存储对象。</li><li>HashMap通过put方法添加元素，HashSet通过add()向Set中添加元素。</li><li>HashMap使用Key计算hashcode，HashSet使用成员对象计算hashcode值。</li></ul><h2 id="HashMap是线程的安全的吗？介绍一下ConcurrentHashMap"><a href="#HashMap是线程的安全的吗？介绍一下ConcurrentHashMap" class="headerlink" title="HashMap是线程的安全的吗？介绍一下ConcurrentHashMap"></a>HashMap是线程的安全的吗？介绍一下ConcurrentHashMap</h2><p>线程<strong>不安全</strong>，因为多线程情况下，HashMap进行键值对存值的时候，可能会因为分配到一个桶里面造成数据覆盖的风险，比如线程1，2同时进行put操作，此时正好发生了hash冲突，线程1执行完hash冲突判断之后，时间片耗尽挂起，此时线程2进行hash冲突判断并对数据插入到链表中，后面等线程1重新获取到时间片，进行插入操作就会覆盖掉线程插入的数据。</p><p><strong>ConcuurentHashMap：</strong></p><p>Java8以上数据结构是Node数组+链表/红黑树，哈希冲突时当链表长度大于一定长度时，链表就会转换成红黑树。</p><h2 id="接口和抽象类的区别？"><a href="#接口和抽象类的区别？" class="headerlink" title="接口和抽象类的区别？"></a>接口和抽象类的区别？</h2><ul><li>接口是对类的行为进行约束，实现了某个接口就是已经拥有了具体的行为，抽象类是代码复用，强调的是类的从属关系。</li><li>接口的成员变量只能用public static final修饰且不可修改和初始化，抽象类的成员变量默认为default类型，可以在子类被重新赋值定义。</li><li>一个类可以实现多个接口但是只能继承一个父类。</li></ul><h2 id="如果某个网页打不开了，排查手段有哪些？"><a href="#如果某个网页打不开了，排查手段有哪些？" class="headerlink" title="如果某个网页打不开了，排查手段有哪些？"></a>如果某个网页打不开了，排查手段有哪些？</h2><h2 id="Linux中查看主目录下以-log结尾的文件？"><a href="#Linux中查看主目录下以-log结尾的文件？" class="headerlink" title="Linux中查看主目录下以.log结尾的文件？"></a>Linux中查看主目录下以.log结尾的文件？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/home/directory -<span class="built_in">type</span> f -name <span class="string">&quot;*.log&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>find</code>：命令本身，用于查找文件和目录。</li><li><code>/path/to/home/directory</code>：替换为你要查找的主目录的路径。例如，如果你要在当前用户的主目录下查找，可以使用<code>~</code>代替这个路径。</li><li><code>-type f</code>：表示只查找普通文件，不包括目录等其他类型的文件。</li><li><code>-name &quot;*.log&quot;</code>：表示查找文件名以<code>.log</code>结尾的文件。<code>*.log</code>是通配符，表示匹配所有以<code>.log</code>结尾的文件名。</li></ul><h2 id="如何查询某个日志的内容？"><a href="#如何查询某个日志的内容？" class="headerlink" title="如何查询某个日志的内容？"></a>如何查询某个日志的内容？</h2><ul><li>Cat</li><li>Head</li><li>Tail</li><li>Less</li><li>More</li></ul><h2 id="比较一下less命令和more命令的区别？"><a href="#比较一下less命令和more命令的区别？" class="headerlink" title="比较一下less命令和more命令的区别？"></a>比较一下less命令和more命令的区别？</h2><ul><li>less支持前后翻页，more只支持向后翻页</li><li>less是根据要展示的内容加载到内存中，加快读取速度，more是将整个文件内容全部加载到内存中，可能会导致崩溃</li></ul><h2 id="算法题：力扣平衡字符串问题"><a href="#算法题：力扣平衡字符串问题" class="headerlink" title="算法题：力扣平衡字符串问题"></a>算法题：力扣平衡字符串问题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单介绍一下二手市场整体的架构，数据流的实现？&quot;&gt;&lt;a href=&quot;#简单介绍一下二手市场整体的架构，数据流的实现？&quot; class=&quot;headerlink&quot; title=&quot;简单介绍一下二手市场整体的架构，数据流的实现？&quot;&gt;&lt;/a&gt;简单介绍一下二手市场整体的架构，数</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面经-滴滴golang后端实习 2023 - 07 - 04</title>
    <link href="http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E6%BB%B4%E6%BB%B4Golang%E5%AE%9E%E4%B9%A0/"/>
    <id>http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E6%BB%B4%E6%BB%B4Golang%E5%AE%9E%E4%B9%A0/</id>
    <published>2023-07-23T05:16:20.000Z</published>
    <updated>2023-08-10T05:13:44.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP有哪些请求方式？"><a href="#HTTP有哪些请求方式？" class="headerlink" title="HTTP有哪些请求方式？"></a>HTTP有哪些请求方式？</h2><ul><li>PUT：将数据存储在服务器，覆盖指定URL，常用于更新资源</li><li>GET：从服务器获取数据，GET请求是幂等的，即多次请求相同的URL会返回相同的结果</li><li>POST：向服务器提交数据，通常用于向服务器发送数据，比如提交表单</li><li>DELETE：从服务器删除指定的URL资源。</li><li>HEAD：类似于GET请求，但服务器只返回头部信息，不返回实际数据。主要用于检查资源的元数据，例如确认资源是否存在或最后修改日期等。</li><li>OPTIONS：获取目标URL支持的请求方法信息。用于查询服务器支持哪些HTTP方法。</li><li>PATCH：用于对资源进行局部更新，更新指定的字段而不是像PUT一样更新整个资源。</li><li>TRACE：用于目标服务器上执行一个消息环回测试，主要用于诊断。</li><li>CONNECT：用于代理服务器请求，通常用于建立代理服务器的隧道。</li></ul><h2 id="POST和GET的使用场景及区别？"><a href="#POST和GET的使用场景及区别？" class="headerlink" title="POST和GET的使用场景及区别？"></a>POST和GET的使用场景及区别？</h2><p>POST主要用于客户端向服务端提交数据的时候使用，GET主要用于客户端向服务端获取请求的时候使用。</p><p>POST和GET实际上没有什么区别，如果硬要说有区别可见如下：</p><ul><li>GET方法产生一个数据包，POST方法产生两个数据包。<ul><li>GET方法会将header和data一并发给服务器，服务器响应200。</li><li>POST方法会先发送header给服务器，等服务器返回100之后发送data给服务器，然后服务器响应200。此方法在网络差的情况下，会稍微好一点，因为分两次发可能丢包率会小一些。（POST请求，数据包Firefox只会发一次）</li></ul></li><li>GET请求URL传递的参数会有长度限制，POST没有</li><li>GET请求传递参数放在URL中，POST放在Body部分</li><li>GET请求只接受ASCII字符，POST无限制</li><li>GET请求比POST更不安全，因为参数会外漏在URL，所以不能传递敏感信息。</li></ul><h2 id="Token在HTTP请求的时候会放在什么位置？"><a href="#Token在HTTP请求的时候会放在什么位置？" class="headerlink" title="Token在HTTP请求的时候会放在什么位置？"></a>Token在HTTP请求的时候会放在什么位置？</h2><p>一般存在header里面的Authorization字段，Java获取的此字段信息的代码一般如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取Authorization头的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorizationHeader</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        System.out.println(authorizationHeader);</span><br><span class="line"></span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？"><a href="#GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？" class="headerlink" title="GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？"></a>GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？</h2><ol><li>有长度限制。</li><li>不是HTTP本身限制了这个URL长度，一般是指定的浏览器或者服务器对它进行了长度的限制，超过一定的限制，服务器可能会直接返回错误或者截断URL，发生错误的请求。</li><li>解决URL超长问题方法如下：<ol><li>采取POST请求，因为POST请求对数据传输的长度没有限制</li><li>分割请求，如果传输的数据量很大，可以分割成很多小的请求分批次进行数据发送，然后服务端进行整合。</li><li>避免GET请求传输大量的数据。</li><li>压缩URL参数：通过将GET请求的URL参数进行压缩，转换成Base64来压缩参数，减少URL长度。</li></ol></li></ol><h2 id="介绍一下对Spring的理解"><a href="#介绍一下对Spring的理解" class="headerlink" title="介绍一下对Spring的理解"></a>介绍一下对Spring的理解</h2><p>是一款开源的轻量级开发框架，是多个模块的集合，比如：Spring IOC、Spring AOP等。</p><ol><li>SpringIOC（DI）</li><li>SpringAOP</li><li>可以整合其他技术开发</li></ol><h2 id="Spring、SpringMVC、SpringleBoot的区别"><a href="#Spring、SpringMVC、SpringleBoot的区别" class="headerlink" title="Spring、SpringMVC、SpringleBoot的区别"></a>Spring、SpringMVC、SpringleBoot的区别</h2><ul><li>Spring的核心模块就是Spring-Core（主要负责SpringIOC容器的依赖注入的支持），Spring其他所有功能都依赖此模块（包括SpringMVC）。</li><li>SpringMVC是Spring中得一个模块，主要赋予Spring快速构建MVC架构的Web程序能力，MVC（Model、View、Controller），其核心思想就是将业务逻辑、数据处理、视图显示分离来组织代码。</li><li>SpringBoot只是简化了配置，减少配置文件（比如xml文件、Java显示配置，开箱即用）</li></ul><h2 id="解释一下SpringIOC、SpringAOP"><a href="#解释一下SpringIOC、SpringAOP" class="headerlink" title="解释一下SpringIOC、SpringAOP"></a>解释一下SpringIOC、SpringAOP</h2><p><strong>Spring</strong> <strong>IOC<strong><strong>（</strong></strong>inversion of control<strong><strong>，</strong></strong>控制反转****）</strong></p><p>是一种设计思想，其思想就是把原本在程序创建对象的控制权，统一交给SpringIOC容器去管理，控制：创建对象实例的权利，反转：控制权交给Spring框架、IOC容器去管理。</p><p>有了SpringIOC之后，我们只需要直接从容器中获取对象即可，而对象的创建是交给SpringIOC容器去创建管理的。</p><p>实现方式：</p><p>1、从配置元数据获取DI的业务POJO（配置元数据：xml、Configuration、注解等）</p><p>2、将业务POJO形成BeanDefinition注入到Spring Container中</p><p>3、使用方通过AppllicationContext从SpringContainer中获取即可</p><p><strong>Spring AOP（Aspect Object Programming，<strong><strong>面向切面编程</strong></strong>）</strong></p><p>就是把公共逻辑抽出来，让开发者更加专注于业务逻辑开发。AOP是一种设计思想，是OOP的补充，OOP是面向类和对象的，但是AOP是面向不同切面的，一个切面可以横跨多个类和对象去操作，极大的提高了开发效率。</p><p>比如一个订单的创建，大致流程是：</p><p>1、权限校验</p><p>2、事务管理</p><p>3、创建订单</p><p>4、日志管理</p><p>使用AOP思想就可以把这四个步骤当作四个切面，让开发者专注于第三个切面，其他三个切面则使用基础的通用逻辑统一交给AOP封装管理。</p><h2 id="SpringAOP是如何实现的？"><a href="#SpringAOP是如何实现的？" class="headerlink" title="SpringAOP是如何实现的？"></a>SpringAOP是如何实现的？</h2><p>AOP实现原理：</p><p>AOP实现有两种方式，一种是Java原生的动态代理，一种是基于cglib的动态代理。默认的一般是原生的JDK的动态代理，但是这种代理方式无法代理没有接口的类，此时就会使用cglib代理这个没有接口实现的类。</p><h2 id="Sql注入攻击是什么？SQL注入是怎么产生的？"><a href="#Sql注入攻击是什么？SQL注入是怎么产生的？" class="headerlink" title="Sql注入攻击是什么？SQL注入是怎么产生的？"></a>Sql注入攻击是什么？SQL注入是怎么产生的？</h2><p><strong>SQL注入攻击****：</strong>针对使用SQL进行数据查询和操作的应用程序，基本原理是通过在用户输入的数据中插入恶意的SQL代码，从而让应用程序执行未经授权的数据库操作或者或者泄露敏感信息。</p><p>比如SQL = select * from user where username = ‘#{username}’ and password = ‘#{password}’，攻击者在用户名框或者密码输入框中输入恶意的SQL代码：<code>&#39; OR 1 = 1 --</code> 就会变成<code>select * from user where username = &#39;&#39; or 1 = 1  --&#39;and password=&#39;&#39;</code> ，此时<code>-- &#39; and password = &#39;&#39;</code> 已经被注释掉了实际上就是<code>select * from user where username = &#39;&#39; or 1 = 1;</code> 此时就会将所有用户的数据信息全部返回给前端。</p><p><strong>SQL注入的产生</strong></p><p>1、参数未校验，用户不正确的输入</p><p>2、特殊字符未转义，例如：=、–这种类型的符号</p><h2 id="什么时候需要创建索引？"><a href="#什么时候需要创建索引？" class="headerlink" title="什么时候需要创建索引？"></a>什么时候需要创建索引？</h2><ul><li>字段具有唯一性限制</li><li>经常用于where子句查询的字段</li><li>经常用于group by 和 order by查询的字段</li></ul><h2 id="为什么索引如果重复度比较高的时候会对数据库产生一定的压力？"><a href="#为什么索引如果重复度比较高的时候会对数据库产生一定的压力？" class="headerlink" title="为什么索引如果重复度比较高的时候会对数据库产生一定的压力？"></a>为什么索引如果重复度比较高的时候会对数据库产生一定的压力？</h2><ul><li>导致页分裂，占用物理空间大：每次数据更新的话，会导致索引进行重新排序，甚至造成页分裂的问题，导致索引查询效率下降，也会在一定程度上造成空间不必要的浪费。</li><li>维护成本高：索引重复度比较高也会导致索引字段大小很大，维护空间和时间成本就会变大，占用一定的冗余物理空间</li><li>查询效率低：索引重复度比较高可能会匹配到多个符合条件的索引项，进而增加查询的开销，导致查询效率下降。</li><li>内存消耗大：如果是5.7的版本，由于MySQL的索引缓存存在的原因，索引重复度高，索引大小也会变大，需要更多的内存去存储这些数据，高内存可能会导致服务器崩溃。</li></ul><h2 id="创建联合索引失效的情况"><a href="#创建联合索引失效的情况" class="headerlink" title="创建联合索引失效的情况"></a>创建联合索引失效的情况</h2><p>当where子句查询或者order by或者group by查询的时候没有遵循最左匹配原则则会导致查询时联合索引部分失效。</p><p>比如:创建索引(a,b,c)，此时<code>select * from user where a = 1 and b = 1 and c = 1;</code>此时均用到了联合索引。</p><p>若改成<code>select * from user where a = 1 and b &gt; 1 and c = 1;</code>此时用到了索引的只有a,b，因为索引查询是先对a进行排序，在a相等的情况下，对b再进行排序，最后在b相同的情况下对c进行排序，此时因为b &gt; 1无法直接定位到从哪个索引列开始顺序查询，也就是说对c再进行排序的话无法进一步提高查询速率，所以只有a，b用到了联合索引。</p><blockquote><p>一条查询语句的顺序是from -&gt; where -&gt; group by -&gt; Having -&gt; select -&gt; order by</p></blockquote><h2 id="如果有一个联合索引-a-b-c-，如果where子句查询只有a-1-and-c-1，能不能实现走-a-b-c-这个索引查询？"><a href="#如果有一个联合索引-a-b-c-，如果where子句查询只有a-1-and-c-1，能不能实现走-a-b-c-这个索引查询？" class="headerlink" title="如果有一个联合索引(a,b,c)，如果where子句查询只有a = 1 and c = 1，能不能实现走(a,b,c)这个索引查询？"></a>如果有一个联合索引(a,b,c)，如果where子句查询只有a = 1 and c = 1，能不能实现走(a,b,c)这个索引查询？</h2><p>1、如果能够修改a,b,c联合索引的顺序的话，就可以实现，比如改成<code>(a,c,b)</code> 因为联合索引遵循<strong>最左匹配原则</strong>，即先对a排序，在a相同的情况下，对c排序，在c相同的情况下再对b进行排序，最终形成索引B+树。</p><p>2、如果不可以修改联合索引的顺序，那么将无法实现走a,b,c形成的联合索引查询，此时只有a = 1能走到联合索引。</p><h2 id="目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？"><a href="#目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？" class="headerlink" title="目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？"></a>目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> age , sex , count<span class="comment">(*) from user group by age , sex;</span></span><br><span class="line"><span class="comment">select age , count(*)</span> <span class="keyword">from</span> user <span class="keyword">group</span> <span class="keyword">by</span> age<span class="punctuation">;</span> </span><br></pre></td></tr></table></figure><h2 id="有两个集合List如何快速找出相同的元素？"><a href="#有两个集合List如何快速找出相同的元素？" class="headerlink" title="有两个集合List如何快速找出相同的元素？"></a>有两个集合List如何快速找出相同的元素？</h2><p>思路大致如下：</p><ol><li>创建并初始化两个List类型的链表</li><li>将两个List类型的列表转换成HashSet类型</li><li>使用HashSet自带的取交集方法<code>set1.retainAll(set2)</code> ，此时set1中保存的就是原set1和set2的交集，即两个集合相同的元素。</li></ol><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindCommonElements</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例数据</span></span><br><span class="line">        List&lt;Integer&gt; list1 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用HashSet找出相同元素</span></span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list1);</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list2);</span><br><span class="line"></span><br><span class="line">        set1.retainAll(set2); <span class="comment">// 保留set1中与set2的交集</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set1); <span class="comment">// 输出：[3, 4, 5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构：哈希如何使用？"><a href="#数据结构：哈希如何使用？" class="headerlink" title="数据结构：哈希如何使用？"></a>数据结构：哈希如何使用？</h2><p>「哈希表 Hash Table」通过建立键 <code>key</code> 与值 <code>value</code> 之间的映射，实现高效的元素查询。具体而言，我们向哈希表输入一个 <code>key</code> ，则可以在O(1)时间内获取对应的 <code>value</code> 。</p><p>详情见下：</p><p><a href="https://www.hello-algo.com/chapter_hashing/hash_map/">哈希表（Hello算法）</a></p><h2 id="有一个集合Set怎么批量删除部分元素？"><a href="#有一个集合Set怎么批量删除部分元素？" class="headerlink" title="有一个集合Set怎么批量删除部分元素？"></a>有一个集合Set怎么批量删除部分元素？</h2><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoveElementsFromSet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 原始Set</span></span><br><span class="line">        Set&lt;Integer&gt; originalSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        originalSet.add(<span class="number">1</span>);</span><br><span class="line">        originalSet.add(<span class="number">2</span>);</span><br><span class="line">        originalSet.add(<span class="number">3</span>);</span><br><span class="line">        originalSet.add(<span class="number">4</span>);</span><br><span class="line">        originalSet.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要删除的元素集合</span></span><br><span class="line">        Set&lt;Integer&gt; elementsToRemove = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        elementsToRemove.add(<span class="number">3</span>);</span><br><span class="line">        elementsToRemove.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 批量删除部分元素</span></span><br><span class="line">        originalSet.removeAll(elementsToRemove);</span><br><span class="line"></span><br><span class="line">        System.out.println(originalSet); <span class="comment">// 输出：[1, 2, 4]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Linux查询一个日志文件的关键字？查询某个关键字的前后500行？"><a href="#Linux查询一个日志文件的关键字？查询某个关键字的前后500行？" class="headerlink" title="Linux查询一个日志文件的关键字？查询某个关键字的前后500行？"></a>Linux查询一个日志文件的关键字？查询某个关键字的前后500行？</h2><p>查询日志文件的某个关键字可以使用grep命令实现，例如:grep ‘关键字’ filePath</p><p>查询某个关键字的前后500行：grep -AB 500或者 grep -C 500（-C == -AB）</p><h2 id="怎么保证MySQL和Redis的一致性问题"><a href="#怎么保证MySQL和Redis的一致性问题" class="headerlink" title="怎么保证MySQL和Redis的一致性问题"></a>怎么保证MySQL和Redis的一致性问题</h2><p>读请求：先读缓存，如果缓存失效或不存在就让先获取到互斥锁的线程查数据库并回写缓存，让后续的请求直接都缓存即可</p><p>写请求：先更新数据库，再删缓存即可（此时可能会出现删缓存失败的场景，可以通过消息队列的方式，采取重试机制，如果删除缓存失败，则通过消息队列再进行一次删除缓存的操作，如果删除成功，则把消息队列里面的删除缓存操作删除即可，避免重复消费，造成不必要的资源浪费）</p><h2 id="价格类型的数据Java用什么存储？"><a href="#价格类型的数据Java用什么存储？" class="headerlink" title="价格类型的数据Java用什么存储？"></a>价格类型的数据Java用什么存储？</h2><p>1、BigDecimal（使用String类型的进行转换，才不会导致精度丢失)</p><p>2、整数存储（比如：3.14存为314）</p><p>3、自定义存储方式，数据库一个字段存整数，一个字段存小数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP有哪些请求方式？&quot;&gt;&lt;a href=&quot;#HTTP有哪些请求方式？&quot; class=&quot;headerlink&quot; title=&quot;HTTP有哪些请求方式？&quot;&gt;&lt;/a&gt;HTTP有哪些请求方式？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;PUT：将数据存储在服务器，覆盖指定URL，常用</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>微布开发-二手市场开发思路(小程序+Java后端)</title>
    <link href="http://xiaobazeo.github.io/2023/07/23/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/"/>
    <id>http://xiaobazeo.github.io/2023/07/23/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/</id>
    <published>2023-07-23T02:39:05.000Z</published>
    <updated>2023-08-04T08:07:26.029Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h3 id="小程序端："><a href="#小程序端：" class="headerlink" title="小程序端："></a>小程序端：</h3><h4 id="相关参数："><a href="#相关参数：" class="headerlink" title="相关参数："></a>相关参数：</h4><ul><li>categoryBid：二级分类类别的主键id</li><li>allList：全部商品列表</li><li>sellList：转卖商品列表</li><li>askBuyList：求购商品列表</li><li>type：一级分类</li></ul><h4 id="开发思路如下："><a href="#开发思路如下：" class="headerlink" title="开发思路如下："></a>开发思路如下：</h4><h5 id="物品列表拉取："><a href="#物品列表拉取：" class="headerlink" title="物品列表拉取："></a>物品列表拉取：</h5><ol><li>默认获取全部所有的商品list用于初始化加载页面</li><li>滑动一级分类，确认一级分类type类型<ol><li>Type = 转卖<ol><li>初始化<ol><li>默认转卖一级分类的所有商品列表</li><li>滑动到二级分类，根据二级分类类型对应的categoryBid拉取列表</li></ol></li><li>下拉刷新<ol><li>若为一级分类的所有商品列表，categoryBid = null</li><li>若具体到二级分类的具体类型，categoryBid = 对应的二级分类bid</li></ol></li><li>上滑加载<ol><li>根据一级分类和二级分类(categoryBid )的类别确定获取什么类型的list并且赋值到allList/sellList/askBuyList</li></ol></li></ol></li><li>Type = 求购<ol><li>初始化<ol><li>默认求购一级分类的所有商品列表</li><li>滑动到二级分类，根据二级分类类型对应的categoryBid拉取列表</li></ol></li><li>下拉刷新<ol><li>若为一级分类的所有商品列表，categoryBid = null</li><li>若具体到二级分类的具体类型，categoryBid = 对应的二级分类bid</li></ol></li><li>上滑加载<ol><li>根据一级分类和二级分类的类别确定获取什么类型的list并且赋值到allList/sellList/askBuyList</li></ol></li></ol></li><li>一级分类切换的时候由于默认的是一级分类的所有商品列表拉取，所以一级分类切换的时候，修改对应的二级分类bid为空，不然切换的时候就相当于执行了<code>select * from hand where type = &#39;***&#39; and categoryBid = &#39;***&#39; order by id desc</code>;</li></ol></li></ol><p>发布、删除、编辑操作，根据接口以及业务场景传递对应的参数即可。其中可能需要对部分参数进行参数校验、长度限制等，前后端都会做限制。</p><h4 id="物品详情："><a href="#物品详情：" class="headerlink" title="物品详情："></a>物品详情：</h4><p>物品名、物品介绍、物品照片、物品价格、交易地址、物品数量、物品类型、其他联系方式：QQ/微信</p><h3 id="Java后端："><a href="#Java后端：" class="headerlink" title="Java后端："></a>Java后端：</h3><h4 id="表结构设计：（仅展示部分必要字段，可根据自己的需求自定义设计其他字段）"><a href="#表结构设计：（仅展示部分必要字段，可根据自己的需求自定义设计其他字段）" class="headerlink" title="表结构设计：（仅展示部分必要字段，可根据自己的需求自定义设计其他字段）"></a>表结构设计：（仅展示部分必要字段，可根据自己的需求自定义设计其他字段）</h4><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/512ac4e3ee94e9c20c6b7733cfdc8e9.png" alt="512ac4e3ee94e9c20c6b7733cfdc8e9"></p><h4 id="开发思路："><a href="#开发思路：" class="headerlink" title="开发思路："></a>开发思路：</h4><h5 id="获取商品列表-详情（都是封装在一个接口，根据根据不同场景，前端传的参数不一样，获取不同的查询结果）："><a href="#获取商品列表-详情（都是封装在一个接口，根据根据不同场景，前端传的参数不一样，获取不同的查询结果）：" class="headerlink" title="获取商品列表/详情（都是封装在一个接口，根据根据不同场景，前端传的参数不一样，获取不同的查询结果）："></a><strong>获取商品列表/详情</strong>（都是封装在一个接口，根据根据不同场景，前端传的参数不一样，获取不同的查询结果）：</h5><ol><li>校验用户身份，主要是从userBid、schoolBid以及token是否被篡改方向进行校验。</li><li>根据条件筛选结果。<ol><li>全部商品：根据id进行倒序分页查询，主要参数：商品主键id</li><li>根据type类型（确定是转卖/求购）<ol><li>二级分类查询：使用andCategoryBidsEqualTo方法实现匹配，分页返回list，主要参数：type（求购/转卖）+categorybid（二级分类类别id）</li></ol></li><li>查询某物品的详情：根据targetBid字段，进行where子句查询，获取返回结果，参数：targetBid(需要查询的物品的主键id)</li><li>关键字模糊查询：根据传过来的关键字进行左右模糊查询，<strong>但是因为索引遇到左右模糊查询的时候会出现索引失效，所以后面可能需要通过<strong><strong>es</strong></strong>组件优化模糊查询速率。</strong></li><li>查询自己发布过的商品：根据用户id进行where子句查询，获取返回结果，主要参数：tagetUserBid</li></ol></li><li>返回操作码以及结果</li></ol><h5 id="添加商品"><a href="#添加商品" class="headerlink" title="添加商品"></a><strong>添加商品</strong></h5><ol><li>校验用户身份。</li><li>身份校验成功，进行添加操作：<ol><li>判断必传参数：type、地址、联系方式、物品的名字、二级分类类别id、出售/求购价格、物品描述、是否同步到说说（<strong>后续可以改成异步操作防止主线程阻塞</strong>）、物品数量</li><li>可选择性传递参数：物品照片url</li></ol></li><li>存入数据库</li><li>返回操作码以及状态</li></ol><h5 id="删除商品"><a href="#删除商品" class="headerlink" title="删除商品"></a>删除商品</h5><ol><li>校验用户身份。</li><li>判断传递参数是否有效：<ol><li>判断商品id是否为空</li><li>判断商品是否存在</li><li>判断是不是本人操作</li></ol></li><li>进行软删操作，即设置isdelete=1并更新数据库</li><li>返回操作码及结果</li></ol><h5 id="更新商品信息："><a href="#更新商品信息：" class="headerlink" title="更新商品信息："></a>更新商品信息：</h5><ol><li>校验用户信息</li><li>判断参数是否有效<ol><li>判断请求参数是否为空</li><li>判断是否有此商品信息</li><li>判断是不是本人操作</li></ol></li><li>进行相关参数更新操作</li><li>返回操作码及结果</li></ol><h5 id="联系他人："><a href="#联系他人：" class="headerlink" title="联系他人："></a>联系他人：</h5><p>联系他人涉及：扣除发起者能量值、</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;小程序端：&quot;&gt;&lt;a href=&quot;#小程序端：&quot; class=&quot;headerlink&quot; title=&quot;小程序端：&quot;&gt;&lt;/a&gt;小程序端：&lt;/h3&gt;&lt;h4 id=&quot;相关参数：&quot;&gt;&lt;a href=&quot;#相关参数：&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-Index</title>
    <link href="http://xiaobazeo.github.io/2023/06/19/MySQL-Index/"/>
    <id>http://xiaobazeo.github.io/2023/06/19/MySQL-Index/</id>
    <published>2023-06-19T04:28:01.000Z</published>
    <updated>2023-08-19T07:34:09.035Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引篇"><a href="#索引篇" class="headerlink" title="索引篇"></a>索引篇</h3><h4 id="为什么Mysql-InnoDB选择B-树作为索引数据结构？"><a href="#为什么Mysql-InnoDB选择B-树作为索引数据结构？" class="headerlink" title="为什么Mysql InnoDB选择B+树作为索引数据结构？"></a>为什么Mysql InnoDB选择B+树作为索引数据结构？</h4><p>1、B+ Tree VS B Tree</p><ul><li>B+树只有在叶子节点才存储数据，非叶子节点只存储索引，B树的非叶子节点也要存储数据，所以B+树的单个节点的数据量更小，在相同I/O次数下，能查询更多的节点。</li><li>B+树是双链表连接，适合MySQL中基于范围的顺序查找，但是B树不行。</li></ul><p>2、B+ Tree VS 二叉树</p><ul><li>B+Tree的搜索复杂度是O(logdN)，d表示节点的最大子节点个数，一般大于100，这样可以保证在千万级别的数据量下，B+Tree高度依然保持在3<del>4层左右，即一次数据查询操作一般只需要3</del>4次I/O操作即可查询到目标。</li><li>二叉树节点的子节点最多两个，所以搜索复杂度是O(logN)，因此搜索一条数据在二叉树里面的I/O操作次数远高于B+Tree。</li></ul><p>3、B+Tree vs Hash</p><ul><li>Hash在进行等值查询的时候效率是O(1)，但是Hash不适合做范围查询。</li></ul><h4 id="主键索引，唯一索引，普通索引，前缀索引，联合索引"><a href="#主键索引，唯一索引，普通索引，前缀索引，联合索引" class="headerlink" title="主键索引，唯一索引，普通索引，前缀索引，联合索引"></a>主键索引，唯一索引，普通索引，前缀索引，联合索引</h4><ul><li><p>主键索引</p><ul><li>一张表只有一个主键索引</li><li>不能为空，NOT NULL</li></ul></li><li><p>唯一索引</p><ul><li>一张表可以有多个唯一索引，但是索引值必须唯一，允许有空值</li></ul></li><li><p>普通索引</p><ul><li>不要求是主键，也不要求unique</li></ul></li><li><p>前缀索引</p><ul><li>针对字符型字段的前几个字符创建索引，可以建立在char、varchar、binary、varbinary的列上。</li><li>为了减少索引占用的存储空间，提升查询效率</li></ul></li><li><p>联合索引</p><ul><li><p> 举例如下：创建商品表的product_no 和 name 字段组成联合索引(product_no,name)，创建联合索引的方式如下:</p></li><li><p>```Java<br>CREATE INDEX index_product_no_name ON product(product_no,name);</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">B+Tree的示意图如下：</span><br><span class="line"></span><br><span class="line">![img](https://qazbc6jrkh1.feishu.cn/space/api/<span class="type">box</span>/stream/download/asynccode/?code=ZGVkYTZlYjFmZTIyODdlNDlhYTU5M2I2NDQ0ZDk3ZmJfUGRPNHA5RHBuR1hzWUE3cG93TGRDVm1Jb0V3NUVPYlNfVG9rZW46U2QycGI5c0N5b25LMzF4aDg1a2NvQlhkbmZiXzE2OTI0MzA0Mzg6MTY5MjQzNDAzOF9WNA)</span><br><span class="line"></span><br><span class="line">联合索引查询数据时，先按照product_no字段比较，在product_no相同的情况下再按<span class="type">name</span>字段比较，也就是说联合索引查询的时候，先将product_no进行排序，再按照product_no相同的情况下将<span class="type">name</span>字段进行排序。</span><br><span class="line"></span><br><span class="line">此时联合索引存在**最左匹配原则，**也就是按照最左优先的方式进行索引匹配，使用联合索引的时候如果不遵循“最左匹配原则”索引此时就会失效。</span><br><span class="line"></span><br><span class="line">上述创建了product_no，<span class="type">name</span>的联合索引即`(product_no,<span class="type">name</span>)`如果是以下的情况即可匹配联合索引:</span><br><span class="line"></span><br><span class="line">- <span class="keyword">where</span> product_no = <span class="number">1</span> <span class="keyword">and</span> <span class="type">name</span> = <span class="string">&#x27;ali&#x27;</span>;</span><br><span class="line">- <span class="keyword">where</span> <span class="type">name</span> = <span class="string">&#x27;bytedance&#x27;</span> <span class="keyword">and</span> product_no = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">因为查询优化器的存在，product_no和<span class="type">name</span>字段在<span class="keyword">where</span>子句中并不重要。</span><br><span class="line"></span><br><span class="line">但是下列例子中，因为不符合最左匹配原则，所以无法匹配以上联合索引，联合索引会失效：</span><br><span class="line"></span><br><span class="line">-  <span class="keyword">where</span> <span class="type">name</span> = <span class="string">&#x27;ali&#x27;</span>;</span><br><span class="line"></span><br><span class="line">以上语句会导致索引失效，因为`(product_no,<span class="type">name</span>)`索引是按照product_no先进行排序，在product_no相同的情况下再按<span class="type">name</span>排序，因此<span class="type">name</span>是**全局无序的，局部相对有序的**，这样在没有遵循最左匹配原则的情况下，无法利用索引。</span><br><span class="line"></span><br><span class="line">  **联合索引****范围查询**</span><br><span class="line"></span><br><span class="line">**查询过程中不一定使用了****联合索引****查询，就代表联合索引中得所有字段都用到了联合索引进行索引查询。**可能是部分索引用到了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>select * from t_table where a &gt; 1 and b = 2</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">因为a &gt; <span class="number">1</span> <span class="keyword">and </span><span class="keyword">b </span>= <span class="number">2</span>无法通过范围查询定位到从哪个具体的索引开始查询（可能会有a = <span class="number">2</span> <span class="keyword">and </span><span class="keyword">b </span>= <span class="number">2</span>，a = <span class="number">3</span> <span class="keyword">and </span><span class="keyword">b </span>= <span class="number">2</span>的情况），此时意味着<span class="keyword">b=2的条件并不能通过索引进一步减少扫描的记录数量，即b字段无法利用联合索引进行查询。</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure><p>select * from t_table where a &gt;= 1 and b = 2</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">此时因为a &gt;= <span class="number">1</span> <span class="keyword">and </span><span class="keyword">b </span>= <span class="number">2</span>可以直接定位到具体从哪个索引开始扫描查询（即a = <span class="number">1</span> <span class="keyword">and </span><span class="keyword">b </span>= <span class="number">2</span>），此时<span class="keyword">b </span>= <span class="number">2</span>是相对有序全局无序的（即先按照a字段进行排序，再在a字段相等的情况下按照<span class="keyword">b字段进行排序）。</span></span><br><span class="line"><span class="keyword"></span></span><br></pre></td></tr></table></figure><p>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">因为a &gt;= <span class="number">2</span> <span class="keyword">and</span> a &lt;= <span class="number">8</span> <span class="keyword">and</span> b = <span class="number">2</span>可以直接定位到具体从哪个索引开始扫描（即 a = <span class="number">2</span> <span class="keyword">and</span> b = <span class="number">2</span>），此时b = <span class="number">2</span>是在a = <span class="number">2</span>开始排序的前提下，在a相等的情况下再对b进行排序，即b字段是局部有序，全局无序的状态。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">&#x27;j%&#x27;</span> <span class="keyword">and</span> age = <span class="number">22</span></span><br><span class="line"></span><br><span class="line">二级索引先根据<span class="type">name</span>字段进行排序，在<span class="type">name</span>字段相等的前提下，再对age进行排序，此时<span class="type">name</span>前缀为‘j’的二级索引是相邻的</span><br><span class="line"></span><br><span class="line">#### 什么时候需要创建索引？</span><br><span class="line"></span><br><span class="line">- 字段有唯一性限制</span><br><span class="line">- 经常用于`<span class="keyword">WHERE</span>`查询的字段</span><br><span class="line">- 经常用于`<span class="keyword">GROUP</span> <span class="keyword">BY</span>`和`<span class="keyword">ORDER</span> <span class="keyword">BY</span>`字段</span><br><span class="line"></span><br><span class="line">#### 什么时候不需要索引？</span><br><span class="line"></span><br><span class="line">- `<span class="keyword">where</span>` 条件、`<span class="keyword">GROUP</span> <span class="keyword">BY</span>` 、`<span class="keyword">ORDER</span> <span class="keyword">BY</span>` 里面用不到的字段。</span><br><span class="line">- 字段中存在大量重复数据，不需要创建索引，如性别字段，查询优化器发现某个值出现在表的数据行中得百分比很高的时候，就会忽略索引，进行全表扫描。</span><br><span class="line">- 表的数据太少的时候，就不需要创建索引。</span><br><span class="line">- 经常更新的字段不需要创建索引。比如电商的余额</span><br><span class="line"></span><br><span class="line">#### 索引优化的办法？</span><br><span class="line"></span><br><span class="line">- 前缀索引优化</span><br><span class="line"> - <span class="keyword">ORDER</span> <span class="keyword">BY</span>无法使用前缀索引</span><br><span class="line"> - 无法把前缀索引用作覆盖索引</span><br><span class="line">- 覆盖索引优化</span><br><span class="line">- 主键索引最好自增</span><br><span class="line"> - 如果不是自增化，就可能会导致插入的数据，插入到现有数据页中得某个位置，这将不得不移动其他数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，这时候就会产生页分裂，页分裂可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</span><br><span class="line">- 防止索引失效</span><br><span class="line">- 索引最好设置成<span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"> - 会占用物理空间</span><br><span class="line"> - 会导致优化器在做索引选择的时候更加复杂</span><br><span class="line"></span><br><span class="line">#### 索引失效有哪些？</span><br><span class="line"></span><br><span class="line">- 对索引使用左或左右模糊匹配</span><br><span class="line"></span><br><span class="line">因为索引查询的根本目的是为了通过索引能够缩小查询范围，从而提高查询的速率，但是左模糊或左右模糊查询无法直接通过索引直接定位到符合要求的字段而减小查询范围，所以会导致索引失效。</span><br><span class="line"></span><br><span class="line">- 对索引使用函数</span><br><span class="line"> - 因为索引保存的是索引字段的原始值，而不是经过函数计算之后的值，索引无法走索引了。</span><br><span class="line"> - 不过在MySQL8<span class="number">.0</span>之后可以针对函数计算之后的值建立索引，即该索引的值是函数计算后的值，可以通过扫描该索引进行查询数据了。</span><br><span class="line"></span><br><span class="line">- 对索引进行表达式计算</span><br><span class="line"> - 因为索引保存的是索引字段的原始值，而不是id+<span class="number">1</span>表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。</span><br><span class="line"></span><br><span class="line">- 对索引隐式类型转换</span><br><span class="line"> - id  <span class="type">int</span>，phone <span class="type">varchar</span></span><br><span class="line"> - ```<span class="keyword">SQL</span></span><br><span class="line">   <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id = &quot;1&quot;;//字符串转整数类型</span><br><span class="line">   <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> id = CAST(&quot;1&quot; <span class="keyword">AS</span> signed <span class="type">int</span>);//此时id字段并没有用到<span class="keyword">CAST</span>函数，索引能够走到索引字段。</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> phone = <span class="number">1300000001</span>;//整数转字符串</span><br><span class="line">   <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> CAST(phone <span class="keyword">AS</span> signed <span class="type">int</span>) = <span class="number">1300000001</span>;//此时phone索引字段使用了<span class="keyword">CAST</span>函数，而对索引使用函数会导致索引失效。</span><br></pre></td></tr></table></figure></blockquote></li><li></li></ul></li><li><p>联合索引非最左匹配</p><ul><li><p> <code>SELECT * FROM y_table where a = 1 and b = 1 and c = 1;</code></p></li><li><p> 联合索引查询的时候B+树是先按a的顺序进行排序，然后在a相同的情况下对b进行排序，在b相同的情况下，最后对c进行排序。</p></li></ul></li><li><p>WHERE子句中得OR查询</p><ul><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;索引篇&quot;&gt;&lt;a href=&quot;#索引篇&quot; class=&quot;headerlink&quot; title=&quot;索引篇&quot;&gt;&lt;/a&gt;索引篇&lt;/h3&gt;&lt;h4 id=&quot;为什么Mysql-InnoDB选择B-树作为索引数据结构？&quot;&gt;&lt;a href=&quot;#为什么Mysql-InnoDB选择B-树</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://xiaobazeo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>面经- 星环科技Java实习 2023-6-12</title>
    <link href="http://xiaobazeo.github.io/2023/06/12/%E9%9D%A2%E7%BB%8F-%E6%98%9F%E7%8E%AF%E7%A7%91%E6%8A%80Java%E5%AE%9E%E4%B9%A0-2023-6-12/"/>
    <id>http://xiaobazeo.github.io/2023/06/12/%E9%9D%A2%E7%BB%8F-%E6%98%9F%E7%8E%AF%E7%A7%91%E6%8A%80Java%E5%AE%9E%E4%B9%A0-2023-6-12/</id>
    <published>2023-06-12T15:58:51.000Z</published>
    <updated>2023-08-18T15:59:32.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最高QPS是承受多少？服务器部署位置？目前是单体应用？"><a href="#最高QPS是承受多少？服务器部署位置？目前是单体应用？" class="headerlink" title="最高QPS是承受多少？服务器部署位置？目前是单体应用？"></a>最高QPS是承受多少？服务器部署位置？目前是单体应用？</h2><h2 id="为什么要使用雪花算法？（分布式id、雪花算法组成）"><a href="#为什么要使用雪花算法？（分布式id、雪花算法组成）" class="headerlink" title="为什么要使用雪花算法？（分布式id、雪花算法组成）"></a>为什么要使用雪花算法？（分布式id、雪花算法组成）</h2><h2 id="有无发布订阅的功能？应用场景有哪些？"><a href="#有无发布订阅的功能？应用场景有哪些？" class="headerlink" title="有无发布订阅的功能？应用场景有哪些？"></a>有无发布订阅的功能？应用场景有哪些？</h2><h2 id="Redis的应用场景是哪些？"><a href="#Redis的应用场景是哪些？" class="headerlink" title="Redis的应用场景是哪些？"></a>Redis的应用场景是哪些？</h2><h2 id="什么情况下会出现缓存雪崩？怎么防止缓存雪崩的问题？"><a href="#什么情况下会出现缓存雪崩？怎么防止缓存雪崩的问题？" class="headerlink" title="什么情况下会出现缓存雪崩？怎么防止缓存雪崩的问题？"></a>什么情况下会出现缓存雪崩？怎么防止缓存雪崩的问题？</h2><h2 id="怎么保证数据库和redis的一致性问题？"><a href="#怎么保证数据库和redis的一致性问题？" class="headerlink" title="怎么保证数据库和redis的一致性问题？"></a>怎么保证数据库和redis的一致性问题？</h2><h2 id="怎么解决用户禁言时间失效的问题？"><a href="#怎么解决用户禁言时间失效的问题？" class="headerlink" title="怎么解决用户禁言时间失效的问题？"></a>怎么解决用户禁言时间失效的问题？</h2><h2 id="介绍一下Java集合"><a href="#介绍一下Java集合" class="headerlink" title="介绍一下Java集合"></a>介绍一下Java集合</h2><h2 id="ArrayList是基于什么实现的？-从ArrayList和Array的区别出发）"><a href="#ArrayList是基于什么实现的？-从ArrayList和Array的区别出发）" class="headerlink" title="ArrayList是基于什么实现的？(从ArrayList和Array的区别出发）"></a>ArrayList是基于什么实现的？(从ArrayList和Array的区别出发）</h2><h2 id="ArrayList的怎么动态扩容的？"><a href="#ArrayList的怎么动态扩容的？" class="headerlink" title="ArrayList的怎么动态扩容的？"></a>ArrayList的怎么动态扩容的？</h2><h2 id="介绍一下JVM的内存区域（面试官其实是想要我自己说出来程序计数器、虚拟机栈等的作用。。。）"><a href="#介绍一下JVM的内存区域（面试官其实是想要我自己说出来程序计数器、虚拟机栈等的作用。。。）" class="headerlink" title="介绍一下JVM的内存区域（面试官其实是想要我自己说出来程序计数器、虚拟机栈等的作用。。。）"></a>介绍一下JVM的内存区域（面试官其实是想要我自己说出来程序计数器、虚拟机栈等的作用。。。）</h2><h2 id="程序计数器的作用"><a href="#程序计数器的作用" class="headerlink" title="程序计数器的作用"></a>程序计数器的作用</h2><h2 id="介绍一下垃圾回收算法"><a href="#介绍一下垃圾回收算法" class="headerlink" title="介绍一下垃圾回收算法"></a>介绍一下垃圾回收算法</h2><h2 id="MySQL的常用引擎"><a href="#MySQL的常用引擎" class="headerlink" title="MySQL的常用引擎?"></a>MySQL的常用引擎?</h2><h2 id="MYSQL如何实现MVCC的原理？（从ReadView角度回答）"><a href="#MYSQL如何实现MVCC的原理？（从ReadView角度回答）" class="headerlink" title="MYSQL如何实现MVCC的原理？（从ReadView角度回答）"></a>MYSQL如何实现MVCC的原理？（从ReadView角度回答）</h2><h2 id="Redis的浏览量怎么实现？"><a href="#Redis的浏览量怎么实现？" class="headerlink" title="Redis的浏览量怎么实现？"></a>Redis的浏览量怎么实现？</h2><h2 id="多线程的应用场景"><a href="#多线程的应用场景" class="headerlink" title="多线程的应用场景"></a>多线程的应用场景</h2><h2 id="如何创建线程池？为什么要使用线程池？"><a href="#如何创建线程池？为什么要使用线程池？" class="headerlink" title="如何创建线程池？为什么要使用线程池？"></a>如何创建线程池？为什么要使用线程池？</h2><h2 id="如何解决线程安全问题？"><a href="#如何解决线程安全问题？" class="headerlink" title="如何解决线程安全问题？"></a>如何解决线程安全问题？</h2><h2 id="了解自旋锁、乐观锁、悲观锁吗？（自旋锁不会。。。）"><a href="#了解自旋锁、乐观锁、悲观锁吗？（自旋锁不会。。。）" class="headerlink" title="了解自旋锁、乐观锁、悲观锁吗？（自旋锁不会。。。）"></a>了解自旋锁、乐观锁、悲观锁吗？（自旋锁不会。。。）</h2><h2 id="SpringBoot的常用注解"><a href="#SpringBoot的常用注解" class="headerlink" title="SpringBoot的常用注解"></a>SpringBoot的常用注解</h2><h2 id="Component和Bean注解的区别？"><a href="#Component和Bean注解的区别？" class="headerlink" title="Component和Bean注解的区别？"></a>Component和Bean注解的区别？</h2><h2 id="Spring的设计模式有哪些？"><a href="#Spring的设计模式有哪些？" class="headerlink" title="Spring的设计模式有哪些？"></a>Spring的设计模式有哪些？</h2><h2 id="怎么部署Java服务？"><a href="#怎么部署Java服务？" class="headerlink" title="怎么部署Java服务？"></a>怎么部署Java服务？</h2><h2 id="查看cpu、进程、内存命令"><a href="#查看cpu、进程、内存命令" class="headerlink" title="查看cpu、进程、内存命令"></a>查看cpu、进程、内存命令</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;最高QPS是承受多少？服务器部署位置？目前是单体应用？&quot;&gt;&lt;a href=&quot;#最高QPS是承受多少？服务器部署位置？目前是单体应用？&quot; class=&quot;headerlink&quot; title=&quot;最高QPS是承受多少？服务器部署位置？目前是单体应用？&quot;&gt;&lt;/a&gt;最高QPS</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-Lock</title>
    <link href="http://xiaobazeo.github.io/2023/06/10/MySQL-Lock/"/>
    <id>http://xiaobazeo.github.io/2023/06/10/MySQL-Lock/</id>
    <published>2023-06-10T04:28:54.000Z</published>
    <updated>2023-08-19T07:37:34.684Z</updated>
    
    
    
    
    
    <category term="MySQL" scheme="http://xiaobazeo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-Transaction</title>
    <link href="http://xiaobazeo.github.io/2023/06/01/MySQL-Transaction/"/>
    <id>http://xiaobazeo.github.io/2023/06/01/MySQL-Transaction/</id>
    <published>2023-06-01T04:27:42.000Z</published>
    <updated>2023-08-19T12:21:50.268Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务篇："><a href="#事务篇：" class="headerlink" title="事务篇："></a>事务篇：</h3><h4 id="事务的四大特性："><a href="#事务的四大特性：" class="headerlink" title="事务的四大特性："></a>事务的四大特性：</h4><p>1、原子性：一个事务要么全部完成要么全部不完成，不会结束在中间的某个环节而且事务再执行过程中发生错误，会被回滚到事务开始前的状态。</p><p>2、一致性：事务操作前后，数据满足完整性约束，数据库保持一致性状态。</p><p>比如：用户A和用户B在银行分别有800和600，总共1400元，用户A给用户B转账200元，分为两步，从A账户扣除200变成600，B账户增加200变成800，而不会出现A账户扣除，B账户没有增加的情况。</p><p>3、隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据的时候不会相互干扰，每个事务都有一个数据空间，对其他并发事务是隔离的。</p><p>比如：消费者之间的消费不会互相影响。</p><p>4、持久性：数据处理结束之后，对数据的修改永久化存储，即便系统故障也不会丢失</p><h4 id="并行事务引起的问题"><a href="#并行事务引起的问题" class="headerlink" title="并行事务引起的问题"></a>并行事务引起的问题</h4><ul><li><p>脏读</p><ul><li><p> 如果一个事务读到了另外一个事务未提交的修改过的数据，就是脏读。</p></li><li><p> 比如：事务A和事务B同时在处理，事务A对余额进行修改但是还没有提交，事务B此时读取数据，读到了事务A还没有提交的修改后的余额数据，此时就是出现了脏读，<strong>如果事务A此时因为某种原因触发回滚，导致余额回滚成初始值，那么事务B实际上获取到的就是过期的数据。</strong></p></li></ul></li><li><p>不可重复读</p><ul><li><p> 在一个事务中，多次读取同一个数据，结果出现前后两次数据不一样的情况，就是发生了不可重复读。</p></li><li><p> 比如：事务A和事务B在同时处理同一个数据，事务A先读取了一次这个数据，然后事务B修改了这个数据并提交，事务A再读取此数据，发现两次读取的数据不一样，就出现了不可重复度的情况。</p></li></ul></li><li><p>幻读</p><ul><li><p> 在一个事务中，多次查询符合某个条件的记录数量，出现前后两次记录数量不一致的情况就意味着发生了幻读。</p></li><li><p> 比如：事务A和事务B同时在处理，事务A先查询了大于100w的记录，然后事务B插入了一条200w的记录，并提交，此时事务A再次查询大于100w的记录，发现记录数量多了一条就发生了幻读。</p></li></ul></li></ul><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul><li>读未提交：一个事务还没有提交，他所做的变更就能被其他事务看到</li><li>读并提交：一个事务所做的变更在提交之后才能被其他事务看到</li><li>可重复读：一个事务执行过程中所看到的数据，一直跟这个事务启动时看到的数据一致</li><li>串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作的时候，如果发生了读写冲突，后访问的事务必须等前一个事务执行完成才会继续执行。</li></ul><h4 id="四种隔离级别具体是如何实现的呢？"><a href="#四种隔离级别具体是如何实现的呢？" class="headerlink" title="四种隔离级别具体是如何实现的呢？"></a>四种隔离级别具体是如何实现的呢？</h4><ul><li>读未提交：直接读取最新的数据即可。</li><li>串行化：添加读写锁避免并行访问</li><li>读提交：每次执行语句前都会重新生成一个ReadView。</li><li>可重复读：启动事务的时候创建一个ReadView，在这个事务内的多个语句操作都只会使用刚开始事务创建的那个Read View</li></ul><h4 id="Read-View在MVCC如何工作的？"><a href="#Read-View在MVCC如何工作的？" class="headerlink" title="Read View在MVCC如何工作的？"></a>Read View在MVCC如何工作的？</h4><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/8bf869f9f469ae4cccf625e3b6149a7.png" alt="8bf869f9f469ae4cccf625e3b6149a7"></p><p>聚簇索引记录中还有两个隐藏列，如下：</p><ul><li>trx_id，当一个事务对某条聚簇索引记录<strong>进行改动</strong>时，就会把<strong>该事务的事务 id 记录在 trx_id 隐藏列</strong>里。s</li><li>roll_pointer，每次对某条聚簇索引记录<strong>进行改动</strong>时，都会把旧版本的记录写入到 undo 日志中，然后这个<strong>隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/b9c22a2e97d0cf6b03142f28edef0d0.png" alt="b9c22a2e97d0cf6b03142f28edef0d0"></p><p>大概流程：当你访问一条记录时，数据库会根据该记录的事务 ID（trx_id）和你的 Read View 来确定你是否能看到这个记录。</p><ol><li><p>如果记录的 trx_id 小于 Read View 的 min_trx_id 值，说明这个记录在当前 Read View 创建之前就已经被提交，因此对当前事务可见。</p></li><li><p>如果记录的 trx_id 大于等于 Read View 的 max_trx_id 值，说明这个记录在当前 Read View 创建之后才被提交，因此对当前事务不可见。</p></li><li><p>如果记录的 trx_id 在 Read View 的 min_trx_id 和 max_trx_id 之间，那么需要检查这个 trx_id 是否在 Read View 的 m_ids 列表中：</p><p>a. 如果在 m_ids 列表中，说明这个事务是活跃的（还未提交），因此该记录对当前事务不可见。</p><p>b. 如果不在 m_ids 列表中，说明这个事务已经提交，因此该记录对当前事务可见。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事务篇：&quot;&gt;&lt;a href=&quot;#事务篇：&quot; class=&quot;headerlink&quot; title=&quot;事务篇：&quot;&gt;&lt;/a&gt;事务篇：&lt;/h3&gt;&lt;h4 id=&quot;事务的四大特性：&quot;&gt;&lt;a href=&quot;#事务的四大特性：&quot; class=&quot;headerlink&quot; title=&quot;事</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://xiaobazeo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用</title>
    <link href="http://xiaobazeo.github.io/2023/05/29/Docker%E4%BD%BF%E7%94%A8/"/>
    <id>http://xiaobazeo.github.io/2023/05/29/Docker%E4%BD%BF%E7%94%A8/</id>
    <published>2023-05-29T15:46:11.000Z</published>
    <updated>2023-05-29T16:25:48.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h2><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230529235020493.png" alt="image-20230529235020493"></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul><li>docker images</li></ul><blockquote><p>罗列出docker的所有的镜像相关信息</p></blockquote><ul><li>docker search 某个xxx镜像的名字</li></ul><blockquote><p>在hub仓库查询是否有相关的镜像 –limit 默认罗列前25个</p></blockquote><ul><li>docker pull 某个xxx镜像名[:tag]</li></ul><blockquote><p>tag:表示版本号    </p></blockquote><ul><li><p>docker system df 查看镜像/容器/数据卷所占空间</p></li><li><p>docker rmi 某个xxx镜像的id或者名字  -f强制删除</p><blockquote><p>docker rmi hello-world 或 docker rmi 9c7a54a9a43c<br>删除多个:</p><pre><code>docker rmi -f 镜像名1:tag 镜像名2:tag....docker rmi -f $(docker images -qa)</code></pre></blockquote><p>什么叫虚悬镜像？</p><p>仓库名、标签都是<none>的，俗称虚悬镜像，通常会把他删掉</none></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;帮助启动类命令&quot;&gt;&lt;a href=&quot;#帮助启动类命令&quot; class=&quot;headerlink&quot; title=&quot;帮助启动类命令&quot;&gt;&lt;/a&gt;帮助启动类命令&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://pengzihao166.oss-cn-beijing.aliy</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://xiaobazeo.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>微布开发-微信三方接口文本校验校验开发思路</title>
    <link href="http://xiaobazeo.github.io/2023/05/27/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%BE%AE%E4%BF%A1%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E6%96%87%E6%9C%AC%E6%A0%A1%E9%AA%8C%E6%A0%A1%E9%AA%8C%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/"/>
    <id>http://xiaobazeo.github.io/2023/05/27/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%BE%AE%E4%BF%A1%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E6%96%87%E6%9C%AC%E6%A0%A1%E9%AA%8C%E6%A0%A1%E9%AA%8C%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/</id>
    <published>2023-05-27T02:12:14.000Z</published>
    <updated>2023-08-03T02:42:13.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="根据文档要求总结分为以下的情况："><a href="#根据文档要求总结分为以下的情况：" class="headerlink" title="根据文档要求总结分为以下的情况："></a>根据文档要求总结分为以下的情况：</h3><ol><li>文本内容正常 (suggest: “pass”, label: 100)：<ol><li>情况处理：如果文本内容被判定为正常，可以允许发布该文本内容。</li></ol></li><li>文本内容命中关键词，但不违规 (suggest: “pass”, label: 20006)：<ol><li>情况处理：如果文本内容命中自定义关键词但不违规，可以允许发布该文本内容，同时可能根据需要记录命中的关键词和概率信息。</li></ol></li><li>文本内容建议审核 (suggest: “review”)：<ol><li>情况处理：如果文本内容被建议进行审核，您可以将该内容设置为待审核状态，让人工审核来决定是否发布该内容。</li></ol></li><li>文本内容命中违规标签 (suggest: “risky”)：<ol><li>情况处理：如果文本内容被判定为违规，应禁止发布该内容，并通知用户违规原因。</li></ol></li><li>文本内容属于广告 (label: 10001)：<ol><li>情况处理：如果文本内容被判定为广告，应禁止发布该内容，并通知用户不允许发布广告内容。</li></ol></li><li>文本内容属于色情、辱骂、违法犯罪等 (label: 20002, 20003, 20006等)：<ol><li>情况处理：如果文本内容被判定为色情、辱骂、违法犯罪等，应禁止发布该内容，并根据需要采取进一步的处理措施，比如记录日志或进行用户封禁等。</li></ol></li></ol><h3 id="开发思路如下："><a href="#开发思路如下：" class="headerlink" title="开发思路如下："></a>开发思路如下：</h3><ol><li>从Redis中获取到AccessToken</li><li>查库获取发布者微信的openid</li><li>调用<a href="https://api.weixin.qq.com/wxa/msg_sec_check?access_token=%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%A0%A1%E9%AA%8C%E8%BF%94%E5%9B%9E%E5%8F%82%E6%95%B0">https://api.weixin.qq.com/wxa/msg_sec_check?access_token=接口，校验返回参数</a><ol><li>errocode == 0<ol><li>获取result对象的suggest参数值并进行比较<ol><li>如果文本内容建议审核，则根据实际需求执行人工审核流程，”review”.equals(suggest)</li><li>如果文本内容正常或命中关键词但不违规，允许发布，”pass”.equals(suggest)</li><li>如果文本内容被判定为违规，禁止发布，并输出违规信息，”risky”.equals(suggest)<ol><li>此时可以遍历detail数组，并获取对应的prob如果其中有敏感词汇prob&gt;50就不准发布。</li></ol></li></ol></li></ol></li></ol></li></ol><h3 id="大致代码逻辑如下："><a href="#大致代码逻辑如下：" class="headerlink" title="大致代码逻辑如下："></a>大致代码逻辑如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(String result)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">JSONObject</span> <span class="variable">responseJson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(result);</span><br><span class="line">          <span class="type">int</span> <span class="variable">errcode</span> <span class="operator">=</span> responseJson.getInt(<span class="string">&quot;errcode&quot;</span>);</span><br><span class="line">          <span class="type">String</span> <span class="variable">errmsg</span> <span class="operator">=</span> responseJson.getString(<span class="string">&quot;errmsg&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (errcode == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 获取综合结果信息</span></span><br><span class="line">              <span class="type">JSONObject</span> <span class="variable">resultObject</span> <span class="operator">=</span> responseJson.getJSONObject(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">              <span class="type">String</span> <span class="variable">suggest</span> <span class="operator">=</span> resultObject.getString(<span class="string">&quot;suggest&quot;</span>);</span><br><span class="line">              <span class="type">int</span> <span class="variable">label</span> <span class="operator">=</span> resultObject.getInt(<span class="string">&quot;label&quot;</span>);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 输出综合结果信息</span></span><br><span class="line">              System.out.println(<span class="string">&quot;综合结果：&quot;</span>);</span><br><span class="line">              System.out.println(<span class="string">&quot;建议：&quot;</span> + suggest);</span><br><span class="line">              System.out.println(<span class="string">&quot;标签：&quot;</span> + label);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果文本内容建议审核，则根据实际需求执行人工审核流程</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="string">&quot;review&quot;</span>.equals(suggest)) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;该文本内容建议进行人工审核！&quot;</span>);</span><br><span class="line">                  <span class="comment">// 可以将内容设置为待审核状态，由人工审核决定是否发布</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;pass&quot;</span>.equals(suggest)) &#123;</span><br><span class="line">                  <span class="comment">// 如果文本内容正常或命中关键词但不违规，允许发布</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;文本内容合规，可以发布！&quot;</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;risky&quot;</span>.equals(suggest)) &#123;</span><br><span class="line">                  <span class="comment">// 如果文本内容被判定为违规，禁止发布，并输出违规信息</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;文本内容违规，请修改后重新提交！&quot;</span>);</span><br><span class="line">                  <span class="type">JSONArray</span> <span class="variable">detailArray</span> <span class="operator">=</span> responseJson.getJSONArray(<span class="string">&quot;detail&quot;</span>);</span><br><span class="line">                  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; detailArray.length(); i++) &#123;</span><br><span class="line">                      <span class="type">JSONObject</span> <span class="variable">detailObject</span> <span class="operator">=</span> detailArray.getJSONObject(i);</span><br><span class="line">                      <span class="type">String</span> <span class="variable">strategy</span> <span class="operator">=</span> detailObject.getString(<span class="string">&quot;strategy&quot;</span>);</span><br><span class="line">                      <span class="keyword">if</span> (<span class="string">&quot;keyword&quot;</span>.equals(strategy)) &#123;</span><br><span class="line">                          <span class="type">String</span> <span class="variable">keyword</span> <span class="operator">=</span> detailObject.getString(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">                          <span class="type">int</span> <span class="variable">prob</span> <span class="operator">=</span> detailObject.getInt(<span class="string">&quot;prob&quot;</span>);</span><br><span class="line">                          System.out.println(<span class="string">&quot;命中关键词：&quot;</span> + keyword + <span class="string">&quot;，概率：&quot;</span> + prob);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;未知建议类型：&quot;</span> + suggest);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 输出错误信息</span></span><br><span class="line">              System.out.println(<span class="string">&quot;接口调用失败，错误码：&quot;</span> + errcode + <span class="string">&quot;，错误信息：&quot;</span> + errmsg);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;接口调用失败！&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;根据文档要求总结分为以下的情况：&quot;&gt;&lt;a href=&quot;#根据文档要求总结分为以下的情况：&quot; class=&quot;headerlink&quot; title=&quot;根据文档要求总结分为以下的情况：&quot;&gt;&lt;/a&gt;根据文档要求总结分为以下的情况：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;文本内容正常 (</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>备份hexo-_o-U盘篇</title>
    <link href="http://xiaobazeo.github.io/2023/05/16/%E5%A4%87%E4%BB%BDhexo-o-U%E7%9B%98%E7%AF%87/"/>
    <id>http://xiaobazeo.github.io/2023/05/16/%E5%A4%87%E4%BB%BDhexo-o-U%E7%9B%98%E7%AF%87/</id>
    <published>2023-05-16T07:06:32.000Z</published>
    <updated>2023-08-03T02:21:34.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新机环境搭建"><a href="#新机环境搭建" class="headerlink" title="新机环境搭建"></a>新机环境搭建</h2><p>​    1、安装Node.js</p><p>​    2、安装Git</p><p>​    3、新建存放Blog的文件夹</p><h2 id="拷贝旧机器中得文件-文件夹"><a href="#拷贝旧机器中得文件-文件夹" class="headerlink" title="拷贝旧机器中得文件/文件夹"></a>拷贝旧机器中得文件/文件夹</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line"><span class="keyword">package</span>.json</span><br><span class="line">scaffolds/</span><br><span class="line"><span class="keyword">source</span>/</span><br><span class="line">themes/</span><br><span class="line">其中/代表拷贝的是文件夹</span><br></pre></td></tr></table></figure><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>右键打开Git bash，依次输入下列命令之后，安装相关依赖</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>安装hexo</span><br><span class="line">   <span class="built_in">npm</span> install -g hexo</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>本地测试的时候需要用hexo server</span><br><span class="line">   <span class="built_in">npm</span> i hexo-server</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>将文章部署到github上的模块</span><br><span class="line">   <span class="built_in">npm</span> install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>安装RSS插件</span><br><span class="line">   <span class="built_in">npm</span> install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>添加Sitemap,加速网页收录速度</span><br><span class="line">   <span class="built_in">npm</span> install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><h2 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s -g == hexo g + hexo s</span><br></pre></td></tr></table></figure><p>在浏览器打开<a href="http://localhost:4000/">http://localhost:4000</a>查看效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新机环境搭建&quot;&gt;&lt;a href=&quot;#新机环境搭建&quot; class=&quot;headerlink&quot; title=&quot;新机环境搭建&quot;&gt;&lt;/a&gt;新机环境搭建&lt;/h2&gt;&lt;p&gt;​    1、安装Node.js&lt;/p&gt;
&lt;p&gt;​    2、安装Git&lt;/p&gt;
&lt;p&gt;​    3、新建存</summary>
      
    
    
    
    
    <category term="程序人生" scheme="http://xiaobazeo.github.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>网络基础篇</title>
    <link href="http://xiaobazeo.github.io/2023/05/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://xiaobazeo.github.io/2023/05/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2023-05-15T18:25:03.000Z</published>
    <updated>2023-05-16T08:27:01.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP网络模型有哪几层？"><a href="#TCP-IP网络模型有哪几层？" class="headerlink" title="TCP/IP网络模型有哪几层？"></a>TCP/IP网络模型有哪几层？</h2><h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><p>&emsp;&emsp;用户直接接触到的就是<strong>应用层</strong>，应用层专注于用户提供应用功能，例如：HTTP、FTP、DNS、Telnet、SMTP等。</p><p>&emsp;&emsp;应用层工作在操作系统中得<strong>用户态</strong>，<strong>传输层及以下</strong>则工作在<strong>内核态</strong>。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>&emsp;&emsp;应用层的数据包会传给传输层，传输层是为应用层提供网络支持。传输层的两个协议：<strong>TCP</strong>和<strong>UDP</strong>。</p><p>&emsp;&emsp;TCP（传输控制协议），TCP相较于UDP的特性，比如：<strong>流量控制，超时重传，拥塞控制</strong>等，为了保证数据包能可靠的传输给对方。</p><p>&emsp;&emsp;UDP只负责发送数据包，<strong>不保证</strong>数据包是否能抵达对方，但是<strong>实时性</strong>相对较好，<strong>传输效率</strong>也较高。如果要实现UDP的可靠传输，可以把TCP的特性在应用层实现。</p><p>&emsp;&emsp;应用传输数据过大，传输层的数据包大小超过MSS(TCP最大报文段长度)，需要将数据包分块，如果中途有一个分块丢失或损坏，只需重新发送此分块即可，而不需要发送整个数据包。在TCP协议中，<strong>每个分块称为一个TCP段</strong>（TCP Segment）。</p><p>&emsp;&emsp;传输层负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，此时需要用一个编号将应用区分开，这个编号就是端口。例如：Web服务器通常使用80端口，22端口通常是远程登录服务器的端口。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>&emsp;&emsp;实现传输功能的是<strong>网络层</strong>，传输层只是作为数据传输的媒介，帮助应用到应用的通信。</p><p>&emsp;&emsp;常见协议是IP协议（Internet Protocol），IP协议会将传输层的报文作为数据部分，再加上IP包头部组装成IP报文，如果IP报文大小超过MTU（一般默认1500Bytes）会<strong>再次进行分片</strong>，得到一个即将发送的到网络的IP报文。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/12.jpg" alt="选自小林coding"></p><h4 id="IP协议寻址功能："><a href="#IP协议寻址功能：" class="headerlink" title="IP协议寻址功能："></a>IP协议寻址功能：</h4><p>&emsp;&emsp;由于网络层需要有区分设备的编号，一般使用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分为四段（比如：192.168.100.1），每段8位。由于IPv4地址有设备上限，无法做到一个设备一个IP地址，所以会将IP地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该IP地址是属于哪个<strong>子网</strong>的</li><li>一个是<strong>主机号</strong>，负责标识<strong>同一子网</strong>下的<strong>不同主机</strong></li></ul><p>此时需要<strong>子网掩码</strong>才能计算出IP地址的网络号和主机号，比如：10.100.122.0/24，后面的/24表示就是255.255.255.0子网掩码，255.255.255.0二进制就是11111111-11111111-11111111-00000000，24个1，为了简化子网掩码的表示，就会用/24代替255.255.255.0</p><p><strong>网络号</strong>将 10.100.122.2 和 255.255.255.0 <strong>按位与运算</strong>。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/16.jpg" alt="取自小林coding"></p><p><strong>主机号：</strong>将 255.255.255.0 <strong>取反</strong>后与IP地址进行进行<strong>按位与运算</strong>。</p><p>在寻址过程中，先匹配相同的网络号（表示要找到同一个子网），才会去找对应的主机号。</p><h4 id="IP协议路由功能"><a href="#IP协议路由功能" class="headerlink" title="IP协议路由功能"></a>IP协议路由功能</h4><p>当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p><p>IP协议的寻址是告诉我们去往下一个目的地朝哪个方向走，路由是根据下一个目的地选择路径。</p><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>网络接口层会在IP头部的前面加上MAC头部，并封装成数据帧发送到网络上。网络接口层主要是为网络层提供链路级别传输的服务，负责以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来表示网络上的设备。</p><p>MAC头部是以以太网的头部，包含了接收方和发送方的MAC地址等信息，可以通过ARP协议获取对方的MAC地址。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络接口层的传输单位是帧，IP的传输单位是包，TCP层传输单位是段，HTTP传输单位是消息或报文，每一层的封装格式如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="取自小林coding"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP-IP网络模型有哪几层？&quot;&gt;&lt;a href=&quot;#TCP-IP网络模型有哪几层？&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP网络模型有哪几层？&quot;&gt;&lt;/a&gt;TCP/IP网络模型有哪几层？&lt;/h2&gt;&lt;h3 id=&quot;应用层：&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="计网" scheme="http://xiaobazeo.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
</feed>
