<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HUT菜鸟小八的博客</title>
  
  
  <link href="http://xiaobazeo.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaobazeo.github.io/"/>
  <updated>2023-09-29T14:42:36.305Z</updated>
  <id>http://xiaobazeo.github.io/</id>
  
  <author>
    <name>xiaoba</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go-Grammar</title>
    <link href="http://xiaobazeo.github.io/2023/09/29/Go-Grammar/"/>
    <id>http://xiaobazeo.github.io/2023/09/29/Go-Grammar/</id>
    <published>2023-09-29T07:42:44.000Z</published>
    <updated>2023-09-29T14:42:36.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p>Go语言设计的关键字，了解这些关键字有助于命名变量的冲突避免</p><h3 id="go的二十五个关键字"><a href="#go的二十五个关键字" class="headerlink" title="go的二十五个关键字"></a>go的二十五个关键字</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>    <span class="keyword">default</span>      func    <span class="keyword">interface</span>    <span class="symbol">select</span></span><br><span class="line"><span class="symbol">case</span>     <span class="symbol">defer</span>        <span class="symbol">go</span>      <span class="symbol">map</span>          <span class="symbol">struct</span></span><br><span class="line"><span class="symbol">chan</span>     <span class="symbol">else</span>         <span class="symbol">goto</span>    <span class="symbol">package</span>      <span class="symbol">switch</span></span><br><span class="line"><span class="symbol">const</span>    <span class="symbol">fallthrough</span>  <span class="symbol">if</span>      <span class="symbol">range</span>        <span class="symbol">type</span></span><br><span class="line"><span class="symbol">continue</span> <span class="symbol">for</span>          <span class="symbol">import</span>  <span class="symbol">return</span>       <span class="symbol">var</span></span><br></pre></td></tr></table></figure><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li><p><code>var</code>和<code>const</code> 是 Go语言基础里面的变量和常量申明</p></li><li><p><code>package</code>和<code>import</code> 用于分包和导入</p></li><li><p><code>func</code> 用于定义函数和方法</p></li><li><p><code>return</code> 用于从函数返回</p></li><li><p><code>defer</code> 用于类似析构函数</p></li><li><p><code>go</code> 用于并发</p></li><li><p><code>select</code> 用于选择不同类型的通讯</p></li><li><p><code>interface</code> 用于定义接口</p></li><li><p><code>struct</code> 用于定义抽象数据类型</p></li><li><p><code>break</code>、<code>case</code>、<code>continue</code>、<code>for</code>、<code>fallthrough</code>、<code>else</code>、<code>if</code>、<code>switch</code>、<code>goto</code>、<code>default</code> 用于流程控制</p></li><li><p><code>chan</code>用于channel通讯</p></li><li><p><code>type</code>用于声明自定义类型</p></li><li><p><code>map</code>用于声明map类型数据</p></li><li><p><code>range</code>用于读取slice、map、channel数据</p></li></ul><h1 id="数据类型的定义"><a href="#数据类型的定义" class="headerlink" title="数据类型的定义"></a>数据类型的定义</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>Go语言里面定义变量有多种方式。</p><p>使用<code>var</code>关键字是Go最基本的定义变量方式，与C语言不同的是Go把变量类型放在变量名后面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名称为“variableName”，类型为&quot;type&quot;的变量</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>定义多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义三个类型都是“type”的变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>定义变量并初始化值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化“variableName”的变量为“value”值，类型是“type”</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span> = value</span><br></pre></td></tr></table></figure><p>同时初始化多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个类型都是&quot;type&quot;的变量,并且分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span>= v1, v2, v3</span><br></pre></td></tr></table></figure><p>是不是觉得上面这样的定义有点繁琐？有一种写法可以让它变得简单一点。可以直接忽略类型声明，那么上面的代码变成这样了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">    然后Go会根据其相应值的类型来初始化它们</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3</span><br></pre></td></tr></table></figure><p>觉得上面的还是有些繁琐，继续简化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line"><span class="comment">    vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">    编译器会根据初始化的值自动推导出相应的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3</span><br></pre></td></tr></table></figure><p>现在是不是看上去非常简洁了？<code>:=</code>这个符号直接取代了<code>var</code>和<code>type</code>,这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用<code>var</code>方式来定义全局变量。</p><p><code>_</code>（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，将值<code>35</code>赋予<code>b</code>，并同时丢弃<code>34</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, b := <span class="number">34</span>, <span class="number">35</span></span><br></pre></td></tr></table></figure><p>Go对于已声明但未使用的变量会在编译阶段报错，比如下面的代码就会产生一个错误：声明了<code>i</code>但未使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在Go程序中，常量可定义为数值、布尔值或字符串等类型。</p><p>它的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> constantName = value</span><br><span class="line"><span class="comment">//如果需要，也可以明确指定常量的类型：</span></span><br><span class="line"><span class="keyword">const</span> Pi <span class="type">float32</span> = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure><p>下面是一些常量声明的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">10000</span></span><br><span class="line"><span class="keyword">const</span> MaxThread = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;astaxie_&quot;</span></span><br></pre></td></tr></table></figure><p>Go 常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)，若指定给<code>float32</code>自动缩短为<code>32bit</code>，指定给<code>float64</code>自动缩短为<code>64bit</code>，详情参考 <code>http://golang.org/ref/spec#Constants</code> (需科学上网)</p><h2 id="内置基础类型"><a href="#内置基础类型" class="headerlink" title="内置基础类型"></a>内置基础类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>在Go中，布尔值的类型为<code>bool</code>，值是<code>true</code>或<code>false</code>，默认为<code>false</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> isActive <span class="type">bool</span>  <span class="comment">// 全局变量声明</span></span><br><span class="line"><span class="keyword">var</span> enabled, disabled = <span class="literal">true</span>, <span class="literal">false</span>  <span class="comment">// 忽略类型的声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> available <span class="type">bool</span>  <span class="comment">// 一般声明</span></span><br><span class="line">    valid := <span class="literal">false</span>      <span class="comment">// 简短声明</span></span><br><span class="line">    available = <span class="literal">true</span>    <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>整数类型有无符号和带符号两种。Go同时支持<code>int</code>和<code>uint</code>，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：<code>rune</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>和<code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>。其中<code>rune</code>是<code>int32</code>的别称，<code>byte</code>是<code>uint8</code>的别称。</p><p>需要注意的一点是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器报错。</p><p>如下的代码会产生错误：invalid operation: a + b (mismatched types int8 and int32)</p><p>var a int8</p><p>var b int32</p><p>c:=a + b</p><p>另外，尽管int的长度是32 bit, 但int 与 int32并不可以互用。</p><p>浮点数的类型有<code>float32</code>和<code>float64</code>两种（没有<code>float</code>类型），默认是<code>float64</code>。</p><p>Go还支持复数。它的默认类型是<code>complex128</code>（64位实数+64位虚数）。如果需要小一些的，也有<code>complex64</code>(32位实数+32位虚数)。复数的形式为<code>RE + IMi</code>，其中<code>RE</code>是实数部分，<code>IM</code>是虚数部分，而最后的<code>i</code>是虚数单位。下面是一个使用复数的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="type">complex64</span> = <span class="number">5</span>+<span class="number">5i</span></span><br><span class="line"><span class="comment">//output: (5+5i)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Value is: %v&quot;</span>, c)</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Go中的字符串都是采用<code>UTF-8</code>字符集编码。字符串是用一对双引号（<code>&quot;&quot;</code>）或反引号（<code> </code>）括起来定义，它的类型是<code>string</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> frenchHello <span class="type">string</span>  <span class="comment">// 声明变量为字符串的一般方法</span></span><br><span class="line"><span class="keyword">var</span> emptyString <span class="type">string</span> = <span class="string">&quot;&quot;</span>  <span class="comment">// 声明了一个字符串变量，初始化为空字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    no, yes, maybe := <span class="string">&quot;no&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;maybe&quot;</span>  <span class="comment">// 简短声明，同时声明多个变量</span></span><br><span class="line">    japaneseHello := <span class="string">&quot;Konichiwa&quot;</span>  <span class="comment">// 同上</span></span><br><span class="line">    frenchHello = <span class="string">&quot;Bonjour&quot;</span>  <span class="comment">// 常规赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><p>但如果真的想要修改怎么办呢？下面的代码可以实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">c := []<span class="type">byte</span>(s)  <span class="comment">// 将字符串 s 转换为 []byte 类型</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">s2 := <span class="type">string</span>(c)  <span class="comment">// 再转换回 string 类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s2)</span><br></pre></td></tr></table></figure><p>Go中可以使用<code>+</code>操作符来连接两个字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello,&quot;</span></span><br><span class="line">m := <span class="string">&quot; world&quot;</span></span><br><span class="line">a := s + m</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, a)</span><br></pre></td></tr></table></figure><p>修改字符串也可写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s = <span class="string">&quot;c&quot;</span> + s[<span class="number">1</span>:] <span class="comment">// 字符串虽不能更改，但可进行切片操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure><p>如果要声明一个多行的字符串怎么办？可以通过```来声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="string">`hello</span></span><br><span class="line"><span class="string">    world`</span></span><br></pre></td></tr></table></figure><p>``` 括起的字符串为<code>Raw</code>字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。例如本例中会输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">    world</span><br></pre></td></tr></table></figure><h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><p>Go内置有一个<code>error</code>类型，专门用来处理错误信息，Go的<code>package</code>里面还专门有一个包<code>errors</code>来处理错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;emit macho dwarf: elf header corrupted&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组声明"><a href="#分组声明" class="headerlink" title="分组声明"></a>分组声明</h2><p>在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明。</p><p>例如下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;Go_&quot;</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> pi <span class="type">float32</span></span><br><span class="line"><span class="keyword">var</span> prefix <span class="type">string</span></span><br></pre></td></tr></table></figure><p>可以分组写成如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    i = <span class="number">100</span></span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    prefix = <span class="string">&quot;Go_&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">    i <span class="type">int</span></span><br><span class="line">    pi <span class="type">float32</span></span><br><span class="line">    prefix <span class="type">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="iota枚举"><a href="#iota枚举" class="headerlink" title="iota枚举"></a>iota枚举</h2><p>Go里面有一个关键字<code>iota</code>，这个关键字用来声明<code>enum</code>的时候采用，它默认开始值是0，const中每增加一行加1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    x = <span class="literal">iota</span> <span class="comment">// x == 0</span></span><br><span class="line">    y = <span class="literal">iota</span> <span class="comment">// y == 1</span></span><br><span class="line">    z = <span class="literal">iota</span> <span class="comment">// z == 2</span></span><br><span class="line">    w        <span class="comment">// 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> v = <span class="literal">iota</span> <span class="comment">// 每遇到一个const关键字，iota就会重置，此时v == 0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    h, i, j = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//h=0,i=0,j=0 iota在同一行值相同</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a       = <span class="literal">iota</span> <span class="comment">//a=0</span></span><br><span class="line">    b       = <span class="string">&quot;B&quot;</span></span><br><span class="line">    c       = <span class="literal">iota</span>             <span class="comment">//c=2</span></span><br><span class="line">    d, e, f = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//d=3,e=3,f=3</span></span><br><span class="line">    g       = <span class="literal">iota</span>             <span class="comment">//g = 4</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非被显式设置为其它值或<code>iota</code>，每个<code>const</code>分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是<code>iota</code>，则它也被设置为<code>iota</code>。</p><h2 id="Go程序设计的一些规则"><a href="#Go程序设计的一些规则" class="headerlink" title="Go程序设计的一些规则"></a>Go程序设计的一些规则</h2><p>Go之所以会那么简洁，是因为它有一些默认的行为：</p><ul><li>大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。</li><li>大写字母开头的函数也是一样，相当于<code>class</code>中的带<code>public</code>关键词的公有函数；小写字母开头的就是有<code>private</code>关键词的私有函数。</li></ul><h2 id="array、slice、map"><a href="#array、slice、map" class="headerlink" title="array、slice、map"></a><code>array</code>、<code>slice</code>、<code>map</code></h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a><code>array</code></h3><p><code>array</code>就是数组，它的定义方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [n]<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>在<code>[n]type</code>中，<code>n</code>表示数组的长度，<code>type</code>表示存储元素的类型。对数组的操作和其它语言类似，都是通过<code>[]</code>来进行读取或赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="type">int</span>  <span class="comment">// 声明了一个int类型的数组</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">42</span>      <span class="comment">// 数组下标是从0开始的</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">13</span>      <span class="comment">// 赋值操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The first element is %d\n&quot;</span>, arr[<span class="number">0</span>])  <span class="comment">// 获取数据，返回42</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The last element is %d\n&quot;</span>, arr[<span class="number">9</span>]) <span class="comment">//返回未赋值的最后一个元素，默认返回0</span></span><br></pre></td></tr></table></figure><p>由于长度也是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的<code>slice</code>类型了。</p><p>数组可以使用另一种<code>:=</code>来声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为3的int数组</span></span><br><span class="line">b := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0</span></span><br><span class="line">c := [...]<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度</span></span><br></pre></td></tr></table></figure><p>Go支持嵌套数组，即多维数组。比如下面的代码就声明了一个二维数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span></span><br><span class="line">doubleArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="type">int</span>&#123;[<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line"><span class="comment">// 上面的声明可以简化，直接忽略内部的类型</span></span><br><span class="line">easyArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a><code>slice</code></h3><p>在很多应用场景中，数组并不能满足需求。在初始定义数组时，并不知道需要多大的数组，因此就需要“动态数组”。在Go里面这种数据结构叫<code>slice</code></p><p><code>slice</code>并不是真正意义上的动态数组，而是一个引用类型。<code>slice</code>总是指向一个底层<code>array</code>，<code>slice</code>的声明也可以像<code>array</code>一样，只是不需要长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和声明array一样，只是少了长度</span></span><br><span class="line"><span class="keyword">var</span> fslice []<span class="type">int</span></span><br></pre></td></tr></table></figure><p>接下来可以声明一个<code>slice</code>，并初始化数据，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="type">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p><code>slice</code>可以从一个数组或一个已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>array[i:j]</code>来获取，其中<code>i</code>是数组的开始位置，<code>j</code>是结束位置，但不包含<code>array[j]</code>，它的长度是<code>j-i</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个含有10个元素元素类型为byte的数组</span></span><br><span class="line"><span class="keyword">var</span> ar = [<span class="number">10</span>]<span class="type">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个含有byte的slice</span></span><br><span class="line"><span class="keyword">var</span> a, b []<span class="type">byte</span></span><br><span class="line"><span class="comment">// a指向数组的第3个元素开始，并到第五个元素结束，</span></span><br><span class="line">a = ar[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">//现在a含有的元素: ar[2]、ar[3]和ar[4]</span></span><br><span class="line"><span class="comment">// b是数组ar的另一个slice</span></span><br><span class="line">b = ar[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// b的元素是：ar[3]和ar[4]</span></span><br></pre></td></tr></table></figure><p>注意<code>slice</code>和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用<code>...</code>自动计算长度，而声明<code>slice</code>时，方括号内没有任何字符。</p><h4 id="slice有一些简便的操作"><a href="#slice有一些简便的操作" class="headerlink" title="slice有一些简便的操作"></a><code>slice</code>有一些简便的操作</h4><ul><li><p><code>slice</code>的默认开始位置是0，<code>ar[:n]</code>等价于<code>ar[0:n]</code></p></li><li><p><code>slice</code>的第二个序列默认是数组的长度，<code>ar[n:]</code>等价于<code>ar[n:len(ar)]</code></p></li><li><p>如果从一个数组里面直接获取<code>slice</code>，可以这样<code>ar[:]</code>，因为默认第一个序列是0，第二个是数组的长度，即等价于<code>ar[0:len(ar)]</code></p></li></ul><p>下面这个例子展示了更多关于<code>slice</code>的操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>]<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个slice</span></span><br><span class="line"><span class="keyword">var</span> aSlice, bSlice []<span class="type">byte</span></span><br><span class="line"><span class="comment">// 演示一些简便操作</span></span><br><span class="line">aSlice = array[:<span class="number">3</span>] <span class="comment">// 等价于aSlice = array[0:3] aSlice包含元素: a,b,c</span></span><br><span class="line">aSlice = array[<span class="number">5</span>:] <span class="comment">// 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j</span></span><br><span class="line">aSlice = array[:]  <span class="comment">// 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素</span></span><br><span class="line"><span class="comment">// 从slice中获取slice</span></span><br><span class="line">aSlice = array[<span class="number">3</span>:<span class="number">7</span>]  <span class="comment">// aSlice包含元素: d,e,f,g，len=4，cap=7</span></span><br><span class="line">bSlice = aSlice[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f</span></span><br><span class="line">bSlice = aSlice[:<span class="number">3</span>]  <span class="comment">// bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f</span></span><br><span class="line">bSlice = aSlice[<span class="number">0</span>:<span class="number">5</span>] <span class="comment">// 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h</span></span><br><span class="line">bSlice = aSlice[:]   <span class="comment">// bSlice包含所有aSlice的元素: d,e,f,g</span></span><br></pre></td></tr></table></figure><p><code>slice</code>是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的<code>aSlice</code>和<code>bSlice</code>，如果修改了<code>aSlice</code>中元素的值，那么<code>bSlice</code>相对应的值也会改变。</p><p>从概念上面来说<code>slice</code>像一个结构体，这个结构体包含了三个元素：</p><ul><li><p>一个指针，指向数组中<code>slice</code>指定的开始位置</p></li><li><p>长度，即<code>slice</code>的长度</p></li><li><p>最大长度，也就是<code>slice</code>开始位置到数组的最后位置的长度</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array_a := [<span class="number">10</span>]<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line">    Slice_a := Array_a[<span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h4 id="slice有几个有用的内置函数"><a href="#slice有几个有用的内置函数" class="headerlink" title="slice有几个有用的内置函数"></a><code>slice</code>有几个有用的内置函数</h4><ul><li><p><code>len</code> 获取<code>slice</code>的长度</p></li><li><p><code>cap</code> 获取<code>slice</code>的最大容量</p></li><li><p><code>append</code> 向<code>slice</code>里面追加一个或者多个元素，然后返回一个和<code>slice</code>一样类型的<code>slice</code></p></li><li><p><code>copy</code> 函数<code>copy</code>从源<code>slice</code>的<code>src</code>中复制元素到目标<code>dst</code>，并且返回复制的元素的个数</p></li></ul><p>注：<code>append</code>函数会改变<code>slice</code>所引用的数组的内容，从而影响到引用同一数组的其它<code>slice</code>。</p><p>但当<code>slice</code>中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的<code>slice</code>数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的<code>slice</code>则不受影响。</p><p>从Go1.2开始<code>slice</code>支持了三个参数的<code>slice</code>，之前一直采用这种方式在<code>slice</code>或者<code>array</code>基础上来获取一个<code>slice</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line">slice := array[<span class="number">2</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>这个例子里面slice的容量是8，新版本里面可以指定这个容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice = array[<span class="number">2</span>:<span class="number">4</span>:<span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>上面这个的容量就是<code>7-2</code>，即5。这样这个产生的新的<code>slice</code>就没办法访问最后的三个元素。</p><p>如果<code>slice</code>是这样的形式<code>array[:i:j]</code>，即第一个参数为空，默认值就是0。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span><span class="string">`也就是Python中字典的概念，它的格式为`</span><span class="keyword">map</span>[keyType]valueType</span><br></pre></td></tr></table></figure><p>看下面的代码，<code>map</code>的读取和设置也类似<code>slice</code>一样，通过<code>key</code>来操作，只是<code>slice</code>的<code>index</code>只能是｀int｀类型，而<code>map</code>多了很多类型，可以是<code>int</code>，可以是<code>string</code>及所有完全定义了<code>==</code>与<code>!=</code>操作的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化</span></span><br><span class="line"><span class="keyword">var</span> numbers <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"><span class="comment">// 另一种map的声明方式</span></span><br><span class="line">numbers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">numbers[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>  <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">&quot;ten&quot;</span>] = <span class="number">10</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">&quot;three&quot;</span>] = <span class="number">3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;第三个数字是: &quot;</span>, numbers[<span class="string">&quot;three&quot;</span>]) <span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 打印出来如:第三个数字是: 3</span></span><br></pre></td></tr></table></figure><p>这个<code>map</code>就像平常看到的表格一样，左边列是<code>key</code>，右边列是值</p><p>使用<code>map</code>过程中需要注意的几点：</p><ul><li><p><code>map</code>是无序的，每次打印出来的<code>map</code>都会不一样，它不能通过<code>index</code>获取，而必须通过<code>key</code>获取</p></li><li><p><code>map</code>的长度是不固定的，也就是和<code>slice</code>一样，也是一种引用类型</p></li><li><p>内置的<code>len</code>函数同样适用于<code>map</code>，返回<code>map</code>拥有的<code>key</code>的数量</p></li><li><p><code>map</code>的值可以很方便的修改，通过<code>numbers[&quot;one&quot;]=11</code>可以很容易的把key为<code>one</code>的字典值改为<code>11</code></p></li><li><p><code>map</code>和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</p></li></ul><p><code>map</code>的初始化可以通过<code>key:val</code>的方式初始化值，同时<code>map</code>内置有判断是否存在<code>key</code>的方式</p><p>通过<code>delete</code>删除<code>map</code>的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个字典</span></span><br><span class="line">rating := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">float32</span>&#123;<span class="string">&quot;C&quot;</span>:<span class="number">5</span>, <span class="string">&quot;Go&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;Python&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;C++&quot;</span>:<span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true</span></span><br><span class="line">csharpRating, ok := rating[<span class="string">&quot;C#&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;C# is in the map and its rating is &quot;</span>, csharpRating)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;We have no rating associated with C# in the map&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(rating, <span class="string">&quot;C&quot;</span>)  <span class="comment">// 删除key为C的元素</span></span><br></pre></td></tr></table></figure><p>上面说过了，<code>map</code>也是一种引用类型，如果两个<code>map</code>同时指向一个底层，那么一个改变，另一个也相应的改变：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">m[<span class="string">&quot;Hello&quot;</span>] = <span class="string">&quot;Bonjour&quot;</span></span><br><span class="line">m1 := m</span><br><span class="line">m1[<span class="string">&quot;Hello&quot;</span>] = <span class="string">&quot;Salut&quot;</span>  <span class="comment">// 现在m[&quot;hello&quot;]的值已经是Salut了</span></span><br></pre></td></tr></table></figure><h2 id="make、new操作"><a href="#make、new操作" class="headerlink" title="make、new操作"></a><code>make</code>、<code>new</code>操作</h2><p><code>make</code>用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配。<code>new</code>用于各种类型的内存分配。</p><p>内建函数<code>new</code>本质上说跟其它语言中的同名函数功能一样：<code>new(T)</code>分配了零值填充的<code>T</code>类型的内存空间，并且返回其地址，即一个<code>*T</code>类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型<code>T</code>的零值。有一点非常重要：</p><p><code>new</code>返回指针。</p><p>内建函数<code>make(T, args)</code>与<code>new(T)</code>有着不同的功能，make只能创建<code>slice</code>、<code>map</code>和<code>channel</code>，并且返回一个有初始值(非零)的<code>T</code>类型，而不是<code>*T</code>。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个<code>slice</code>，是一个包含指向数据（内部<code>array</code>）的指针、长度和容量的三项描述符；在这些项目被初始化之前，<code>slice</code>为<code>nil</code>。对于<code>slice</code>、<code>map</code>和<code>channel</code>来说，<code>make</code>初始化了内部的数据结构，填充适当的值。</p><p><code>make</code>返回初始化后的（非零）值。</p><h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。</p><p>此处罗列 部分类型 的 “零值”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>     <span class="number">0</span></span><br><span class="line"><span class="type">int8</span>    <span class="number">0</span></span><br><span class="line"><span class="type">int32</span>   <span class="number">0</span></span><br><span class="line"><span class="type">int64</span>   <span class="number">0</span></span><br><span class="line"><span class="type">uint</span>    <span class="number">0x0</span></span><br><span class="line"><span class="type">rune</span>    <span class="number">0</span> <span class="comment">//rune的实际类型是 int32</span></span><br><span class="line"><span class="type">byte</span>    <span class="number">0x0</span> <span class="comment">// byte的实际类型是 uint8</span></span><br><span class="line"><span class="type">float32</span> <span class="number">0</span> <span class="comment">//长度为 4 byte</span></span><br><span class="line"><span class="type">float64</span> <span class="number">0</span> <span class="comment">//长度为 8 byte</span></span><br><span class="line"><span class="type">bool</span>    <span class="literal">false</span></span><br><span class="line"><span class="type">string</span>  <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><p>Go中流程控制分三大类：条件判断，循环控制和无条件跳转。</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p><code>if</code>也许是各种编程语言中最常见的了，它的语法概括起来就是：如果满足条件就做某事，否则做另一件事。</p><p>Go里面<code>if</code>条件判断语句中不需要括号，如下代码所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go的<code>if</code>还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算获取值x,然后根据x返回的大小，判断是否大于10。</span></span><br><span class="line"><span class="keyword">if</span> x := computedValue(); x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个地方如果这样调用就编译出错了，因为x是条件里面的变量</span></span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure><p>多个条件的时候如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> integer == <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is equal to 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> integer &lt; <span class="number">3</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is less than 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer is greater than 3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>Go有<code>goto</code>语句——请明智地使用它。用<code>goto</code>跳转到必须在当前函数内定义的标签。例如假设这样一个循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">Here:   <span class="comment">//这行的第一个词，以冒号结束作为标签</span></span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">goto</span> Here   <span class="comment">//跳转到Here去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标签名是大小写敏感的。</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Go里面最强大的一个控制逻辑就是<code>for</code>，它既可以用来循环读取数据，又可以当作<code>while</code>来控制逻辑，还能迭代操作。它的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> expression1; expression2; expression3 &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>expression1</code>、<code>expression2</code>和<code>expression3</code>都是表达式，其中<code>expression1</code>和<code>expression3</code>是变量声明或者函数调用返回值之类的，<code>expression2</code>是用来条件判断，<code>expression1</code>在循环开始之前调用，<code>expression3</code>在每轮循环结束之时调用。</p><p>一个例子比上面讲那么多更有用，看看下面的例子吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> index:=<span class="number">0</span>; index &lt; <span class="number">10</span> ; index++ &#123;</span><br><span class="line">        sum += index</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum is equal to &quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：sum is equal to 45</span></span><br></pre></td></tr></table></figure><p>有些时候需要进行多个赋值操作，由于Go里面没有<code>,</code>操作符，那么可以使用平行赋值<code>i, j = i+1, j-1</code></p><p>有些时候如果忽略<code>expression1</code>和<code>expression3</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>;  &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>;</code>也可以省略，那么就变成如下的代码了，这就是<code>while</code>的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环里面有两个关键操作<code>break</code>和<code>continue</code>   ,<code>break</code>操作是跳出当前循环，<code>continue</code>是跳过本次循环。当嵌套过深的时候，<code>break</code>可以配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index := <span class="number">10</span>; index&gt;<span class="number">0</span>; index-- &#123;</span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">5</span>&#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 或者continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// break打印出来10、9、8、7、6</span></span><br><span class="line"><span class="comment">// continue打印出来10、9、8、7、6、4、3、2、1</span></span><br></pre></td></tr></table></figure><p><code>break</code>和<code>continue</code>还可以跟着标号，用来跳到多重循环中的外层循环</p><p><code>for</code>配合<code>range</code>可以用于读取<code>slice</code>和<code>map</code>的数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> <span class="keyword">map</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s key:&quot;</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用<code>_</code>来丢弃不需要的返回值</p><p>例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> <span class="keyword">map</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>有些时候需要写很多的<code>if-else</code>来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维护，这个时候<code>switch</code>就能很好的解决这个问题。它的语法如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> sExpr &#123;</span><br><span class="line"><span class="keyword">case</span> expr1:</span><br><span class="line">    some instructions</span><br><span class="line"><span class="keyword">case</span> expr2:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">case</span> expr3:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sExpr</code>和<code>expr1</code>、<code>expr2</code>、<code>expr3</code>的类型必须一致。Go的<code>switch</code>非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；而如果<code>switch</code>没有表达式，它会匹配<code>true</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 1&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 2, 3 or 4&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;i is equal to 10&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;All I know is that i is an integer&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第5行中，把很多值聚合在了一个<code>case</code>里面，同时，Go里面<code>switch</code>默认相当于每个<code>case</code>最后带有<code>break</code>，匹配成功后不会自动向下执行其他case，而是跳出整个<code>switch</code>, 但是可以使用<code>fallthrough</code>强制执行后面的case代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">integer := <span class="number">6</span></span><br><span class="line"><span class="keyword">switch</span> integer &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 4&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 5&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 6&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 7&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;The integer was &lt;= 8&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default case&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序将输出</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The <span class="keyword">integer</span> was &lt;= <span class="number">6</span></span><br><span class="line">The <span class="keyword">integer</span> was &lt;= <span class="number">7</span></span><br><span class="line">The <span class="keyword">integer</span> was &lt;= <span class="number">8</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">case</span></span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>函数是Go里面的核心设计，它通过关键字<code>func</code>来声明，它的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(input1 type1, input2 type2)</span></span> (output1 type1, output2 type2) &#123;</span><br><span class="line">    <span class="comment">//这里是处理逻辑代码</span></span><br><span class="line">    <span class="comment">//返回多个值</span></span><br><span class="line">    <span class="keyword">return</span> value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以看出</p><ul><li><p>关键字<code>func</code>用来声明一个函数<code>funcName</code></p></li><li><p>函数可以有一个或者多个参数，每个参数后面带有类型，通过<code>,</code>分隔</p></li><li><p>函数可以返回多个值</p></li><li><p>上面返回值声明了两个变量<code>output1</code>和<code>output2</code>，如果不想声明也可以，直接就两个类型</p></li><li><p>如果只有一个返回值且不声明返回值变量，那么可以省略 包括返回值的括号</p></li><li><p>如果没有返回值，那么就直接省略最后的返回信息</p></li><li><p>如果有返回值， 那么必须在函数的外层添加return语句</p></li></ul><p>下面来看一个实际应用函数的例子（用来计算Max值）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 返回a、b中最大值.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    z := <span class="number">5</span></span><br><span class="line">    max_xy := max(x, y) <span class="comment">//调用函数max(x, y)</span></span><br><span class="line">    max_xz := max(x, z) <span class="comment">//调用函数max(x, z)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, y, max_xy)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, z, max_xz)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, y, z, max(y,z)) <span class="comment">// 也可在这直接调用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个里面可以看到<code>max</code>函数有两个参数，它们的类型都是<code>int</code>，那么第一个变量的类型可以省略（即 a,b int,而非 a int, b int)，默认为离它最近的类型，同理多于2个同类型的变量或者返回值。同时注意到它的返回值就是一个类型，这个就是省略写法。</p><h2 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h2><p>Go语言比C更先进的特性，其中一点就是函数能够返回多个值。</p><p>直接看例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//返回 A+B 和 A*B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    xPLUSy, xTIMESy := SumAndProduct(x, y)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>, x, y, xPLUSy)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d * %d = %d\n&quot;</span>, x, y, xTIMESy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子可以看到直接返回了两个参数，当然也可以命名返回参数的变量，这个例子里面只是用了两个类型，也可以改成如下这样的定义，然后返回的时候不用带上变量名，因为直接在函数里面初始化了。但如果函数是导出的(首字母大写)，官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="type">int</span>)</span></span> (add <span class="type">int</span>, Multiplied <span class="type">int</span>) &#123;</span><br><span class="line">    add = A+B</span><br><span class="line">    Multiplied = A*B</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h2><p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(arg ...<span class="type">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>arg ...int</code>告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是<code>int</code>。在函数体中，变量<code>arg</code>是一个<code>int</code>的<code>slice</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arg &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;And the number is: %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传值与传指针"><a href="#传值与传指针" class="headerlink" title="传值与传指针"></a>传值与传指针</h2><p>传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。</p><p>为了验证上面的说法，来看一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a = a+<span class="number">1</span> <span class="comment">// 改变了a的值</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="comment">//返回一个新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">    x1 := add1(x)  <span class="comment">//调用add1(x)</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出&quot;x+1 = 4&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出&quot;x = 3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然调用了<code>add1</code>函数，并且在<code>add1</code>中执行<code>a = a+1</code>操作，但是上面例子中<code>x</code>变量的值没有发生变化</p><p>理由很简单：因为当调用<code>add1</code>的时候，<code>add1</code>接收的参数其实是<code>x</code>的copy，而不是<code>x</code>本身。</p><p>如果真的需要传这个<code>x</code>本身,该怎么办呢？</p><p>这就牵扯到了所谓的指针。变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有<code>add1</code>函数知道<code>x</code>变量所在的地址，才能修改<code>x</code>变量的值。所以需要将<code>x</code>所在地址<code>&amp;x</code>传入函数，并将函数的参数的类型由<code>int</code>改为<code>*int</code>，即改为指针类型，才能在函数中修改<code>x</code>变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">// 请注意，</span></span><br><span class="line">    *a = *a+<span class="number">1</span> <span class="comment">// 修改了a的值</span></span><br><span class="line">    <span class="keyword">return</span> *a <span class="comment">// 返回新值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">    x1 := add1(&amp;x)  <span class="comment">// 调用 add1(&amp;x) 传x的地址</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出 &quot;x+1 = 4&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出 &quot;x = 4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就达到了修改<code>x</code>的目的。那么到底传指针有什么好处呢？</p><ul><li><p>传指针使得多个函数能操作同一个对象。</p></li><li><p>传指针比较轻量级 (8bytes),只是传内存地址，可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当要传递大的结构体的时候，用指针是一个明智的选择。</p></li><li><p>Go语言中<code>channel</code>，<code>slice</code>，<code>map</code>这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变<code>slice</code>的长度，则仍需要取地址传递指针）</p></li></ul><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>Go语言中有种不错的设计，即延迟（defer）语句，可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当进行一些打开资源的操作时，遇到错误需要提前返回，在返回前需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，一般写打开一个资源是这样操作的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"><span class="comment">// 做一些工作</span></span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        file.Close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面有很多重复的代码，Go的<code>defer</code>有效解决了这个问题。使用它后，不但代码量减少了很多，而且程序变得更优雅。在<code>defer</code>后指定的函数会在函数退出前调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> failureY &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有很多调用<code>defer</code>，那么<code>defer</code>是采用后进先出模式，所以如下代码会输出<code>4 3 2 1 0</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常来说，defer会用在释放数据库连接，关闭文件等需要在函数结束时处理的操作。</p><h2 id="函数作为值、类型"><a href="#函数作为值、类型" class="headerlink" title="函数作为值、类型"></a>函数作为值、类型</h2><p>在Go中函数也是一种变量，可以通过<code>type</code>来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> typeName <span class="function"><span class="keyword">func</span><span class="params">(input1 inputType1 , input2 inputType2 [, ...])</span></span> (result1 resultType1 [, ...])</span><br></pre></td></tr></table></figure><p>函数作为类型到底有什么好处呢？那就是可以把这个类型的函数当做值来传递，请看下面的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> testInt <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">bool</span> <span class="comment">// 声明了一个函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isOdd</span><span class="params">(integer <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEven</span><span class="params">(integer <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明的函数类型在这个地方当做了一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(slice []<span class="type">int</span>, f testInt)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">if</span> f(value) &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slice := []<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice = &quot;</span>, slice)</span><br><span class="line">    odd := filter(slice, isOdd)    <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Odd elements of slice are: &quot;</span>, odd)</span><br><span class="line">    even := filter(slice, isEven)  <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Even elements of slice are: &quot;</span>, even)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数当做值和类型在写一些通用接口的时候非常有用，通过上面例子看到<code>testInt</code>这个类型是一个函数类型，然后两个<code>filter</code>函数的参数和返回值与<code>testInt</code>类型是一样的，但是可以实现很多种的逻辑，这样使得程序变得非常的灵活。</p><h2 id="Panic和Recover"><a href="#Panic和Recover" class="headerlink" title="Panic和Recover"></a>Panic和Recover</h2><p>Go没有像Java那样的异常机制，它不能抛出异常，而是使用了<code>panic</code>和<code>recover</code>机制。一定要记住，应当把它作为最后的手段来使用，也就是说，代码中应当没有，或者很少有<code>panic</code>的东西。这是个强大的工具，请明智地使用它。</p><p>Panic</p><p>是一个内建函数，可以中断原有的控制流程，进入一个<code>panic</code>状态中。当函数<code>F</code>调用<code>panic</code>，函数F的执行被中断，但是<code>F</code>中的延迟函数会正常执行，然后F返回到调用它的地方。在调用的地方，<code>F</code>的行为就像调用了<code>panic</code>。这一过程继续向上，直到发生<code>panic</code>的<code>goroutine</code>中所有调用的函数返回，此时程序退出。<code>panic</code>可以直接调用<code>panic</code>产生。也可以由运行时错误产生，例如访问越界的数组。</p><p>Recover</p><p>是一个内建的函数，可以让进入<code>panic</code>状态的<code>goroutine</code>恢复过来。<code>recover</code>仅在延迟函数中有效。在正常的执行过程中，调用<code>recover</code>会返回<code>nil</code>，并且没有其它任何效果。如果当前的<code>goroutine</code>陷入<code>panic</code>状态，调用<code>recover</code>可以捕获到<code>panic</code>的输入值，并且恢复正常的执行。</p><p>下面这个函数演示了如何在过程中使用<code>panic</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;no value for $USER&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个函数检查作为其参数的函数在执行时是否会产生<code>panic</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">throwsPanic</span><span class="params">(f <span class="keyword">func</span>()</span></span>) (b <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">            b = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    f() <span class="comment">//执行函数f，如果f中出现了panic，那么就可以恢复回来</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p><code>defer</code>必须在<code>panic</code>语句之前。</p><p><code>recover</code>必须配合<code>defer</code>使用。</p><h2 id="main函数和init函数"><a href="#main函数和init函数" class="headerlink" title="main函数和init函数"></a><code>main</code>函数和<code>init</code>函数</h2><p>Go里面有两个保留的函数：<code>init</code>函数（能够应用于所有的<code>package</code>）和<code>main</code>函数（只能应用于<code>package main</code>）。这两个函数在定义时不能有任何的参数和返回值。虽然一个<code>package</code>里面可以写任意多个<code>init</code>函数，但这无论是对于可读性还是以后的可维护性来说，强烈建议用户在一个<code>package</code>中每个文件只写一个<code>init</code>函数。</p><p>Go程序会自动调用<code>init()</code>和<code>main()</code>，所以不需要在任何地方调用这两个函数。每个<code>package</code>中的<code>init</code>函数都是可选的，但<code>package main</code>就必须包含一个<code>main</code>函数。</p><p>程序的初始化和执行都起始于<code>main</code>包。如果<code>main</code>包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到<code>fmt</code>包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行<code>init</code>函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对<code>main</code>包中的包级常量和变量进行初始化，然后执行<code>main</code>包中的<code>init</code>函数（如果存在的话），最后执行<code>main</code>函数。</p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>在写Go代码的时候经常用到import这个命令用来导入包文件，经常看到的方式参考如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后代码里面可以通过如下的方式调用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>上面这个fmt是Go语言的标准库，其实是去<code>GOROOT</code>环境变量指定目录下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块：</p><h3 id="1、相对路径"><a href="#1、相对路径" class="headerlink" title="1、相对路径"></a>1、相对路径</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./model&quot;</span> <span class="comment">//当前文件同一目录的model目录，但是不建议这种方式来import</span></span><br></pre></td></tr></table></figure><h3 id="2、绝对路径"><a href="#2、绝对路径" class="headerlink" title="2、绝对路径"></a>2、绝对路径</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;shorturl/model&quot;</span> <span class="comment">//加载gopath/src/shorturl/model模块</span></span><br></pre></td></tr></table></figure><p>上面展示了一些import常用的几种方式，但是还有一些</p><h3 id="特殊的import"><a href="#特殊的import" class="headerlink" title="特殊的import"></a>特殊的import</h3><h4 id="1、点操作"><a href="#1、点操作" class="headerlink" title="1、点操作"></a>1、点操作</h4><p>有时候会看到如下的方式导入包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    . <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这个点操作的含义就是这个包导入之后在调用这个包的函数时，可以省略前缀的包名，也就是前面调用的fmt.Println(“hello world”)可以省略的写成<code>Println(&quot;hello world&quot;)</code></p><h4 id="2、别名操作"><a href="#2、别名操作" class="headerlink" title="2、别名操作"></a>2、别名操作</h4><p>别名操作顾名思义可以把包命名成另一个用起来容易记忆的名字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">        f <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>别名操作的话调用包函数时前缀变成了前缀，即<code>f.Println(&quot;hello world&quot;)</code></p><h4 id="3、-操作"><a href="#3、-操作" class="headerlink" title="3、_操作"></a>3、_操作</h4><p>这个操作经常是让很多人费解的一个操作符，请看下面这个<code>import</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/ziutek/mymysql/godrv&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>_</code>操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的<code>init函数</code>。</p><h1 id="struct类型"><a href="#struct类型" class="headerlink" title="struct类型"></a>struct类型</h1><h2 id="struct类型的声明"><a href="#struct类型的声明" class="headerlink" title="struct类型的声明"></a>struct类型的声明</h2><p>Go语言中，也和C或者其他语言一样，可以声明新的类型，作为其它类型的属性或字段的容器。例如，可以创建一个自定义类型<code>person</code>代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型称之<code>struct</code>。如下代码所示:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个<code>struct</code>如此简单，上面的类型包含有两个字段</p><ul><li>一个<code>string</code>类型的字段name，用来保存用户名称这个属性</li><li>一个<code>int</code>类型的字段age，用来保存用户年龄这个属性</li></ul><p>使用<code>struct</code>看下面的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> P person  <span class="comment">// P现在就是person类型的变量了</span></span><br><span class="line">P.name = <span class="string">&quot;Astaxie&quot;</span>  <span class="comment">// 赋值&quot;Astaxie&quot;给P的name属性.</span></span><br><span class="line">P.age = <span class="number">25</span>  <span class="comment">// 赋值&quot;25&quot;给变量P的age属性</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The person&#x27;s name is %s&quot;</span>, P.name)  <span class="comment">// 访问P的name属性.</span></span><br></pre></td></tr></table></figure><p>除了上面这种P的声明使用之外，还有另外几种声明使用方式：</p><ol><li><p>按照顺序提供初始化值<br><code>P := person&#123;&quot;Tom&quot;, 25&#125;</code></p></li><li><p>通过<code>field:value</code>的方式初始化，这样可以任意顺序<br><code>P := person&#123;age:24, name:&quot;Tom&quot;&#125;</code></p></li><li><p>当然也可以通过<code>new</code>函数分配一个指针，此处P的类型为<code>*person</code><br><code>P := new(person)</code></p></li></ol><p>看一个完整的使用<code>struct</code>的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 声明一个新的类型</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较两个人的年龄，返回年龄大的那个人，并且返回年龄差</span></span><br><span class="line"><span class="comment">// struct也是传值的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Older</span><span class="params">(p1, p2 person)</span></span> (person, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> p1.age&gt;p2.age &#123;  <span class="comment">// 比较p1和p2这两个人的年龄</span></span><br><span class="line">        <span class="keyword">return</span> p1, p1.age-p2.age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2, p2.age-p1.age</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tom person</span><br><span class="line">    <span class="comment">// 赋值初始化</span></span><br><span class="line">    tom.name, tom.age = <span class="string">&quot;Tom&quot;</span>, <span class="number">18</span></span><br><span class="line">    <span class="comment">// 两个字段都写清楚的初始化</span></span><br><span class="line">    bob := person&#123;age:<span class="number">25</span>, name:<span class="string">&quot;Bob&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 按照struct定义顺序初始化值</span></span><br><span class="line">    paul := person&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">43</span>&#125;</span><br><span class="line">    tb_Older, tb_diff := Older(tom, bob)</span><br><span class="line">    tp_Older, tp_diff := Older(tom, paul)</span><br><span class="line">    bp_Older, bp_diff := Older(bob, paul)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        tom.name, bob.name, tb_Older.name, tb_diff)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        tom.name, paul.name, tp_Older.name, tp_diff)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">        bob.name, paul.name, bp_Older.name, bp_diff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="struct的匿名字段"><a href="#struct的匿名字段" class="headerlink" title="struct的匿名字段"></a><code>struct</code>的匿名字段</h2><p>定义的时候是字段名与其类型一一对应，实际上Go支持只提供类型，而不写字段名的方式，也就是匿名字段，也称为嵌入字段。</p><p>当匿名字段是一个<code>struct</code>的时候，那么这个<code>struct</code>所拥有的全部字段都被隐式地引入了当前定义的这个<code>struct</code>。</p><p>看一个例子，让上面说的这些更具体化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个学生</span></span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="number">120</span>&#125;, <span class="string">&quot;Computer Science&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His name is &quot;</span>, mark.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is &quot;</span>, mark.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is &quot;</span>, mark.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改对应的备注信息</span></span><br><span class="line">    mark.speciality = <span class="string">&quot;AI&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark changed his speciality&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改他的年龄信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark become old&quot;</span>)</span><br><span class="line">    mark.age = <span class="number">46</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His age is&quot;</span>, mark.age)</span><br><span class="line">    <span class="comment">// 修改他的体重信息</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Mark is not an athlet anymore&quot;</span>)</span><br><span class="line">    mark.weight += <span class="number">60</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;His weight is&quot;</span>, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到Student访问属性age和name的时候，就像访问自己所有用的字段一样，匿名字段就是这样，能够实现字段的继承。student还能访问Human这个字段作为字段名。请看下面的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mark.Human = Human&#123;<span class="string">&quot;Marcus&quot;</span>, <span class="number">55</span>, <span class="number">220</span>&#125;</span><br><span class="line">mark.Human.age -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过匿名访问和修改字段相当的有用，但是不仅仅是<code>struct</code>字段，所有的内置类型和自定义类型都是可以作为匿名字段的。请看下面的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Skills []<span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    weight <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段，struct</span></span><br><span class="line">    Skills <span class="comment">// 匿名字段，自定义的类型string slice</span></span><br><span class="line">    <span class="type">int</span>    <span class="comment">// 内置类型作为匿名字段</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化学生Jane</span></span><br><span class="line">    jane := Student&#123;Human:Human&#123;<span class="string">&quot;Jane&quot;</span>, <span class="number">35</span>, <span class="number">100</span>&#125;, speciality:<span class="string">&quot;Biology&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 现在访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Her name is &quot;</span>, jane.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her age is &quot;</span>, jane.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her weight is &quot;</span>, jane.weight)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her speciality is &quot;</span>, jane.speciality)</span><br><span class="line">    <span class="comment">// 修改他的skill技能字段</span></span><br><span class="line">    jane.Skills = []<span class="type">string</span>&#123;<span class="string">&quot;anatomy&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her skills are &quot;</span>, jane.Skills)</span><br><span class="line">    fmt.Println(<span class="string">&quot;She acquired two new ones &quot;</span>)</span><br><span class="line">    jane.Skills = <span class="built_in">append</span>(jane.Skills, <span class="string">&quot;physics&quot;</span>, <span class="string">&quot;golang&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Her skills now are &quot;</span>, jane.Skills)</span><br><span class="line">    <span class="comment">// 修改匿名内置类型字段</span></span><br><span class="line">    jane.<span class="type">int</span> = <span class="number">3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Her preferred number is&quot;</span>, jane.<span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面例子看出来<code>struct</code>不仅仅能够将<code>struct</code>作为匿名字段，自定义类型、内置类型都可以作为匿名字段，而且可以在相应的字段上面进行函数操作（如例子中的append）。</p><p>这里有一个问题：如果human里面有一个字段叫做phone，而student也有一个字段叫做phone，那么该怎么办呢？</p><p>Go里面很简单的解决了这个问题，最外层的优先访问，也就是当通过<code>student.phone</code>访问的时候，是访问student里面的字段，而不是human里面的字段。</p><p>这样就允许去重载通过匿名字段继承的一些字段，当然如果想访问重载后对应匿名类型里面的字段，可以通过匿名字段名来访问。请看下面的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span>  <span class="comment">// Human类型拥有的字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human  <span class="comment">// 匿名字段Human</span></span><br><span class="line">    speciality <span class="type">string</span></span><br><span class="line">    phone <span class="type">string</span>  <span class="comment">// 雇员的phone字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Employee&#123;Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">34</span>, <span class="string">&quot;777-444-XXXX&quot;</span>&#125;, <span class="string">&quot;Designer&quot;</span>, <span class="string">&quot;333-222&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s work phone is:&quot;</span>, Bob.phone)</span><br><span class="line">    <span class="comment">// 如果要访问Human的phone字段</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Bob&#x27;s personal phone is:&quot;</span>, Bob.Human.phone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="method"><a href="#method" class="headerlink" title="method"></a>method</h1><p>函数的另一种形态，带有接收者的函数，称为<code>method</code></p><h2 id="method-1"><a href="#method-1" class="headerlink" title="method"></a>method</h2><p>现在假设有这么一个场景，定义了一个struct叫做长方形，现在想要计算他的面积，那么按照一般的思路应该会用下面的方式来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">(r Rectangle)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, area(r1))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, area(r2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码可以计算出来长方形的面积，但是area()不是作为Rectangle的方法实现的（类似面向对象里面的方法），而是将Rectangle的对象（如r1,r2）作为参数传入函数计算面积的。</p><p>这样实现当然没有问题，但是当需要增加圆形、正方形、五边形甚至其它多边形的时候，想计算他们的面积的时候怎么办？那就只能增加新的函数，但是函数名就必须要跟着换了，变成<code>area_rectangle, area_circle, area_triangle...</code></p><p> 椭圆代表函数, 而这些函数并不从属于struct(或者以面向对象的术语来说，并不属于class)，他们是单独存在于struct外围，而非在概念上属于某个struct的。</p><p>很显然，这样的实现并不优雅，并且从概念上来说”面积”是”形状”的一个属性，它是属于这个特定的形状的，就像长方形的长和宽一样。</p><p>基于上面的原因所以就有了<code>method</code>的概念，<code>method</code>是附属在一个给定的类型上的，他的语法和函数的声明语法几乎一样，只是在<code>func</code>后面增加了一个receiver(也就是method所依从的主体)。</p><p>用上面提到的形状的例子来说，method <code>area()</code> 是依赖于某个形状(比如说Rectangle)来发生作用的。Rectangle.area()的发出者是Rectangle， area()是属于Rectangle的方法，而非一个外围函数。</p><p>更具体地说，Rectangle存在字段 height 和 width, 同时存在方法area(), 这些字段和方法都属于Rectangle。</p><p>用Rob Pike的话来说就是：</p><p>“A method is a function with an implicit first argument, called a receiver.”</p><p>method的语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r ReceiverType)</span></span> funcName(parameters) (results)</span><br></pre></td></tr></table></figure><p>下面用最开始的例子用method来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">    c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">    c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, r1.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, r2.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of c1 is: &quot;</span>, c1.area())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Area of c2 is: &quot;</span>, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用method的时候重要注意几点</p><ul><li><p>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</p></li><li><p>method里面可以访问接收者的字段</p></li><li><p>调用method通过<code>.</code>访问，就像struct里面访问字段一样</p></li></ul><p>在上例，method area() 分别属于Rectangle和Circle， 于是他们的 Receiver 就变成了Rectangle 和 Circle, 或者说，这个area()方法 是由 Rectangle/Circle 发出的。</p><p>值得说明的一点是，图示中method用虚线标出，意思是此处方法的Receiver是以值传递，而非引用传递，是的，Receiver还可以是指针, 两者的差别在于, 指针作为Receiver会对实例对象的内容发生操作,而普通类型作为Receiver仅仅是以副本作为操作对象,并不对原实例对象发生操作。后文对此会有详细论述。</p><p>那是不是method只能作用在struct上面呢？当然不是，他可以定义在任何自定义的类型、内置类型、struct等各种类型上面。什么叫自定义类型，自定义类型不就是struct，其实不是这样的，struct只是自定义类型里面一种比较特殊的类型而已，还有其他自定义类型申明，可以通过如下这样的申明来实现。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">typeName </span>typeLiteral</span><br></pre></td></tr></table></figure><p>请看下面这个申明自定义类型的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ages <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> money <span class="type">float32</span></span><br><span class="line"><span class="keyword">type</span> months <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m := months &#123;</span><br><span class="line">    <span class="string">&quot;January&quot;</span>:<span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;February&quot;</span>:<span class="number">28</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">&quot;December&quot;</span>:<span class="number">31</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以在自己的代码里面定义有意义的类型了，实际上只是一个定义了一个别名,有点类似于c中的typedef，例如上面ages替代了int，回到<code>method</code> 可以在任何的自定义类型中定义任意多的<code>method</code>，接下来让看一个复杂一点的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    WHITE = <span class="literal">iota</span><span class="comment">//0</span></span><br><span class="line">    BLACK<span class="comment">//1</span></span><br><span class="line">    BLUE<span class="comment">//2</span></span><br><span class="line">    RED<span class="comment">//3</span></span><br><span class="line">    YELLOW<span class="comment">//4</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Color <span class="type">byte</span></span><br><span class="line"><span class="keyword">type</span> Box <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height, depth <span class="type">float64</span></span><br><span class="line">    color Color</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> BoxList []Box <span class="comment">//a slice of boxes，以Box为类型的切片类</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Box)</span></span> Volume() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.width * b.height * b.depth</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span></span> SetColor(c Color) &#123;</span><br><span class="line">    b.color = c</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span></span> BiggestColor() Color &#123;</span><br><span class="line">    v := <span class="number">0.00</span></span><br><span class="line">    k := Color(WHITE)</span><br><span class="line">    <span class="keyword">for</span> _, b := <span class="keyword">range</span> bl &#123;</span><br><span class="line">        <span class="keyword">if</span> bv := b.Volume(); bv &gt; v &#123;</span><br><span class="line">            v = bv</span><br><span class="line">            k = b.color</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span></span> PaintItBlack() &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> bl &#123;</span><br><span class="line">        bl[i].SetColor(BLACK)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Color)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    strings := []<span class="type">string</span> &#123;<span class="string">&quot;WHITE&quot;</span>, <span class="string">&quot;BLACK&quot;</span>, <span class="string">&quot;BLUE&quot;</span>, <span class="string">&quot;RED&quot;</span>, <span class="string">&quot;YELLOW&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> strings[c]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    boxes := BoxList &#123;</span><br><span class="line">        Box&#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, RED&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, YELLOW&#125;,</span><br><span class="line">        Box&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">20</span>, BLACK&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, BLUE&#125;,</span><br><span class="line">        Box&#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">1</span>, WHITE&#125;,</span><br><span class="line">        Box&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, YELLOW&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;We have %d boxes in our set\n&quot;</span>, <span class="built_in">len</span>(boxes))</span><br><span class="line">    fmt.Println(<span class="string">&quot;The volume of the first one is&quot;</span>, boxes[<span class="number">0</span>].Volume(), <span class="string">&quot;cm³&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;The color of the last one is&quot;</span>,boxes[<span class="built_in">len</span>(boxes)<span class="number">-1</span>].color.String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestColor().String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Let&#x27;s paint them all black&quot;</span>)</span><br><span class="line">    boxes.PaintItBlack()</span><br><span class="line">    fmt.Println(<span class="string">&quot;The color of the second one is&quot;</span>, boxes[<span class="number">1</span>].color.String())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Obviously, now, the biggest one is&quot;</span>, boxes.BiggestColor().String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码通过const定义了一些常量，然后定义了一些自定义类型</p><ul><li><p>Color作为byte的别名</p></li><li><p>定义了一个struct:Box，含有三个长宽高字段和一个颜色属性</p></li><li><p>定义了一个slice:BoxList，含有Box</p></li></ul><p>然后以上面的自定义类型为接收者定义了一些method</p><ul><li><p>Volume()定义了接收者为Box，返回Box的容量</p></li><li><p>SetColor(c Color)，把Box的颜色改为c</p></li><li><p>BiggestColor()定在在BoxList上面，返回list里面容量最大的颜色</p></li><li><p>PaintItBlack()把BoxList里面所有Box的颜色全部变成黑色</p></li><li><p>String()定义在Color上面，返回Color的具体颜色(字符串格式)</p></li></ul><p>上面的代码通过文字描述出来之后是不是很简单？一般解决问题都是通过问题的描述，去写相应的代码实现。</p><h2 id="指针作为receiver"><a href="#指针作为receiver" class="headerlink" title="指针作为receiver"></a>指针作为receiver</h2><p>现在让回过头来看看SetColor这个method，它的receiver是一个指向Box的指针，可以使用*Box。</p><p>定义SetColor的真正目的是想改变这个Box的颜色，如果不传Box的指针，那么SetColor接受的其实是Box的一个copy，也就是说method内对于颜色值的修改，其实只作用于Box的copy，而不是真正的Box。所以需要传入指针。</p><p>这里可以把receiver当作method的第一个参数来看，然后结合前面函数讲解的传值和传引用就不难理解</p><p>这里也许会问SetColor函数里面应该这样定义<code>*b.Color=c</code>,而不是<code>b.Color=c</code>,需要读取到指针相应的值。</p><p>其实Go里面这两种方式都是正确的，当用指针去访问相应的字段时(虽然指针没有任何的字段)，Go知道要通过指针去获取这个值。PaintItBlack里面调用SetColor的时候是不是应该写成<code>(&amp;bl[i]).SetColor(BLACK)</code>，因为SetColor的receiver是*Box，而不是Box。这两种方式都可以，因为Go知道receiver是指针，他自动转了。</p><p>也就是说：</p><p>如果一个method的receiver是*T,可以在一个T类型的实例变量V上面调用这个method，而不需要&amp;V去调用这个method</p><p>类似的</p><p>如果一个method的receiver是T，可以在一个*T类型的变量P上面调用这个method，而不需要 *P去调用这个method</p><p>所以不用担心是调用的指针的method还是不是指针的method，Go知道要做的一切，这对于有多年C/C++编程经验的同学来说，真是解决了一个很大的痛苦。</p><h2 id="method继承"><a href="#method继承" class="headerlink" title="method继承"></a>method继承</h2><p>通过字段的继承的学习，发现Go的一个神奇之处，method也是可以继承的。如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method。来看下面这个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在human上面定义了一个method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="method重写"><a href="#method重写" class="headerlink" title="method重写"></a>method重写</h2><p>上面的例子中，如果Employee想要实现自己的SayHi,怎么办？简单，和匿名字段冲突一样的道理，可以在Employee上面定义一个method，重写了匿名字段的方法。请看下面的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这些内容，可以设计出基本的面向对象的程序了，但是Go里面的面向对象是如此的简单，没有任何的私有、公有关键字，通过大小写来实现(大写开头的为公有，小写开头的为私有)，方法也同样适用这个原则。</p><h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><p>Go语言里面设计最精妙的应该算<code>interface</code>，它让面向对象，内容组织实现非常的方便</p><h2 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h2><p>简单的说，<code>interface</code>是一组<code>method</code>签名的组合，通过<code>interface</code>来定义对象的一组行为。</p><p>前面例子中<code>Student</code>和<code>Employee</code>都能<code>SayHi</code>，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能<code>say hi</code></p><p>继续做更多的扩展，<code>Student</code>和<code>Employee</code>实现另一个方法<code>Sing</code>，然后<code>Student</code>实现方法<code>BorrowMoney</code>而<code>Employee</code>实现<code>SpendSalary</code>。</p><p>这样<code>Student</code>实现了三个方法：<code>SayHi</code>、<code>Sing</code>、<code>BorrowMoney</code>；而<code>Employee</code>实现了<code>SayHi</code>、<code>Sing</code>、<code>SpendSalary</code>。</p><p>上面这些方法的组合称为<code>interface</code>(被对象<code>Student</code>和<code>Employee</code>实现)。例如<code>Student</code>和<code>Employee</code>都实现了<code>interface</code>：<code>SayHi</code>和<code>Sing</code>，也就是这两个对象是该<code>interface</code>类型。而<code>Employee</code>没有实现这个<code>interface：SayHi、Sing</code>和<code>BorrowMoney</code>，因为<code>Employee</code>没有实现<code>BorrowMoney</code>这个方法。</p><h2 id="interface类型"><a href="#interface类型" class="headerlink" title="interface类型"></a>interface类型</h2><p><code>interface</code>类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法参考下面这个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human对象实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Human对象实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la, la la la, la la la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human对象实现Guzzle方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span></span> Guzzle(beerStein <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Guzzle Guzzle Guzzle...&quot;</span>, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Employee重载Human的Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//此句可以分成多行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student实现BorrowMoney方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> BorrowMoney(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    s.loan += amount <span class="comment">// (again and again and...)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee实现SpendSalary方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> SpendSalary(amount <span class="type">float32</span>) &#123;</span><br><span class="line">    e.money -= amount <span class="comment">// More vodka please!!! Get me through the day!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">    Guzzle(beerStein <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> YoungChap <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    BorrowMoney(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ElderlyGent <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="type">string</span>)</span><br><span class="line">    SpendSalary(amount <span class="type">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码可以知道，interface可以被任意的对象实现。看到上面的Men interface被Human、Student和Employee实现。同理，一个对象可以实现任意多个interface，例如上面的Student实现了Men和YoungChap两个interface。</p><p>最后，任意的类型都实现了空interface(这样定义：interface{})，也就是包含0个method的interface。</p><h2 id="interface值"><a href="#interface值" class="headerlink" title="interface值"></a>interface值</h2><p>那么interface里面到底能存什么值呢？如果定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值。</p><p>因为m能够持有这三种类型的对象，所以可以定义一个包含Men类型元素的slice，这个slice可以被赋予实现了Men接口的任意结构的对象，这个和传统意义上面的slice有所不同。</p><p>来看一下下面这个例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="type">string</span></span><br><span class="line">    loan <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="type">string</span></span><br><span class="line">    money <span class="type">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human实现SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> Sing(lyrics <span class="type">string</span>) &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;La la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee重载Human的SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> SayHi() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">        e.company, e.phone)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Interface Men被Human,Student和Employee实现</span></span><br><span class="line"><span class="comment">// 因为这三个类型都实现了这两个方法</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mike := Student&#123;Human&#123;<span class="string">&quot;Mike&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-XXX&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>, <span class="number">0.00</span>&#125;</span><br><span class="line">    paul := Student&#123;Human&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">26</span>, <span class="string">&quot;111-222-XXX&quot;</span>&#125;, <span class="string">&quot;Harvard&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">36</span>, <span class="string">&quot;444-222-XXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc.&quot;</span>, <span class="number">1000</span>&#125;</span><br><span class="line">    tom := Employee&#123;Human&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">37</span>, <span class="string">&quot;222-444-XXX&quot;</span>&#125;, <span class="string">&quot;Things Ltd.&quot;</span>, <span class="number">5000</span>&#125;</span><br><span class="line">    <span class="comment">//定义Men类型的变量i</span></span><br><span class="line">    <span class="keyword">var</span> i Men</span><br><span class="line">    <span class="comment">//i能存储Student</span></span><br><span class="line">    i = mike</span><br><span class="line">    fmt.Println(<span class="string">&quot;This is Mike, a Student:&quot;</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">&quot;November rain&quot;</span>)</span><br><span class="line">    <span class="comment">//i也能存储Employee</span></span><br><span class="line">    i = tom</span><br><span class="line">    fmt.Println(<span class="string">&quot;This is tom, an Employee:&quot;</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">&quot;Born to be wild&quot;</span>)</span><br><span class="line">    <span class="comment">//定义了slice Men</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Let&#x27;s use a slice of Men and see what happens&quot;</span>)</span><br><span class="line">    x := <span class="built_in">make</span>([]Men, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">//这三个都是不同类型的元素，但是他们实现了interface同一个接口</span></span><br><span class="line">    x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>] = paul, sam, mike</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> x&#123;</span><br><span class="line">        value.SayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码，发现<code>interface</code>就是一组抽象方法的集合，它必须由其他非interface类型实现，而不能自我实现， Go通过interface实现了<code>duck-typing</code>:即”当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”。</p><h2 id="空interface"><a href="#空interface" class="headerlink" title="空interface"></a>空interface</h2><p>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义a为空接口</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">s := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">// a可以存储任意类型的数值</span></span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure><p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回<code>interface&#123;&#125;</code>,那么也就可以返回任意类型的值。是不是很有用啊！</p><h2 id="interface函数参数"><a href="#interface函数参数" class="headerlink" title="interface函数参数"></a>interface函数参数</h2><p>interface的变量可以持有任意实现该interface类型的对象，这给编写函数(包括method)提供了一些额外的思考，是不是可以通过定义interface参数，让函数接受各种类型的参数。</p><p>举个例子：fmt.Println是常用的一个函数，是否注意到它可以接受任意类型的数据。打开fmt的源码文件，会看到这样一个定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">     String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，任何实现了String方法的类型都能作为参数被<code>fmt.Println</code>调用,来试一试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    phone <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过这个方法 Human 实现了 fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;❰&quot;</span>+h.name+<span class="string">&quot; - &quot;</span>+strconv.Itoa(h.age)+<span class="string">&quot; years -  ✆ &quot;</span> +h.phone+<span class="string">&quot;❱&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">39</span>, <span class="string">&quot;000-7777-XXX&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;This Human is : &quot;</span>, Bob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在再回顾一下前面的Box示例，发现Color结构也定义了一个<code>method：String</code>。其实这也是实现了<code>fmt.Stringer</code>这个<code>interface</code>，即如果需要某个类型能被fmt包以特殊的格式输出，就必须实现<code>Stringer</code>这个接口。如果没有实现这个接口，fmt将以默认的方式输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现同样的功能</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestsColor().String())</span><br><span class="line">fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestsColor())</span><br></pre></td></tr></table></figure><p>注：实现了<code>error</code>接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必再定义String()方法了。</p><h2 id="interface变量存储的类型"><a href="#interface变量存储的类型" class="headerlink" title="interface变量存储的类型"></a>interface变量存储的类型</h2><p>interface的变量里面可以存储任意类型的数值(该类型实现了interface)。那么怎么反向知道这个变量里面实际保存了的是哪个类型的对象呢？目前常用的有两种方法：</p><ul><li>Comma-ok断言</li></ul><p>Go语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok = element.(T)，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。</p><p>如果element里面确实存储了T类型的数值，那么ok返回true，否则返回false。</p><p>通过一个例子来更加深入的理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了String方法，实现了fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">// a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> value, ok := element.(<span class="type">int</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(<span class="type">string</span>); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(Person); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is of a different type\n&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否注意到了多个if里面，if里面允许初始化变量。断言的类型越多，那么if else也就越多，所以才引出了下面要介绍的switch。</p><ul><li>switch测试</li></ul><p>重写上面的这个实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">    list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">//an int</span></span><br><span class="line">    list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">//a string</span></span><br><span class="line">    list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> index, element := <span class="keyword">range</span> list&#123;</span><br><span class="line">        <span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">case</span> Person:</span><br><span class="line">            fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;list[%d] is of a different type&quot;</span>, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一点需要强调的是：<code>element.(type)</code>语法不能在switch外的任何逻辑里面使用，如果要在switch外面判断一个类型就使用<code>comma-ok</code>。</p><h2 id="嵌入interface"><a href="#嵌入interface" class="headerlink" title="嵌入interface"></a>嵌入interface</h2><p>Go里面真正吸引人的是它内置的逻辑语法，就像在学习Struct时学习的匿名字段，那么相同的逻辑引入到interface里面，更加完美了。如果一个interface1作为interface2的一个嵌入字段，那么interface2隐式的包含了interface1里面的method。</p><p>可以看到源码包<code>container/heap</code>里面有这样的一个定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface <span class="comment">//嵌入字段sort.Interface</span></span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">//a Push method to push elements into the heap</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125; <span class="comment">//a Pop elements that pops elements from the heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到<code>sort.Interface</code>其实就是嵌入字段，把<code>sort.Interface</code>的所有<code>method</code>给隐式的包含进来了。也就是下面三个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">    <span class="comment">// Less returns whether the element with index i should sort</span></span><br><span class="line">    <span class="comment">// before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个例子就是io包下面的 <code>io.ReadWriter</code> ，它包含了io包下面的<code>Reader</code>和<code>Writer</code>两个<code>interface</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.ReadWriter</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Go语言实现了反射，所谓反射就是能检查程序在运行时的状态。一般用到的包是<code>reflect</code>包。如何运用<code>reflect</code>包，官方的这篇文章详细的讲解了<code>reflect</code>包的实现原理，<code>laws of reflection</code> 链接地址为 <a href="http://golang.org/doc/articles/laws_of_reflection.html">http://golang.org/doc/articles/laws_of_reflection.html</a></p><p>使用reflect一般分成三步，下面简要的讲解一下：要去反射是一个类型的值(这些值都实现了<code>空interface</code>)，首先需要把它转化成<code>reflect</code>对象(<code>reflect.Type</code>或者<code>reflect.Value</code>，根据不同的情况调用不同的函数)。这两种获取方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := reflect.TypeOf(i)    <span class="comment">//得到类型的元数据,通过t能获取类型定义里面的所有元素</span></span><br><span class="line">v := reflect.ValueOf(i)   <span class="comment">//得到实际的值，通过v获取存储在里面的值，还可以去改变值</span></span><br></pre></td></tr></table></figure><p>转化为reflect对象之后就可以进行一些操作了，也就是将reflect对象转化成相应的值，例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tag := t.Elem().Field(<span class="number">0</span>).Tag  <span class="comment">//获取定义在struct里面的标签</span></span><br><span class="line">name := v.Elem().Field(<span class="number">0</span>).String()  <span class="comment">//获取存储在第一个字段里面的值</span></span><br></pre></td></tr></table></figure><p>获取反射值能返回相应的类型和数值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;kind is float64:&quot;</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())</span><br></pre></td></tr></table></figure><p>最后，反射的话，那么反射的字段必须是可修改的，前面学习过传值和传引用，这个里面也是一样的道理。反射的字段必须是可读写的意思是，如果下面这样写，那么会发生错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure><p>如果要修改相应的值，必须这样写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">v := p.Elem()</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>Go从语言层面支持了并行。</p><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p><code>goroutine</code>是<code>Go</code>并行设计的核心。<code>goroutine</code>说到底其实就是协程，但是它比线程更小，十几个<code>goroutine</code>可能体现在底层就是五六个线程，Go语言内部实现了这些<code>goroutine</code>之间的内存共享。执行<code>goroutine</code>只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。<code>goroutine</code>比<code>thread</code>更易用、更高效、更轻便。</p><p><code>goroutine</code>是通过Go的<code>runtime</code>管理的一个线程管理器。<code>goroutine</code>通过<code>go</code>关键字实现了，其实就是一个普通的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> hello(a, b, c)</span><br></pre></td></tr></table></figure><p>通过关键字go就启动了一个<code>goroutine</code>。来看一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>) <span class="comment">//开一个新的Goroutines执行</span></span><br><span class="line">    say(<span class="string">&quot;hello&quot;</span>) <span class="comment">//当前Goroutines执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上程序执行后将输出：</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>可以看到go关键字很方便的就实现了并发编程。</p><p>上面的多个<code>goroutine</code>运行在同一个进程里面，共享内存数据，不过设计上要遵循：不要通过共享来通信，而要通过通信来共享。</p><p><code>runtime.Gosched()</code>表示让CPU把时间片让给别人,下次某个时候继续恢复执行该<code>goroutine</code>。</p><p>默认情况下，在Go 1.5将标识并发系统线程个数的<code>runtime.GOMAXPROCS</code>的初始值由1改为了<code>运行环境的CPU核数</code>。</p><p>但在Go 1.5以前调度器仅使用单线程，也就是说只实现了并发。想要发挥多核处理器的并行，需要程序中显式调用 <code>runtime.GOMAXPROCS(n)</code> 告诉调度器同时使用多个线程。<code>GOMAXPROCS</code> 设置了同时运行逻辑代码的系统线程的最大数量，并返回之前的设置。如果<code>n &lt; 1</code>，不会改变当前设置。</p><h2 id="channels"><a href="#channels" class="headerlink" title="channels"></a>channels</h2><p><code>goroutine</code>运行在相同的地址空间，因此访问共享内存必须做好同步。那么<code>goroutine</code>之间如何进行数据的通信呢，Go提供了一个很好的通信机制<code>channel</code>。<code>channel</code>可以与<code>Unix shell</code> 中的双向管道做类比：可以通过它发送或者接收值。这些值只能是特定的类型：<code>channel类型</code>。定义一个<code>channel</code>时，也需要定义发送到<code>channel</code>的值的类型。注意，必须使用<code>make</code> 创建<code>channel</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ci := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">cf := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p><code>channel</code>通过操作符<code>&lt;-</code>来接收和发送数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 发送v到channel ch.</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从ch中接收数据，并赋值给v</span></span><br></pre></td></tr></table></figure><p>把这些应用到例子中来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        total += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- total  <span class="comment">// send total to c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(a[:<span class="built_in">len</span>(a)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(a[<span class="built_in">len</span>(a)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c  <span class="comment">// receive from c</span></span><br><span class="line">    fmt.Println(x, y, x + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，<code>channel</code>接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得<code>Goroutines</code>同步变的更加的简单，而不需要显式的<code>lock</code>。所谓阻塞，也就是如果读取（<code>value := &lt;-ch</code>）它将会被阻塞，直到有数据接收。其次，任何发送（<code>ch&lt;-5</code>）将会被阻塞，直到数据被读出。无缓冲<code>channel</code>是在多个<code>goroutine</code>之间同步很棒的工具。</p><h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>上面介绍了默认的非缓存类型的channel，不过Go也允许指定channel的缓冲大小，很简单，就是channel可以存储多少元素。<code>ch:= make(chan bool</code>, 4)，创建了可以存储4个元素的bool 型channel。在这个channel 中，前4个元素可以无阻塞的写入。当写入第5个元素时，代码将会阻塞，直到其他goroutine从channel 中读取一些元素，腾出空间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, value)</span><br></pre></td></tr></table></figure><p>当 <code>value = 0</code> 时，channel 是无缓冲阻塞读写的，当<code>value &gt; 0</code> 时，channel 有缓冲、是非阻塞的，直到写满 value 个元素才阻塞写入。</p><p>看一下下面这个例子，可以在自己本机测试一下，修改相应的value值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)<span class="comment">//修改2为1就报错，修改2为3可以正常运行</span></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改为1报如下的错误:</span></span><br><span class="line"><span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></table></figure><h2 id="Range和Close"><a href="#Range和Close" class="headerlink" title="Range和Close"></a>Range和Close</h2><p>上面这个例子中，需要读取两次c，这样不是很方便，Go考虑到了这一点，所以也可以通过range，像操作slice或者map一样操作缓存类型的channel，请看下面的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x + y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for i := range c</code>能够不断的读取<code>channel</code>里面的数据，直到该<code>channel</code>被显式的关闭。上面代码看到可以显式的关闭<code>channel</code>，生产者通过内置函数<code>close</code>关闭<code>channel</code>。关闭<code>channel</code>之后就无法再发送任何数据了，在消费方可以通过语法<code>v, ok := &lt;-ch</code>测试<code>channel</code>是否被关闭。如果ok返回false，那么说明<code>channel</code>已经没有任何数据并且已经被关闭。</p><p>记住应该在生产者的地方关闭<code>channel</code>，而不是消费的地方去关闭它，这样容易引起<code>panic</code></p><p>另外记住一点的就是<code>channel</code>不像文件之类的，不需要经常去关闭，只有确实没有任何发送数据了，或者想显式的结束<code>range</code>循环之类的</p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>上面介绍的都是只有一个<code>channel</code>的情况，那么如果存在多个<code>channel</code>的时候，该如何操作呢，Go里面提供了一个关键字<code>select</code>，通过<code>select</code>可以监听<code>channel</code>上的数据流动。</p><p><code>select</code>默认是阻塞的，只有当监听的<code>channel</code>中有发送或接收可以进行时才会运行，当多个<code>channel</code>都准备好的时候，<code>select</code>是随机的选择一个执行的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">            x, y = y, x + y</span><br><span class="line">        <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">            fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>select</code>里面还有<code>default</code>语法，<code>select</code>其实就是类似<code>switch</code>的功能，<code>default</code>就是当监听的<code>channel</code>都没有准备好的时候，默认执行的（<code>select</code>不再阻塞等待<code>channel</code>）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">    <span class="comment">// use i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 当c阻塞的时候执行这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>有时候会出现<code>goroutine</code>阻塞的情况，那么如何避免整个程序进入阻塞的情况呢？可以利用<code>select</code>来设置超时，通过如下的方式实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> v := &lt;- c:</span><br><span class="line">                    <span class="built_in">println</span>(v)</span><br><span class="line">                <span class="keyword">case</span> &lt;- time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">                    <span class="built_in">println</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">                    o &lt;- <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="runtime-goroutine"><a href="#runtime-goroutine" class="headerlink" title="runtime goroutine"></a>runtime goroutine</h2><p><code>runtime</code>包中有几个处理<code>goroutine</code>的函数：</p><ul><li><p><code>Goexit</code> : 退出当前执行的goroutine，但是defer函数还会继续调用</p></li><li><p><code>Gosched</code>: 让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p></li><li><p><code>NumCPU</code> : 返回 CPU 核数量</p></li><li><p><code>NumGoroutine</code>: 返回正在执行和排队的任务总数</p></li><li><p><code>GOMAXPROCS</code> : 用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p></li></ul><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>Go语言主要的设计准则是：简洁、明白，简洁是指语法和C类似，相当的简单，明白是指任何语句都是很明显的，不含有任何隐含的东西，在错误处理方案的设计中也贯彻了这一思想。</p><p>在C语言里面是通过返回<code>-1</code>或者<code>NULL</code>之类的信息来表示错误，但是对于使用者来说，不查看相应的API说明文档，根本搞不清楚这个返回值究竟代表什么意思，比如:返回0是成功，还是失败,而<code>Go</code>定义了一个叫做<code>error</code>的类型，来显式表达错误。在使用时，通过把返回的<code>error</code>变量与<code>nil</code>的比较，来判定操作是否成功。例如<code>os.Open</code>函数在打开文件失败时将返回一个不为<code>nil</code>的<code>error</code>变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="type">string</span>)</span></span> (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>下面这个例子通过调用<code>os.Open</code>打开一个文件，如果出现错误，那么就会调用<code>log.Fatal</code>来输出错误信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(<span class="string">&quot;filename.ext&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似于<code>os.Open</code>函数，标准包中所有可能出错的API都会返回一个<code>error</code>变量，以方便错误处理，这个小节将详细地介绍<code>error</code>类型的设计，和讨论开发Web应用中如何更好地处理<code>error</code>。</p><h2 id="Error类型"><a href="#Error类型" class="headerlink" title="Error类型"></a>Error类型</h2><p>error类型是一个接口类型，这是它的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>error是一个内置的接口类型，可以在<code>/builtin/</code>包下面找到相应的定义。而在很多内部包里面用到的 <code>error</code>是<code>errors</code>包下面的实现的私有结构<code>errorString</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<code>errors.New</code>把一个字符串转化为<code>errorString</code>，以得到一个满足接口<code>error</code>的对象，其内部实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个例子演示了如何使用<code>errors.New</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在下面的例子中，在调用Sqrt的时候传递的一个负数，然后就得到了<code>non-nil</code>的<code>error</code>对象，将此对象与<code>nil</code>比较，结果为<code>true</code>，所以<code>fmt.Println</code>(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, err := Sqrt(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义Error"><a href="#自定义Error" class="headerlink" title="自定义Error"></a>自定义Error</h2><p><code>error</code>是一个<code>interface</code>，所以在实现自己的包的时候，通过定义实现此接口的结构，就可以实现自己的错误定义，请看来自Json包的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SyntaxError <span class="keyword">struct</span> &#123;</span><br><span class="line">    msg    <span class="type">string</span> <span class="comment">// 错误描述</span></span><br><span class="line">    Offset <span class="type">int64</span>  <span class="comment">// 错误发生的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *SyntaxError)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> e.msg &#125;</span><br></pre></td></tr></table></figure><p><code>Offset</code>字段在调用<code>Error</code>的时候不会被打印，但可以通过类型断言获取错误类型，然后可以打印相应的错误信息，请看下面的例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;val); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> serr, ok := err.(*json.SyntaxError); ok &#123;</span><br><span class="line">        line, col := findLine(f, serr.Offset)</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%s:%d:%d: %v&quot;</span>, f.Name(), line, col, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，函数返回自定义错误时，返回值推荐设置为<code>error</code>类型，而非自定义错误类型，特别需要注意的是不应预声明自定义错误类型的变量。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decode</span><span class="params">()</span></span> *SyntaxError &#123; <span class="comment">// 错误，将可能导致上层调用者err!=nil的判断永远为true。</span></span><br><span class="line">    <span class="keyword">var</span> err *SyntaxError     <span class="comment">// 预声明错误变量</span></span><br><span class="line">    <span class="keyword">if</span> 出错条件 &#123;</span><br><span class="line">        err = &amp;SyntaxError&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err               <span class="comment">// 错误，err永远等于非nil，导致上层调用者err!=nil的判断始终为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因见 <code>http://golang.org/doc/faq#nil_error</code> (需科学上网)</p><p>上面例子简单的演示了如何自定义Error类型。但是如果还需要更复杂的错误处理呢？此时，来参考一下net包采用的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Error <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">error</span></span><br><span class="line">    Timeout() <span class="type">bool</span>   <span class="comment">// Is the error a timeout?</span></span><br><span class="line">    Temporary() <span class="type">bool</span> <span class="comment">// Is the error temporary?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用的地方，通过类型断言<code>err</code>是不是<code>net.Error</code>,来细化错误的处理，例如下面的例子，如果一个网络发生临时性错误，那么将会sleep 1秒之后重试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nerr, ok := err.(net.Error); ok &amp;&amp; nerr.Temporary() &#123;</span><br><span class="line">    time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go在错误处理上采用了与C类似的检查返回值的方式，而不是其他多数主流语言采用的异常方式，这造成了代码编写上的一个很大的缺点:错误处理代码的冗余，对于这种情况是通过复用检测函数来减少类似的代码。</p><p>请看下面这个例子代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/view&quot;</span>, viewRecord)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中获取数据和模板展示调用时都有检测错误，当有错误发生时，调用了统一的处理函数<code>http.Error</code>，返回给客户端500错误码，并显示相应的错误数据。但是当越来越多的<code>HandleFunc</code>加入之后，这样的错误处理逻辑代码就会越来越多，其实可以通过自定义路由器来缩减代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := fn(w, r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了自定义的路由器，然后可以通过如下方式来注册函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.Handle(<span class="string">&quot;/view&quot;</span>, appHandler(viewRecord))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当请求<code>/view</code>的时候逻辑处理可以变成如下代码，和第一种实现方式相比较已经简单了很多。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> viewTemplate.Execute(w, record)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子错误处理的时候所有的错误返回给用户的都是500错误码，然后打印出来相应的错误代码，其实可以把这个错误信息定义的更加友好，调试的时候也方便定位问题，可以自定义返回的错误类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> appError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Error   <span class="type">error</span></span><br><span class="line">    Message <span class="type">string</span></span><br><span class="line">    Code    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样自定义路由器可以改成如下方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> *appError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fn appHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="keyword">if</span> e := fn(w, r); e != <span class="literal">nil</span> &#123; <span class="comment">// e is *appError, not os.Error.</span></span><br><span class="line">        c := appengine.NewContext(r)</span><br><span class="line">        c.Errorf(<span class="string">&quot;%v&quot;</span>, e.Error)</span><br><span class="line">        http.Error(w, e.Message, e.Code)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样修改完自定义错误之后，逻辑处理可以改成如下方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">viewRecord</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> *appError &#123;</span><br><span class="line">    c := appengine.NewContext(r)</span><br><span class="line">    key := datastore.NewKey(c, <span class="string">&quot;Record&quot;</span>, r.FormValue(<span class="string">&quot;id&quot;</span>), <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">    record := <span class="built_in">new</span>(Record)</span><br><span class="line">    <span class="keyword">if</span> err := datastore.Get(c, key, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Record not found&quot;</span>, <span class="number">404</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := viewTemplate.Execute(w, record); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;appError&#123;err, <span class="string">&quot;Can&#x27;t display record&quot;</span>, <span class="number">500</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，在访问view的时候可以根据不同的情况获取不同的错误码和错误信息，虽然这个和第一个版本的代码量差不多，但是这个显示的错误更加明显，提示的错误信息更加友好，扩展性也比第一个更好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在程序设计中，容错是相当重要的一部分工作，在Go中它是通过错误处理来实现的，error虽然只是一个接口，但是其变化却可以有很多，可以根据自己的需求来实现不同的处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关键字&quot;&gt;&lt;a href=&quot;#关键字&quot; class=&quot;headerlink&quot; title=&quot;关键字&quot;&gt;&lt;/a&gt;关键字&lt;/h1&gt;&lt;p&gt;Go语言设计的关键字，了解这些关键字有助于命名变量的冲突避免&lt;/p&gt;
&lt;h3 id=&quot;go的二十五个关键字&quot;&gt;&lt;a href=&quot;#g</summary>
      
    
    
    
    
    <category term="Go" scheme="http://xiaobazeo.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>面经-深信服GO一二面</title>
    <link href="http://xiaobazeo.github.io/2023/09/28/%E9%9D%A2%E7%BB%8F-%E6%B7%B1%E4%BF%A1%E6%9C%8DGO%E4%B8%80%E4%BA%8C%E9%9D%A2/"/>
    <id>http://xiaobazeo.github.io/2023/09/28/%E9%9D%A2%E7%BB%8F-%E6%B7%B1%E4%BF%A1%E6%9C%8DGO%E4%B8%80%E4%BA%8C%E9%9D%A2/</id>
    <published>2023-09-28T14:24:11.000Z</published>
    <updated>2023-09-29T08:47:13.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="算法：30min"><a href="#算法：30min" class="headerlink" title="算法：30min"></a>算法：30min</h3><p>（1）合并三个升序字符串，不能创建新的链表，而是使用已有链表实现。——手撕</p><p>（2）在一个长字符串里面，找出是否出现过的某个字符或子字符串。（遍历或者hashset手撕）</p><h3 id="场景题："><a href="#场景题：" class="headerlink" title="场景题："></a>场景题：</h3><p>（1）给两篇文章，怎么从文章1中找出文章2重复的内容，前提是：内存资源有限。</p><p>考虑因素：内存有限、高效</p><p>深度：除了使用哈希、布隆、MySQL、分段比较这些有没有其他的方法？</p><p>引申问题：如果有五个服务器、现在需要进行负载均衡，可以怎么实现？（哈希取模，虚拟地址分配到哈希环，实现虚拟地址和服务器地址映射）</p><p>（2）如果有一个10G的文件在服务器中，我现在客户端需要从服务器下载，但是网络不是很稳定，并且能保证用户能下载完文件，传输数据用的udp协议不是tcp协议，应该需要注意些什么？</p><p>考虑因素：网络不稳定，传输方式居然是udp。。。</p><p>感觉在应用层实现一个tcp机制，保证数据传输的有序、可靠性。</p><h3 id="常见八股："><a href="#常见八股：" class="headerlink" title="常见八股："></a>常见八股：</h3><p>（1）http和https之间区别？</p><p>（2）为什么现在大部分请求还是http而不是rpc？</p><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><h3 id="项目："><a href="#项目：" class="headerlink" title="项目："></a>项目：</h3><p>（1）比较熟悉的项目是什么？</p><p>（2）微布校园的难点有哪些？怎么解决？（缓存雪崩和击穿、缓存和数据库一致性问题、慢SQL优化）</p><p>（3）如果缓存放到一个进程中去读取会出现什么问题？</p><h3 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h3><p>（1）如果服务器资源有限如何合理利用缓存？（我的理解是部分经常读的数据写到缓存，经常就修改的就不写入缓存、从数据库拉取）</p><p>（2）如果资源有限，有大量数据需要处理，怎么去合理利用内存？（我想的是分段处理数据，类似于MySQL的分页查询，分段处理数据）</p><h3 id="常见八股"><a href="#常见八股" class="headerlink" title="常见八股"></a>常见八股</h3><p>（1）怎么获取http请求的一些头部、body部分的？</p><p>（2）http请求的一些数据是怎么到达代码中的？ （没有回答上来）</p><p>（3）http中post和get请求有什么区别？</p><p>（4）http传输数据过程中会有什么问题？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h2&gt;&lt;h3 id=&quot;算法：30min&quot;&gt;&lt;a href=&quot;#算法：30min&quot; class=&quot;headerlink&quot; title=&quot;算法：30min&quot;</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面经-睿联校招一面-2023-9-20</title>
    <link href="http://xiaobazeo.github.io/2023/09/20/%E9%9D%A2%E7%BB%8F-%E7%9D%BF%E8%81%94%E6%A0%A1%E6%8B%9B%E4%B8%80%E9%9D%A2-2023-9-20/"/>
    <id>http://xiaobazeo.github.io/2023/09/20/%E9%9D%A2%E7%BB%8F-%E7%9D%BF%E8%81%94%E6%A0%A1%E6%8B%9B%E4%B8%80%E9%9D%A2-2023-9-20/</id>
    <published>2023-09-20T07:15:43.000Z</published>
    <updated>2023-09-29T07:46:36.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux文件权限有那些？"><a href="#Linux文件权限有那些？" class="headerlink" title="Linux文件权限有那些？"></a>Linux文件权限有那些？</h2><h2 id="怎么控制文件权限？x权限是用来干什么的？"><a href="#怎么控制文件权限？x权限是用来干什么的？" class="headerlink" title="怎么控制文件权限？x权限是用来干什么的？"></a>怎么控制文件权限？x权限是用来干什么的？</h2><h2 id="操作系统中，进程和线程区别？"><a href="#操作系统中，进程和线程区别？" class="headerlink" title="操作系统中，进程和线程区别？"></a>操作系统中，进程和线程区别？</h2><h2 id="操作系统中的交换分区作用"><a href="#操作系统中的交换分区作用" class="headerlink" title="操作系统中的交换分区作用"></a>操作系统中的交换分区作用</h2><h2 id="MySQL中幻读和脏读的区别"><a href="#MySQL中幻读和脏读的区别" class="headerlink" title="MySQL中幻读和脏读的区别"></a>MySQL中幻读和脏读的区别</h2><h2 id="MySQL中聚簇索引和非聚簇索引的区别"><a href="#MySQL中聚簇索引和非聚簇索引的区别" class="headerlink" title="MySQL中聚簇索引和非聚簇索引的区别"></a>MySQL中聚簇索引和非聚簇索引的区别</h2><h2 id="MySQL的乐观锁和悲观锁"><a href="#MySQL的乐观锁和悲观锁" class="headerlink" title="MySQL的乐观锁和悲观锁"></a>MySQL的乐观锁和悲观锁</h2><h2 id="为什么MySQL使用B-树？"><a href="#为什么MySQL使用B-树？" class="headerlink" title="为什么MySQL使用B+树？"></a>为什么MySQL使用B+树？</h2><h2 id="什么子网掩码？有什么用？"><a href="#什么子网掩码？有什么用？" class="headerlink" title="什么子网掩码？有什么用？"></a>什么子网掩码？有什么用？</h2><h2 id="为什么说tcp是流式的传输协议"><a href="#为什么说tcp是流式的传输协议" class="headerlink" title="为什么说tcp是流式的传输协议"></a>为什么说tcp是流式的传输协议</h2><h2 id="http的常用请求方法"><a href="#http的常用请求方法" class="headerlink" title="http的常用请求方法"></a>http的常用请求方法</h2><h2 id="URL的组成部分"><a href="#URL的组成部分" class="headerlink" title="URL的组成部分"></a>URL的组成部分</h2><h2 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h2><h2 id="https如何保证传输安全"><a href="#https如何保证传输安全" class="headerlink" title="https如何保证传输安全"></a>https如何保证传输安全</h2><h2 id="刚刚提到的https的密匙协商是什么样的过程？"><a href="#刚刚提到的https的密匙协商是什么样的过程？" class="headerlink" title="刚刚提到的https的密匙协商是什么样的过程？"></a>刚刚提到的https的密匙协商是什么样的过程？</h2><h2 id="Java面向对象的多态的理解"><a href="#Java面向对象的多态的理解" class="headerlink" title="Java面向对象的多态的理解"></a>Java面向对象的多态的理解</h2><h2 id="快排的思想"><a href="#快排的思想" class="headerlink" title="快排的思想"></a>快排的思想</h2><h2 id="JWT的组成，以及怎么后端校验此token是否有效的？"><a href="#JWT的组成，以及怎么后端校验此token是否有效的？" class="headerlink" title="JWT的组成，以及怎么后端校验此token是否有效的？"></a>JWT的组成，以及怎么后端校验此token是否有效的？</h2><h2 id="雪花算法怎么实现不重复的？（从组成的角度回答）"><a href="#雪花算法怎么实现不重复的？（从组成的角度回答）" class="headerlink" title="雪花算法怎么实现不重复的？（从组成的角度回答）"></a>雪花算法怎么实现不重复的？（从组成的角度回答）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux文件权限有那些？&quot;&gt;&lt;a href=&quot;#Linux文件权限有那些？&quot; class=&quot;headerlink&quot; title=&quot;Linux文件权限有那些？&quot;&gt;&lt;/a&gt;Linux文件权限有那些？&lt;/h2&gt;&lt;h2 id=&quot;怎么控制文件权限？x权限是用来干什么的？&quot;</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Netty-Client</title>
    <link href="http://xiaobazeo.github.io/2023/09/14/Netty-Client/"/>
    <id>http://xiaobazeo.github.io/2023/09/14/Netty-Client/</id>
    <published>2023-09-14T08:24:07.000Z</published>
    <updated>2023-09-15T05:59:41.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h2><p>创建引导类，确认线程模型，IO模型，以及业务处理逻辑。</p><p><strong>客户端只需要一个线程模型即可</strong>，毕竟不是服务端不需要一个统一的线程模型去管理很多连接，客户端只需要一个线程模型主动去连接服务端就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        bootstrap</span><br><span class="line">                <span class="comment">// 1.指定线程模型</span></span><br><span class="line">                .group(workerGroup)</span><br><span class="line">                <span class="comment">// 2.指定 IO 类型为 NIO</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">// 3.IO 处理逻辑</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 4.建立连接</span></span><br><span class="line">        bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).addListener(future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接成功!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;连接失败!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>connect</code> 方法返回的是一个 <code>Future</code>，也就是说这个方是异步的，我们通过 <code>addListener</code> 方法可以监听到连接是否成功。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h4 id="attr-方法"><a href="#attr-方法" class="headerlink" title="attr()方法"></a>attr()方法</h4><ul><li>给客户端的Channel绑定自定义属性，通过channel.attr()取出属性，</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;客户端初始化&quot;&gt;&lt;a href=&quot;#客户端初始化&quot; class=&quot;headerlink&quot; title=&quot;客户端初始化&quot;&gt;&lt;/a&gt;客户端初始化&lt;/h2&gt;&lt;p&gt;创建引导类，确认线程模型，IO模型，以及业务处理逻辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端只需要一个线程模</summary>
      
    
    
    
    
    <category term="Netty" scheme="http://xiaobazeo.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty-Server</title>
    <link href="http://xiaobazeo.github.io/2023/09/14/Netty-Server/"/>
    <id>http://xiaobazeo.github.io/2023/09/14/Netty-Server/</id>
    <published>2023-09-14T03:46:36.000Z</published>
    <updated>2023-09-14T09:08:06.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netty服务端初始化"><a href="#Netty服务端初始化" class="headerlink" title="Netty服务端初始化"></a>Netty服务端初始化</h2><p>一般需要两个线程组，一个是用来管理接受新线程的线程组(Boss)，一个是处理每条连接的读写数据的线程组(Worker)，可以理解成老板出去接活，员工干细活。所以服务端的创建关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();<span class="comment">//接受管理新的连接</span></span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();<span class="comment">//处理每条连接的数据读写</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();<span class="comment">//引导类进行服务端的启动操作。</span></span><br><span class="line">        serverBootstrap</span><br><span class="line">                .group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class)<span class="comment">//指定IO模型，也可以指定BIO等其他IO模型（OioServerSocketChannel.class）</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<span class="comment">//childHandler()主要是用来处理每个新连接的数据读写的业务逻辑</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        serverBootstrap.bind(<span class="number">8000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h4 id="handler-方法和childHandler"><a href="#handler-方法和childHandler" class="headerlink" title="handler()方法和childHandler()"></a>handler()方法和childHandler()</h4><ul><li>handler()一般是对服务端启动过程中的一些业务逻辑处理</li><li>childHandler()一般是处理新连接的数据的读写逻辑处理</li></ul><h4 id="attr-方法和childAttr-方法"><a href="#attr-方法和childAttr-方法" class="headerlink" title="attr()方法和childAttr()方法"></a>attr()方法和childAttr()方法</h4><ul><li>attr()方法可以给服务端的channel自定义属性，实际上就是通过一个map维护不同的channel</li><li>childAttr()可以给每一条连接指定自定义属性，后续我们可以通过<code>channel.attr()</code>取出该属性。</li></ul><p>应用场景：</p><ul><li><strong>认证状态跟踪</strong>：您可以使用<code>childAttr()</code>来存储每个客户端连接的身份认证状态，以确保只有经过认证的客户端可以访问服务器资源。</li><li><strong>客户端会话信息</strong>：如果您的服务器需要跟踪每个客户端的会话信息，您可以使用<code>childAttr()</code>来存储会话数据，以便在处理客户端请求时访问它们。</li><li><strong>全局配置</strong>：<code>attr()</code>方法可用于存储服务器级别的全局配置，例如监听端口号或服务器的标识。</li><li><strong>连接统计</strong>：您可以使用<code>attr()</code>和<code>childAttr()</code>来记录连接的统计信息，例如连接的数量、连接的类型等。</li></ul><h4 id="childOption-方法和option-方法"><a href="#childOption-方法和option-方法" class="headerlink" title="childOption()方法和option()方法"></a>childOption()方法和option()方法</h4><ul><li><p><code>childOption()</code>可以给每条连接设置一些TCP底层相关的属性，比如上面，我们设置了两种TCP属性，其中</p><ul><li><code>ChannelOption.SO_KEEPALIVE</code>表示是否开启TCP底层心跳机制，true为开启</li><li><code>ChannelOption.TCP_NODELAY</code>表示是否开启Nagle算法，true表示关闭，false表示开启，通俗地说，如果要求高实时性，有数据发送时就马上发送，就关闭，如果需要减少发送次数减少网络交互，就开启。</li></ul></li><li><p><code>option()</code>方法可以给服务端channel设置一些属性，最常见的就是so_backlog，如下设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p>表示系统用于临时存放已完成三次握手的请求的队列的最大长度，如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</p></li></ul><h4 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind()方法"></a>bind()方法</h4><ul><li>是一个异步方法，返回一个<code>ChannelFuture</code>可以通过给<code>ChannelFuture</code>添加一监听器<code>GenericFutureListener</code>监听端口,在这个监听器的<code>operationComplete</code>方法里面监听绑定是否成功。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.bind(<span class="number">8000</span>).addListener(<span class="keyword">new</span> <span class="title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="built_in">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(Future&lt;? <span class="built_in">super</span> Void&gt; future)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;端口绑定成功!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;端口绑定失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>先创建引导类，指定线程模型，IO模型，连接读写处理逻辑，绑定端口即可启动服务端。</li><li>可以给channel设置一些属性值，设置底层TCP参数</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Netty服务端初始化&quot;&gt;&lt;a href=&quot;#Netty服务端初始化&quot; class=&quot;headerlink&quot; title=&quot;Netty服务端初始化&quot;&gt;&lt;/a&gt;Netty服务端初始化&lt;/h2&gt;&lt;p&gt;一般需要两个线程组，一个是用来管理接受新线程的线程组(Boss)，一</summary>
      
    
    
    
    
    <category term="Netty" scheme="http://xiaobazeo.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Spring-IOC-部分源码解读</title>
    <link href="http://xiaobazeo.github.io/2023/08/26/Spring-IOC-SourceCodeAnalysis/"/>
    <id>http://xiaobazeo.github.io/2023/08/26/Spring-IOC-SourceCodeAnalysis/</id>
    <published>2023-08-25T16:47:58.000Z</published>
    <updated>2023-08-29T02:35:09.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring容器启动"><a href="#Spring容器启动" class="headerlink" title="Spring容器启动"></a>Spring容器启动</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationfile.xml&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code>就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/1.png" alt="1"></p><p>简单介绍一下<strong>FileSystemXmlApplicationContext</strong> 和 <strong>AnnotationConfigApplicationContext</strong> 这两个类</p><p><strong>1、FileSystemXmlApplicationContext</strong> 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p><p><strong>2、AnnotationConfigApplicationContext</strong> 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式。</p><p>利用ClassPathXmlApplicationContext类创建一个实例：</p><p>首先，定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    String <span class="title function_">getMessage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span> <span class="attr">default-autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.javadoop.example.MessageServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，我们就可以跑起来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:application.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;context 启动成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class="line">        <span class="type">MessageService</span> <span class="variable">messageService</span> <span class="operator">=</span> context.getBean(MessageService.class);</span><br><span class="line">        <span class="comment">// 这句将输出: hello world</span></span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>顾名思义，就是一个生产Bean的工厂，负责生产和管理各个Bean实例，刚刚所说的ApplicationContext 实际上就是一个BeanFactory，BeanFactory接口继承结构如下：</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2.png" alt="2"></p><ul><li><p>ListableBeanFactory：根据句Listable可知通过这个接口我们可以获取多个Bean，但是顶层BeanFactory只能每次获取单个Bean实例</p></li><li><p>HierarchicalBeanFactory：通过Hierarchical这个单词可知，我们可以通过这个接口创建多个BeanFactory（<strong>不是多个Bean实例</strong>），然后将多个BeanFactory设置为父子关系。</p></li><li><p>AutowireCapableBeanFactory 用于自动装配Bean的，虽然ApplicationContext 没有继承它，但是可以使用组合，ApplicationContext 的最后一个方法getAutowireCapableBeanFactory()就是组合使用。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;</span><br><span class="line">    String <span class="title function_">getId</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getApplicationName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getDisplayName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="title function_">getStartupDate</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    ApplicationContext <span class="title function_">getParent</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    AutowireCapableBeanFactory <span class="title function_">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConfigurableListableBeanFactory 这个接口比较特殊，继承了第二层的所有三个接口，但是ApplicationContext 没有</li></ul><h2 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h2><h3 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">AbstractXmlApplicationContext</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="type">boolean</span> refresh, ApplicationContext parent)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh(); <span class="comment">// 核心方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="refresh-方法"><a href="#refresh-方法" class="headerlink" title="refresh()方法"></a>refresh()方法</h3><p>介绍一下refresh方法，因为他是ClassPathXmlApplicationContext类构造方法的核心方法，它主要的作用就是用于重建，refresh方法会将原来的ApplicationContext销毁然后重新执行一次初始化操作。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">   <span class="comment">// 这里创建一个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛，类似于MySQL“当前读”防止幻读的时候的间隙锁。</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource。</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器。</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建-Bean-容器前的准备工作"><a href="#创建-Bean-容器前的准备工作" class="headerlink" title="创建 Bean 容器前的准备工作"></a>创建 Bean 容器前的准备工作</h4><p>prepareRefresh()就是用来创建Bean容器之前的准备工作，在讲refresh方法中讲到过，主要是记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 记录启动时间，</span></span><br><span class="line">   <span class="comment">// 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span></span><br><span class="line">   <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">   <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment，初始化上下文环境中的任何占位符属性源</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验 xml 配置文件</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建Bean容器，加载并注册Bean"><a href="#创建Bean容器，加载并注册Bean" class="headerlink" title="创建Bean容器，加载并注册Bean"></a>创建Bean容器，加载并注册Bean</h4><p>obtainFreshBeanFactory() 方法就是用于初始化BeanFactory、加载Bean、注册Bean等这个方法是refresh中最重要的一个部分，<strong>但是这个方法执行结束之后Bean实例并没有生成，也就是说Bean没有完成初始化。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="comment">// 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回刚刚创建的 BeanFactory</span></span><br><span class="line">   <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">   <span class="comment">// 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span></span><br><span class="line">   <span class="comment">// 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前ApplicationContext 是否有 BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化一个 DefaultListableBeanFactory，至于为什么要用这个类是因为前面说的继承图，具体为什么见下方注解</span></span><br><span class="line">      <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">      <span class="comment">// 用于 BeanFactory 的序列化</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载 Bean 到 BeanFactory 中</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？</p><p>前面的BeanFactory中有一个接口叫做ConfigurableListableBeanFactory，它实现了BeanFactory下面一层的所有三个接口，而这个接口只有一个实现类DefaultListableBeanFactory，而实现类DefaultListableBeanFactory实际上间接实现了BeanFactory下的三个接口，所以结论就是，DefaultListableBeanFactory是最牛的BeanFactory。例图如下</p></blockquote><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2.png" alt="2"></p><p>customizeBeanFactory(beanFactory)方法就是配置是否允许BeanDefinition覆盖、是否允许循环引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.allowBeanDefinitionOverriding != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 定义覆盖</span></span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.allowCircularReferences != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 间的循环依赖</span></span><br><span class="line">      beanFactory.setAllowCircularReferences(<span class="built_in">this</span>.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadBeanDefinitions(beanFactory)就是根据配置，加载各个Bean，然后放到BeanFactory中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">   <span class="comment">// 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader来读取加载配置、解析</span></span><br><span class="line">   <span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">   <span class="comment">// resource loading environment.</span></span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="built_in">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="built_in">this</span>);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> <span class="title class_">ResourceEntityResolver</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span></span><br><span class="line"></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 重点来了，继续往下，实际上就是loadBeanDefinitions()方法的重载，这两个方法还是在一个类中</span></span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException &#123;</span><br><span class="line">   Resource[] configResources = getConfigResources();</span><br><span class="line">   <span class="keyword">if</span> (configResources != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 往下看</span></span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   &#125;</span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   <span class="keyword">if</span> (configLocations != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line">   <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 注意这里是个 for 循环，也就是每个文件是一个 resource</span></span><br><span class="line">   <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">      <span class="comment">// 继续往下看</span></span><br><span class="line">      counter += loadBeanDefinitions(resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 最后返回 counter，表示总共加载了多少的 BeanDefinition</span></span><br><span class="line">   <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">EncodedResource</span>(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource.getResource());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 用一个 ThreadLocal 来存放配置文件资源</span></span><br><span class="line">   Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   <span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">      currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">         <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 核心部分是这里，往下面看</span></span><br><span class="line">         <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">            <span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">         <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span><br><span class="line">      <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里就不看了，将 xml 文件转换为 Document 对象</span></span><br><span class="line">      <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line">      <span class="comment">// 继续</span></span><br><span class="line">      <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (...</span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line"><span class="comment">// 返回值：返回从当前配置文件加载了多少数量的 Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">   <span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">   <span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 这里才使用另外一个类(DefaultBeanDefinitionDocumentReader)的方法</span></span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line"><span class="comment">//创建DOM树结构，其中的doRegisterBeanDefinitions()函数主要用于解析xml文件</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.readerContext = readerContext;</span><br><span class="line">   logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line">   <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> doc.getDocumentElement();</span><br><span class="line">   <span class="comment">// 从 xml 根节点开始解析文件</span></span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Spring容器启动&quot;&gt;&lt;a href=&quot;#Spring容器启动&quot; class=&quot;headerlink&quot; title=&quot;Spring容器启动&quot;&gt;&lt;/a&gt;Spring容器启动&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://xiaobazeo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>微布开发-热点动态缓存击穿</title>
    <link href="http://xiaobazeo.github.io/2023/08/20/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E7%83%AD%E7%82%B9%E5%8A%A8%E6%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    <id>http://xiaobazeo.github.io/2023/08/20/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E7%83%AD%E7%82%B9%E5%8A%A8%E6%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</id>
    <published>2023-08-20T09:10:57.000Z</published>
    <updated>2023-09-29T08:08:54.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h3><p>热点动态中的某一条说说因为过期且当时大量用户请求查看动态详情，出现数据库查询压力骤增的情况，从而导致某一热点动态的缓存击穿的情况。</p><h3 id="想法："><a href="#想法：" class="headerlink" title="想法："></a>想法：</h3><p>1、 互斥锁：在热点数据的缓存失效时，可以尝试使用分布式锁来避免多个请求同时访问数据库。在获取锁的情况下，只有一个请求去加载数据并更新缓存，其他请求等待，从而减轻数据库的压力。t</p><ol><li><strong>获取互斥锁：</strong> 当缓存失效时，多个请求会尝试获取一个互斥锁。如果只有一个请求能够成功获取锁，那么它将负责加载数据并更新缓存。</li><li><strong>获取锁成功：</strong> 如果某个请求成功获取了互斥锁，它可以开始加载数据。在加载数据时，需要判断缓存是否已经被其他请求加载（可能在当前请求获取锁的过程中被其他请求加载了），避免重复加载数据。</li><li><strong>更新缓存：</strong> 获取锁成功的请求负责加载数据并更新缓存。在更新缓存之后，释放互斥锁，让其他等待锁的请求有机会获取锁并使用更新后的缓存。</li><li><strong>获取锁失败：</strong> 如果请求获取锁失败，意味着其他请求已经在加载数据和更新缓存了。这些失败的请求可以等待一段时间后再次尝试，或者直接返回默认值，以避免多次同时访问数据库。</li></ol><h3 id="伪代码如下："><a href="#伪代码如下：" class="headerlink" title="伪代码如下："></a>伪代码如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheWithMutexLock</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, T&gt; redisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheWithMutexLock</span><span class="params">(RedisTemplate&lt;String, T&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getOrLoadFromCache</span><span class="params">(String key, Supplier&lt;T&gt; dataLoader, T defaultValue, <span class="type">long</span> lockTimeout)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_PREFIX + key;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试获取互斥锁</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">gotLock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(lockKey, <span class="string">&quot;locked&quot;</span>, lockTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (gotLock) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 检查缓存是否已经加载</span></span><br><span class="line">                    <span class="type">T</span> <span class="variable">cachedValue</span> <span class="operator">=</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">                    <span class="keyword">if</span> (cachedValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> cachedValue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 加载数据并更新缓存</span></span><br><span class="line">                    <span class="type">T</span> <span class="variable">loadedValue</span> <span class="operator">=</span> dataLoader.get();</span><br><span class="line">                    redisTemplate.opsForValue().set(key, loadedValue);</span><br><span class="line">                    <span class="keyword">return</span> loadedValue;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    redisTemplate.delete(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取锁失败，返回默认值</span></span><br><span class="line">                <span class="keyword">return</span> defaultValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> defaultValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>getOrLoadFromCache</code> 方法尝试获取互斥锁，如果获取成功，它会检查缓存是否已经加载数据，如果没有则加载数据并更新缓存。如果获取锁失败，就直接返回默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RedisTemplate&lt;String, String&gt; redisTemplate = ...; <span class="comment">// 初始化 RedisTemplate</span></span><br><span class="line">CacheWithMutexLock&lt;String&gt; cache = <span class="keyword">new</span> <span class="title class_">CacheWithMutexLock</span>&lt;&gt;(redisTemplate);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;my_key&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> cache.getOrLoadFromCache(key, </span><br><span class="line">    () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 从数据库或其他数据源加载数据的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Loaded data&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;Default value&quot;</span>,</span><br><span class="line">    <span class="number">5000</span> <span class="comment">// 互斥锁的超时时间，单位为毫秒</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>RedisTemplate</code> 的一个简化实现。使用互斥锁来协调多个请求的数据加载和缓存更新，可以避免缓存击穿问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;业务场景：&quot;&gt;&lt;a href=&quot;#业务场景：&quot; class=&quot;headerlink&quot; title=&quot;业务场景：&quot;&gt;&lt;/a&gt;业务场景：&lt;/h3&gt;&lt;p&gt;热点动态中的某一条说说因为过期且当时大量用户请求查看动态详情，出现数据库查询压力骤增的情况，从而导致某一热点动态的缓</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Spring-DesignPattern</title>
    <link href="http://xiaobazeo.github.io/2023/08/20/Spring-DesignPattern/"/>
    <id>http://xiaobazeo.github.io/2023/08/20/Spring-DesignPattern/</id>
    <published>2023-08-20T02:51:51.000Z</published>
    <updated>2023-09-28T16:17:25.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="控制反转和依赖注入"><a href="#控制反转和依赖注入" class="headerlink" title="控制反转和依赖注入"></a>控制反转和依赖注入</h2><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h2 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a>模版方法</h2><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;控制反转和依赖注入&quot;&gt;&lt;a href=&quot;#控制反转和依赖注入&quot; class=&quot;headerlink&quot; title=&quot;控制反转和依赖注入&quot;&gt;&lt;/a&gt;控制反转和依赖注入&lt;/h2&gt;&lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://xiaobazeo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-AOP</title>
    <link href="http://xiaobazeo.github.io/2023/08/20/Spring-AOP/"/>
    <id>http://xiaobazeo.github.io/2023/08/20/Spring-AOP/</id>
    <published>2023-08-20T02:51:09.000Z</published>
    <updated>2023-08-25T16:30:29.513Z</updated>
    
    <content type="html"><![CDATA[<p>​    AOP（面向切面编程）：就是把公共逻辑抽出来，让开发者更好的专注于业务逻辑的开发，AOP是<a href>OOP</a>的补充，OOP是面向类和对象的，但是AOP是面向不同切面的，一个切面可以横跨多个类和对象去操作，极大提高开发效率。</p><p>​    例如一个订单的创建，可能需要下列四个步骤</p><p>​    1、权限校验</p><p>​    2、事务管理</p><p>​    3、创建订单</p><p>​    4、日志打印</p><p>​    如果使用AOP的思想，其实就可以把四个步骤抽象成四个切面，让开发者专注于第3个切面，其他的切面都用基础通用的逻辑（就是抽象出来的公共逻辑），统计交给AOP封装管理。</p><h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><p><strong>通过代理模式实现</strong>，实现方式有两种，一种事基于Java原生的动态代理，一种是基于cglib的动态代理。</p><p>Spring AOP默认使用JDK的原生代理，可以代理任何接口，但是不能代理没有接口的类，所以使用cglib来实现动态代理没有接口的类。</p><h3 id="AOP的业务场景："><a href="#AOP的业务场景：" class="headerlink" title="AOP的业务场景："></a>AOP的业务场景：</h3><p>1、参数校验</p><p>当使用AOP思想实现参数校验功能时，你可以创建一个AOP切面来拦截需要校验的方法，并从<code>HttpServletRequest</code>中获取JWT参数进行校验。以下是一个基本示例：</p><ul><li><strong>创建自定义注解：</strong> 创建一个自定义注解，用于标记需要进行JWT校验的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ValidateJWT &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>编写AOP切面：</strong> 创建一个AOP切面，用于拦截带有<code>@ValidateJWT</code>注解的方法，并从<code>HttpServletRequest</code>中获取JWT参数进行校验。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTValidationAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换为你的JWT密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="string">&quot;your-secret-key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;@annotation(com.example.ValidateJWT)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validateJWT</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwtToken</span> <span class="operator">=</span> extractTokenFromRequest(request);</span><br><span class="line">        <span class="keyword">if</span> (jwtToken == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;JWT token is missing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwtToken).getBody();</span><br><span class="line">            <span class="comment">// 在这里可以根据需要进一步处理claims，比如判断过期时间、验证issuer等</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid JWT token&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">extractTokenFromRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorizationHeader</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (authorizationHeader != <span class="literal">null</span> &amp;&amp; authorizationHeader.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> authorizationHeader.substring(<span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了<code>@Autowired</code>来注入<code>HttpServletRequest</code>，然后在AOP切面中使用<code>extractTokenFromRequest</code>方法从请求头中提取JWT token。然后，我们在校验逻辑中解析JWT token，并根据需要处理JWT的内容。这个切面会在带有<code>@ValidateJWT</code>注解的方法执行前进行JWT校验。</p><ul><li><strong>在需要校验的方法上添加注解：</strong> 在需要校验JWT的方法上添加<code>@ValidateJWT</code>注解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YourService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ValidateJWT</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里处理请求，前置通知会在此方法执行前进行JWT校验</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，<code>processRequest</code>方法会在执行前进行JWT校验，确保JWT的有效性。同时，你可以将类似的校验逻辑应用于其他带有JWT的方法，以提高代码的安全性和可维护性。请注意，实际项目中可能需要根据业务需求进行更复杂的校验逻辑。</p><p>2、缓存逻辑</p><p>当使用AOP思想来实现Redis的缓存逻辑时，你可以按照以下步骤来操作：</p><ol><li><p><strong>引入依赖：</strong> 在你的项目中引入Spring Data Redis依赖，确保你能够使用Redis作为缓存。</p></li><li><p><strong>创建缓存切面：</strong> 创建一个AOP切面，用于拦截带有<code>@CacheableResult</code>注解的方法，并将方法的返回值缓存到Redis。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;@annotation(com.example.CacheableResult)&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cacheMethodResult</span><span class="params">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().toShortString();</span><br><span class="line">        redisTemplate.opsForValue().set(methodName, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个切面中，我们使用了<code>@Autowired</code>注入了<code>RedisTemplate</code>，这是Spring提供的与Redis交互的工具类。<code>cacheMethodResult</code>方法会在带有<code>@CacheableResult</code>注解的方法执行后执行，将方法返回的结果存储到Redis缓存中，使用方法的名称作为缓存的键。</p><ol start="3"><li><strong>创建自定义注解：</strong> 创建一个自定义注解，用于标记需要进行缓存的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheableResult &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>在需要缓存的方法上添加注解：</strong> 在需要进行缓存的方法上添加<code>@CacheableResult</code>注解。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YourService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CacheableResult</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFromDatabase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以模拟从数据库中获取数据的操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Data from database&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>getFromDatabase</code>方法被<code>@CacheableResult</code>注解标记，当这个方法被调用并返回结果时，切面会拦截这个方法的执行，将返回的数据存储到Redis缓存中。</p><ol start="5"><li><strong>启用AOP和组件扫描：</strong> 在Spring Boot的配置类上添加<code>@EnableAspectJAutoProxy</code>注解，以启用AOP功能，同时确保你的切面和服务类被正确地扫描到。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 配置其他内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上步骤，你就可以使用AOP思想实现基本的Redis缓存逻辑。当使用带有<code>@CacheableResult</code>注解的方法时，切面会自动将方法的结果存储到Redis缓存中。在实际项目中，你可能还需要考虑缓存的失效策略、数据更新时的缓存更新等细节。同时，Spring框架也提供了更丰富的缓存管理功能，你可以根据具体的需求进行选择和配置。</p><p>3、日志打印</p><p>实际上在日志打印的场景中，不一定需要创建自定义注解。通常情况下，日志打印是一种通用的操作，因此你可以直接在切面中定义切点，而不必引入自定义注解。</p><p>以下是一个更准确的示例，展示如何使用AOP来实现日志打印功能：</p><ol><li><strong>创建日志切面：</strong> 创建一个AOP切面，用于拦截方法的执行并记录日志。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(LoggingAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* com.example.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logMethodExecution</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().toShortString();</span><br><span class="line">        logger.info(<span class="string">&quot;Method &#123;&#125; executed&quot;</span>, methodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个切面中，<code>LoggingAspect</code>会拦截<code>com.example</code>包下所有方法的执行，在方法执行后使用<code>logger</code>记录方法的名称。</p><ol start="2"><li><strong>启用AOP和组件扫描：</strong> 在Spring Boot的配置类上添加<code>@EnableAspectJAutoProxy</code>注解，以启用AOP功能，同时确保你的切面被正确地扫描到。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 配置其他内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保<code>basePackages</code>中的包路径是你的切面和服务类所在的包。</p><ol start="3"><li><strong>调用方法：</strong> 在业务逻辑中调用方法，切面会在方法执行后记录日志。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YourService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Processed result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，当调用<code>process</code>方法时，切面会在方法执行后使用日志记录相关信息。</p><ol start="4"><li><strong>配置日志输出：</strong> 在<code>src/main/resources</code>目录下创建<code>logback.xml</code>文件，根据你的需求配置日志的输出格式、级别等。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过以上步骤，你就可以使用AOP思想实现基本的日志打印功能。当执行方法时，切面会在方法执行后记录相关的日志信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    AOP（面向切面编程）：就是把公共逻辑抽出来，让开发者更好的专注于业务逻辑的开发，AOP是&lt;a href&gt;OOP&lt;/a&gt;的补充，OOP是面向类和对象的，但是AOP是面向不同切面的，一个切面可以横跨多个类和对象去操作，极大提高开发效率。&lt;/p&gt;
&lt;p&gt;​    例如</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://xiaobazeo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-IOC</title>
    <link href="http://xiaobazeo.github.io/2023/08/20/Spring-IOC/"/>
    <id>http://xiaobazeo.github.io/2023/08/20/Spring-IOC/</id>
    <published>2023-08-20T02:50:57.000Z</published>
    <updated>2023-08-25T16:48:30.509Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><p>所谓的IOC就是Inversion Of Control，也就是控制反转，其实就是对于某个对象A，原来的控制权在B手上，B想用就能用，想不用就不用，但是现在把控制权交还给了A，只有A给了别人权限才能用，这就是控制反转。</p><p>没有IOC的时候，举例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//此时就是我们所说的控制权在B手上，也就是控制(不是控制反转)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(a);<span class="comment">//此时B对A控制使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了IOC时使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//此时控制权在A自己手上，可以直接使用，当然如果对象A没有注入到容器之中的话，B就不能使用。</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(a);<span class="comment">//此时B对A控制使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结下来就是：IOC（不是指的Spring IOC容器，Spring IOC容器是实现IOC思想的一个载体）实际上就是一种设计思想，可以通过Spring框架对一些原本本来需要手动创建的对象，交由Spring框架统一管理。</p><p>​    如果没有Spring的IOC容器的话，我们要使用某个对象的时候只能通过创建对象的方式解决，但是有了SpringIOC容器之后，对象就会交由IOC容器创建并管理，当我们想使用的时候就直接从容器中获取即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是IOC&quot;&gt;&lt;a href=&quot;#什么是IOC&quot; class=&quot;headerlink&quot; title=&quot;什么是IOC&quot;&gt;&lt;/a&gt;什么是IOC&lt;/h3&gt;&lt;p&gt;所谓的IOC就是Inversion Of Control，也就是控制反转，其实就是对于某个对象A，原来的控制</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://xiaobazeo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-k个一组翻转链表</title>
    <link href="http://xiaobazeo.github.io/2023/08/18/leetcode-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://xiaobazeo.github.io/2023/08/18/leetcode-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2023-08-18T08:36:29.000Z</published>
    <updated>2023-08-18T08:59:44.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p><p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/reverse_ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="string">[2,1,4,3,5]</span></span><br></pre></td></tr></table></figure><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/reverse_ex2.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="string">[1,2,3,4,5]</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">[3,2,1,4,5]</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ul><li>局部翻转</li><li>k &gt; 剩余局部链表长度时，这部分链表无需翻转</li></ul><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li><p>初始化</p><p><code>ListNode dummy = new ListNode(0,head);</code></p></li><li><p>设置指针实现局部翻转</p><p><code>ListNode pre = dummy,end = dummy</code></p></li><li><p>end.next != null 则遍历链表</p><ol><li><p>根据k确定第一组局部链表的尾部指针</p><p><code>for(int i = 0; i &lt; k &amp;&amp; end != null; i++) end = end.next;</code></p><p>此时<code>end == null</code>时，说明剩余的局部链表长度小于k，直接跳出循环无需翻转链表。</p></li><li><p>确定局部链表起始位置及下一组的起始位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start = pre.next;</span><br><span class="line">next = end.next;</span><br></pre></td></tr></table></figure></li><li><p>断开end的后续链表，并调用翻转函数使pre.next连接翻转后的链表。</p><p><code>pre.next = reverse(start);</code></p></li><li><p>重新连接被翻转和未翻转的部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start.next = next;<span class="comment">//连接后面未翻转的链表</span></span><br><span class="line">pre = next;<span class="comment">//重置pre和end指针开始新的一轮链表组的翻转</span></span><br><span class="line">end = pre;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>返回dummy后面所有已经翻转的链表</p></li></ol><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy, end = dummy;</span><br><span class="line">        <span class="keyword">while</span>(end.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="literal">null</span>; i++)&#123;</span><br><span class="line">                end = end.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(end == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> pre.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> end.next;</span><br><span class="line">            end.next = <span class="literal">null</span>; </span><br><span class="line">            pre.next = reverse(start);</span><br><span class="line">            start.next = next;</span><br><span class="line">            pre = start;</span><br><span class="line">            end = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;给你链表的头节点 &lt;code&gt;head&lt;/code&gt; ，每 &lt;code&gt;k&lt;/code&gt; 个节点一组进行翻转，请你返</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>面经-借钱包交易平台Java开发实习</title>
    <link href="http://xiaobazeo.github.io/2023/08/10/%E9%9D%A2%E7%BB%8F-%E5%80%9F%E9%92%B1%E5%8C%85%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0Java%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/"/>
    <id>http://xiaobazeo.github.io/2023/08/10/%E9%9D%A2%E7%BB%8F-%E5%80%9F%E9%92%B1%E5%8C%85%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0Java%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/</id>
    <published>2023-08-10T05:14:54.000Z</published>
    <updated>2023-08-18T12:46:41.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如果对于jdk版本升级，对于jvm的一些参数修改有哪些？"><a href="#如果对于jdk版本升级，对于jvm的一些参数修改有哪些？" class="headerlink" title="如果对于jdk版本升级，对于jvm的一些参数修改有哪些？"></a>如果对于jdk版本升级，对于jvm的一些参数修改有哪些？</h2><ol><li>-Xmx 和 -Xms：这些参数用于设置 JVM 的最大堆内存和初始堆内存大小。在 JDK 版本升级后，由于可能存在新的特性或改进，建议重新评估应用程序的内存需求，并相应地调整这些参数。</li><li>-XX:NewRatio 和 -XX:SurvivorRatio：这些参数用于调整新生代（Young Generation）和老年代（Old Generation）的比例和新生代中 Eden 区和 Survivor 区的比例。在 JDK 版本升级后，新的默认比例可能会有所变化，可能需要重新设置这些参数以优化垃圾回收性能。</li><li>-XX:+UseConcMarkSweepGC 和 -XX:+UseG1GC 等：这些参数用于选择不同的垃圾回收器。随着 JDK 版本的升级，可能会引入新的垃圾回收器或对现有的回收器进行优化，因此需要根据应用程序的特性和需求选择合适的垃圾回收器和相应的参数。</li><li>-XX:MaxMetaspaceSize：在 JDK 8 及之前的版本中，用于设置永久代（Permanent Generation）的最大大小。但从 JDK 8 开始，永久代被移除，取而代之的是 Metaspace。因此，在 JDK 版本升级后，如果之前使用了永久代的参数，需要调整为 Metaspace 相关的参数。</li><li>其他新的 -XX 开头的参数：随着 JDK 版本的升级，可能会引入新的 JVM 参数，用于控制新的特性或优化性能。因此，在升级后应该查阅新的文档，了解这些新参数的用法和影响，并根据需要进行配置。</li></ol><h2 id="介绍包装类和基本数据类型的自动拆箱和自动装箱"><a href="#介绍包装类和基本数据类型的自动拆箱和自动装箱" class="headerlink" title="介绍包装类和基本数据类型的自动拆箱和自动装箱?"></a>介绍包装类和基本数据类型的自动拆箱和自动装箱?</h2><p>自动装箱：将基本数据类型转换成对应的包装类型</p><p>自动拆箱：将包装类型转换成对应的基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//装箱  Integer.valueOf(10);</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;<span class="comment">//拆箱   n = i.intValue();</span></span><br></pre></td></tr></table></figure><h2 id="什么常见场景会自动触发自动装箱和自动拆箱？"><a href="#什么常见场景会自动触发自动装箱和自动拆箱？" class="headerlink" title="什么常见场景会自动触发自动装箱和自动拆箱？"></a>什么常见场景会自动触发自动装箱和自动拆箱？</h2><p>自动装箱场景：</p><ul><li>将基本数据类型赋值给对应的包装类型，比如:Integer i = 10;</li><li>将基本数据类型作为参数赋值给接受包装类型的方法。</li></ul><p>自动拆箱场景：</p><ul><li>将包装类型赋值给对应的基本数据类型，比如<code>Integer i = 10; int n = i;</code></li><li>将包装类型作为参数赋值给接受对应基本数据类型的方法。</li></ul><h2 id="对于Integer类型的数据进行比较大小需要注意哪些问题？"><a href="#对于Integer类型的数据进行比较大小需要注意哪些问题？" class="headerlink" title="对于Integer类型的数据进行比较大小需要注意哪些问题？"></a>对于Integer类型的数据进行比较大小需要注意哪些问题？</h2><p>1、比较大小：使用equals方法，因为equals方法比较的是对象的值，而==比较的是对象的引用地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">n == i; <span class="comment">// YES</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">a == b;<span class="comment">//NO，因为Integer会缓存-128-127的对象，此时==号比较的是a和b的引用地址，但是此时a和b的值不在此缓存范围内，会重新创建两个不同的引用，进行引用地址的比较。</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">c == d;<span class="comment">//NO</span></span><br><span class="line">c.equals(d);<span class="comment">//YES</span></span><br></pre></td></tr></table></figure><p>2、尽量避免频繁的拆箱装箱，频繁的拆装箱会造成一些不必要的资源损耗。</p><p>3、避免空指针异常：如果包装类型定义了null，此时进行自动拆箱的时候会抛出NPE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n= <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n;<span class="comment">//会抛出NPE,NullPointException</span></span><br></pre></td></tr></table></figure><h2 id="为什么是选择equals方法去比较Integer这一类包装类类型的数据？"><a href="#为什么是选择equals方法去比较Integer这一类包装类类型的数据？" class="headerlink" title="为什么是选择equals方法去比较Integer这一类包装类类型的数据？"></a>为什么是选择equals方法去比较Integer这一类包装类类型的数据？</h2><p>使用==号的时候，如果Integer是通过<code>创建对象或者自动装箱的数据在-128~127的范围就会返回false</code>，==比较的是两个Integer对象的引用地址，如果出现刚刚所述的两种情况，是因为他们此时的所属对象的引用地址不一样导致的。</p><p>而使用equals方法比较的是两个对象之间的值，而不是引用地址。</p><h2 id="在重写一个对象的时候为什么要重写equals-以及hashcode-？"><a href="#在重写一个对象的时候为什么要重写equals-以及hashcode-？" class="headerlink" title="在重写一个对象的时候为什么要重写equals()以及hashcode()？"></a>在重写一个对象的时候为什么要重写equals()以及hashcode()？</h2><p>因为两个相等的对象的hashCode必须相等，不然如果重写了equals方法而没有重写hashCode方法的话可能会出现equals方法判断两个对象相等，但是其hashCode不相等的情况。</p><h2 id="hashmap如何解决哈希碰撞-哈希冲突-问题？"><a href="#hashmap如何解决哈希碰撞-哈希冲突-问题？" class="headerlink" title="hashmap如何解决哈希碰撞(哈希冲突)问题？"></a>hashmap如何解决哈希碰撞(哈希冲突)问题？</h2><h2 id="hashmap在存放一个键值对的时候过程是怎么样的？"><a href="#hashmap在存放一个键值对的时候过程是怎么样的？" class="headerlink" title="hashmap在存放一个键值对的时候过程是怎么样的？"></a>hashmap在存放一个键值对的时候过程是怎么样的？</h2><p>1、对键进行hash计算来确定键值存放的位置</p><p>2、通过取模运算找到具体存储哈希键值对的位置即桶</p><p>3、将键值对存储在对应的桶中，如果产生了哈希冲突就会作为一个节点存入到链表或者红黑树的头部。</p><h2 id="当hashmap转换成红黑树后什么情况下会转回链表？"><a href="#当hashmap转换成红黑树后什么情况下会转回链表？" class="headerlink" title="当hashmap转换成红黑树后什么情况下会转回链表？"></a>当hashmap转换成红黑树后什么情况下会转回链表？</h2><p>当红黑树的节点数小于等于6的时候，会转回链表的形式进行键值对的存储，因为hashCode符合泊松分布，哈希冲突造成链表长度等于6的情况比较高，且红黑树维护节点开销会比链表维护所需开销大，如果是长度等于7的情况的话，可能会导致频繁的链表和红黑树的转换开销和资源浪费。</p><blockquote><p><strong>为什么是<strong><strong>链表</strong></strong>等于8的时候转？</strong></p><p>因为经过统计，当hashCode遵循泊松分布时，因为哈希冲突造成桶的链表长度大于等于8的概率只有0.00000006，所以根据数学推算决定当链表长度等于8时转换成红黑树。而且转换成红黑树之后的维护开销会比链表高很多，所以不会随随便便进行红黑树和链表之间的互相转换。</p></blockquote><h2 id="常见集合list、map、set、queue之间的区别"><a href="#常见集合list、map、set、queue之间的区别" class="headerlink" title="常见集合list、map、set、queue之间的区别"></a>常见集合list、map、set、queue之间的区别</h2><p>list：元素有序，可重复</p><p>set：元素无序，不可重复</p><p>map：以key-value方式存储，key无序、不可重复，value无序、可重复，每个键最多映射到一个值。</p><p>queue：元素有序，可重复。</p><h2 id="关于构建一个线程池我们需要配置的核心参数有哪些？"><a href="#关于构建一个线程池我们需要配置的核心参数有哪些？" class="headerlink" title="关于构建一个线程池我们需要配置的核心参数有哪些？"></a>关于构建一个线程池我们需要配置的核心参数有哪些？</h2><p><strong><code>ThreadPoolExecutor</code></strong> <strong>3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code></strong> <strong>:</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code></strong> <strong>:</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>****:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。</li></ul><h2 id="InnoDB的索引数据结构是什么？介绍一下b-树"><a href="#InnoDB的索引数据结构是什么？介绍一下b-树" class="headerlink" title="InnoDB的索引数据结构是什么？介绍一下b+树"></a>InnoDB的索引数据结构是什么？介绍一下b+树</h2><p>B+树</p><ul><li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。</li><li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li><li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</li></ul><h2 id="为什么B-树千万级别在MySQL只有3-4层？"><a href="#为什么B-树千万级别在MySQL只有3-4层？" class="headerlink" title="为什么B+树千万级别在MySQL只有3-4层？"></a>为什么B+树千万级别在MySQL只有3-4层？</h2><p>非叶子结点一般只有键+指针，也就是8+6 = 14byte，那么一个非叶子结点可以存储的键+指针个数是16<em>1024/14=1170个单元数，如果一条记录是1k，那么一个节点能存16条记录，那么两层的B+树就是16 * 1170=18720条记录，3层的话就是16</em>1170*1170=2190w+条记录。</p><h2 id="Innodb的默认隔离事务级别是什么？什么是可重复读？"><a href="#Innodb的默认隔离事务级别是什么？什么是可重复读？" class="headerlink" title="Innodb的默认隔离事务级别是什么？什么是可重复读？"></a>Innodb的默认隔离事务级别是什么？什么是可重复读？</h2><p>可重复读。</p><p>指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的</p><h2 id="在可重复读的事务隔离级别下，什么场景下会出现幻读的情况？"><a href="#在可重复读的事务隔离级别下，什么场景下会出现幻读的情况？" class="headerlink" title="在可重复读的事务隔离级别下，什么场景下会出现幻读的情况？"></a>在可重复读的事务隔离级别下，什么场景下会出现幻读的情况？</h2><p>场景一（针对快照读）：</p><p>以下表为例：</p><p><img src="https://qazbc6jrkh1.feishu.cn/space/api/box/stream/download/asynccode/?code=YThkOTc3ZDZmNzg5ZDgxNTdmYjQxNzExNDNjN2YyMWJfOTdGNnVRc2NCY0xPSGpTa2pNVWo3VDJKS1I3WTI2b0FfVG9rZW46Tzg0eWJQUVpHb0tNYTZ4TnVYRGM0dktGbkRiXzE2OTIzNjI3NDU6MTY5MjM2NjM0NV9WNA" alt="img"></p><p>事务A执行查询id = 5的记录，此时表中没有此记录，所以查不出来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#事务A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>此时事务B添加一条id = 5的记录，并提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#事务B</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t_stu <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">&#x27;小美&#x27;</span>, <span class="number">18</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">commit</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>此时，<strong>事务A更新id=5的记录，并查询id=5的记录，此时就能看到事务B插入的记录。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 事务 A</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> t_stu <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;小林coding&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec)<span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_stu <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 小林coding   <span class="operator">|</span>   <span class="number">18</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>时序图如下：</p><p><img src="https://qazbc6jrkh1.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQ2YmI5MDJlMjEwNDY0MDNlN2JmYmYzM2RkOTQ1M2NfUHVJbTIybHFoWHNnVEwxMFdjdmNOZU5oUk5CU05mdFlfVG9rZW46Q2xWOGJnczV6b1o5bk14OG1Za2NaQ1h1blVlXzE2OTIzNjI3NDU6MTY5MjM2NjM0NV9WNA" alt="img"></p><p>场景二（针对当前读）：</p><ul><li>T1时刻，事务A先执行了快照读语句:select * from t_test where id &gt; 100 得到了 3 条记录;</li><li>T2时刻，事务B插入了一条id = 200的记录并提交</li><li>T3时刻，事务A执行当前读：select * from t_test where id &gt; 100;就会得到4条记录</li></ul><h2 id="Maven添加资源包的时候，如何操作？"><a href="#Maven添加资源包的时候，如何操作？" class="headerlink" title="Maven添加资源包的时候，如何操作？"></a>Maven添加资源包的时候，如何操作？</h2><p>在Maven项目中添加资源包（例如配置文件、图像文件、文本文件等）通常涉及以下步骤：</p><ol><li><p><strong>创建资源文件夹</strong>：</p><p>在项目的源代码目录（src/main/java）旁边创建一个资源文件夹，通常命名为”resources”，这是Maven默认的资源文件夹。</p></li><li><p><strong>将资源文件放入资源文件夹</strong>：</p><p>将您的资源文件（例如配置文件、图像等）放入刚刚创建的”resources”文件夹中。</p></li><li><p><strong>更新项目配置文件（pom.xml）</strong>：</p><p>打开项目的<code>pom.xml</code>文件，并在<code>&lt;build&gt;</code>标签下的<code>&lt;resources&gt;</code>标签中配置资源文件夹。示例如下：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 可选：可以配置&lt;filtering&gt;标签来进行资源文件中的属性替换 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可以添加多个&lt;resource&gt;标签来包含多个资源文件夹 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   此配置告诉Maven在构建项目时将资源文件夹中的内容包含在生成的JAR或WAR文件中。</p><ol start="4"><li><p><strong>运行<strong><strong>Maven</strong></strong>构建命令</strong>：</p><p>打开终端或命令提示符，进入项目根目录，然后运行以下命令来执行Maven构建：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><p>   或者如果只需要将资源添加到生成的JAR或WAR中，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn resources:resources</span><br></pre></td></tr></table></figure><ol start="5"><li><p><strong>访问资源文件</strong>：</p><p>在Java代码中，您可以使用类加载器来访问位于资源文件夹中的资源文件。例如，使用以下代码来加载资源文件：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;path/to/resource.file&quot;</span>);</span><br></pre></td></tr></table></figure><p>   其中，<code>path/to/resource.file</code>是资源文件在资源文件夹中的相对路径。</p><h2 id="Maven的常用命令有哪些？"><a href="#Maven的常用命令有哪些？" class="headerlink" title="Maven的常用命令有哪些？"></a>Maven的常用命令有哪些？</h2><h2 id="缓存雪崩、缓存和数据库一致性问题的解决方案？"><a href="#缓存雪崩、缓存和数据库一致性问题的解决方案？" class="headerlink" title="缓存雪崩、缓存和数据库一致性问题的解决方案？"></a>缓存雪崩、缓存和数据库一致性问题的解决方案？</h2><h2 id="如果此时使用的是cookie-session机制，而且是分布式系统的话，怎么实现用户鉴权问题？"><a href="#如果此时使用的是cookie-session机制，而且是分布式系统的话，怎么实现用户鉴权问题？" class="headerlink" title="如果此时使用的是cookie-session机制，而且是分布式系统的话，怎么实现用户鉴权问题？"></a>如果此时使用的是cookie-session机制，而且是分布式系统的话，怎么实现用户鉴权问题？</h2><p>1、SSO单点登录</p><p>2、集中式Session存储</p><h2 id="微布校园有遇到一些比较棘手的问题吗？如果出现问题，如何排查问题？"><a href="#微布校园有遇到一些比较棘手的问题吗？如果出现问题，如何排查问题？" class="headerlink" title="微布校园有遇到一些比较棘手的问题吗？如果出现问题，如何排查问题？"></a>微布校园有遇到一些比较棘手的问题吗？如果出现问题，如何排查问题？</h2><h2 id="当时是什么情况因为kafka挂了导致整个服务全部挂了？"><a href="#当时是什么情况因为kafka挂了导致整个服务全部挂了？" class="headerlink" title="当时是什么情况因为kafka挂了导致整个服务全部挂了？"></a>当时是什么情况因为kafka挂了导致整个服务全部挂了？</h2><h2 id="对于整个技术栈哪些组件有过深入的了解？"><a href="#对于整个技术栈哪些组件有过深入的了解？" class="headerlink" title="对于整个技术栈哪些组件有过深入的了解？"></a>对于整个技术栈哪些组件有过深入的了解？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如果对于jdk版本升级，对于jvm的一些参数修改有哪些？&quot;&gt;&lt;a href=&quot;#如果对于jdk版本升级，对于jvm的一些参数修改有哪些？&quot; class=&quot;headerlink&quot; title=&quot;如果对于jdk版本升级，对于jvm的一些参数修改有哪些？&quot;&gt;&lt;/a&gt;如果</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>微布开发-实现说说审核发布机制(暂未完成)</title>
    <link href="http://xiaobazeo.github.io/2023/08/09/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%AE%9E%E7%8E%B0%E8%AF%B4%E8%AF%B4%E5%AE%A1%E6%A0%B8%E5%8F%91%E5%B8%83%E6%9C%BA%E5%88%B6/"/>
    <id>http://xiaobazeo.github.io/2023/08/09/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%AE%9E%E7%8E%B0%E8%AF%B4%E8%AF%B4%E5%AE%A1%E6%A0%B8%E5%8F%91%E5%B8%83%E6%9C%BA%E5%88%B6/</id>
    <published>2023-08-09T08:04:28.000Z</published>
    <updated>2023-09-29T08:08:47.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h3><p>调用微信三方接口进行图片/视频安全校验，由于微信的视频/图片校验结果是异步返回到服务端的接口，所以需要将附有照片或者视频的说说审核通过之后再将说说发布到论坛中。</p><h3 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h3><p>1、如何标识所有图片/视频审核完成之后再发布呢？</p><p>因为每次向微信的接口发送请求的时候，会对每张照片的审核都会有一个任务id(trace_id)，根据这个traceid映射对应的is_valid（标识是否校验通过）和talkbid（说说的主键id）字段来标识</p><ol><li>单独拉一张表出来存储图片url和trace_id的关系，然后用一个is_valid字段根据微信接口异步返回的结果标识判断是否校验通过，如果校验通过is_valid就变成1，还在校验过程中或者校验未通过就标识0。</li><li>使用Redis通过设置超时时间来使标识自动淘汰，释放内存空间</li><li>在说说表添加一个trace_id字段，存储每张照片的trace_id，并用逗号分隔开，每次微信异步返回结果之后如果审核通过就把trace_id和返回过来的trace_id部分删除，否则就不删除，同时判断此时trace_id字段是否为空，如果等于空值了，那么就说明全部校验通过了、然后将说说详情中的is_delete(说说软删标识)字段设为0，展示到社区论坛中。</li></ol><p>3、以上标识方法会有什么问题呢？为什么最终选用对说说详情表添加字段的方式进行标识呢？</p><p>第一种方法，需要单独创建一个表，会占用一定的磁盘空间，以及MySQL需要花费更大的空间进行维护造成一定的资源浪费。</p><p>第二种方法，Redis是基于内存的一种缓存数据库，如果当有大量的io操作的时候，就会占用内存空间，这个时候很可能会出现Redis崩盘的情况，甚至说Redis宕机，因为微布校园现在是单体架构，暂时无解，只能放弃这个想法了。</p><p>第三种方法，毕竟只是添加一个字段，MySQL的维护成本相对第一种就比较低了，对于第二种方案，数据的读取，MySQL 通常会使用缓冲池（Buffer Pool）来管理数据在内存中的存储。数据会根据需要从磁盘加载到缓冲池中，并且在查询时尽量从缓冲池中读取数据，从而避免频繁的磁盘 I/O 操作。如果数据在缓冲池中已经存在，查询时可以直接从内存中读取，这比从磁盘读取要快得多。反正在读取的时候，要用缓冲池的机制将数据放到内存中，再从缓冲池中读取数据，这样相对单独用Redis去维护标识会好很多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;业务场景：&quot;&gt;&lt;a href=&quot;#业务场景：&quot; class=&quot;headerlink&quot; title=&quot;业务场景：&quot;&gt;&lt;/a&gt;业务场景：&lt;/h3&gt;&lt;p&gt;调用微信三方接口进行图片/视频安全校验，由于微信的视频/图片校验结果是异步返回到服务端的接口，所以需要将附有照片或者</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>微布开发-优化UGC消息拉取响应速度</title>
    <link href="http://xiaobazeo.github.io/2023/08/09/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%BC%98%E5%8C%96UGC%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6/"/>
    <id>http://xiaobazeo.github.io/2023/08/09/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%BC%98%E5%8C%96UGC%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96%E5%93%8D%E5%BA%94%E9%80%9F%E5%BA%A6/</id>
    <published>2023-08-09T05:06:18.000Z</published>
    <updated>2023-09-29T08:05:04.246Z</updated>
    
    <content type="html"><![CDATA[<h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a><strong>业务场景：</strong></h3><p>小程序端消息通知tab页中点赞通知列表、新粉丝通知列表、评论通知列表等UGC消息接口响应速度高达7s左右，经排查问题优化之后响应时间从7s优化至200ms以内，效果展示图如下：</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/21e92934251b02be0db37da32b9fb0d.png" alt="21e92934251b02be0db37da32b9fb0d"></p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/04311382a71018148382f9092cfdc5f.png" alt="04311382a71018148382f9092cfdc5f"></p><h3 id="问题分析及排查："><a href="#问题分析及排查：" class="headerlink" title="问题分析及排查："></a><strong>问题分析及排查：</strong></h3><p>1、索引问题？</p><p>刚开始以为是数据量太大且没有添加索引导致查询速度很慢从而导致接口反映速度很慢，但是一看数据量也不是很大，而且也有通过添加索引（是通过receiverBid（接受者的主键id）创建）的手段，并且通过<code>explain</code>语句分析我所写的语句走了索引，因此排除索引问题。</p><p>2、业务逻辑代码问题？</p><p>后面去查看业务代码、发现业务代码中除了分页查询UGC消息列表、还有一个同步的修改UGC消息读取状态的操作，也就是当用户拉取了UGC消息之后，将未读的记录转变成已读状态，一看到这里发现是两个同步操作，就赶紧通过<strong>打日志的方式</strong>判断查询操作和修改操作所耗时间，来进一步确定究竟是哪里出了问题，查看日志发现真的是因为修改操作耗时太多（为什么MySQL写操作比读操作慢？）导致的，那既然这样，我当时就想到了两个思路，1、通过一个事务来进行批量的修改操作，不过还是采取同步，但是我感觉这样如果批量同步修改的话，如果修改的数据太多，可能效率没太大提升，于是第二个想法就是在批量操作的基础上采用异步的方式，让这个修改操作打入kafka中异步化，进一步提高接口响应速率。</p><p>3、如果异步修改操作失败怎么办？根据什么判断失败？</p><p>可以根据Mybatis的Example类update方法返回的int值进行判断，如果大于0说明操作成功如果小于0则采取重试机制，重新打入kafka进行重新消费。</p><h3 id="开发思路："><a href="#开发思路：" class="headerlink" title="开发思路："></a>开发思路：</h3><p>1、根据前端穿过来的参数进行查询UGC消息列表操作，并筛选出status字段是UNREAD状态的记录传给kafka生产者的业务逻辑方法。</p><p>2、编写kafka生产者将修改操作的消息写入kafka，并编写消费者对这个消息进行消费。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;业务场景：&quot;&gt;&lt;a href=&quot;#业务场景：&quot; class=&quot;headerlink&quot; title=&quot;业务场景：&quot;&gt;&lt;/a&gt;&lt;strong&gt;业务场景：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;小程序端消息通知tab页中点赞通知列表、新粉丝通知列表、评论通知列表等UGC消息接</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>微布开发-将说说记录的图片url单独提出来用一个表存储的设计</title>
    <link href="http://xiaobazeo.github.io/2023/08/07/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%B0%86%E8%AF%B4%E8%AF%B4%E8%AE%B0%E5%BD%95%E7%9A%84%E5%9B%BE%E7%89%87url%E5%8D%95%E7%8B%AC%E6%8F%90%E5%87%BA%E6%9D%A5%E7%94%A8%E4%B8%80%E4%B8%AA%E8%A1%A8%E5%AD%98%E5%82%A8/"/>
    <id>http://xiaobazeo.github.io/2023/08/07/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%B0%86%E8%AF%B4%E8%AF%B4%E8%AE%B0%E5%BD%95%E7%9A%84%E5%9B%BE%E7%89%87url%E5%8D%95%E7%8B%AC%E6%8F%90%E5%87%BA%E6%9D%A5%E7%94%A8%E4%B8%80%E4%B8%AA%E8%A1%A8%E5%AD%98%E5%82%A8/</id>
    <published>2023-08-06T16:52:22.000Z</published>
    <updated>2023-09-28T16:17:00.579Z</updated>
    
    <content type="html"><![CDATA[<p>这样的目的是为了后续方便说说附带的图片进行修改以及调用三方接口校验图片是否违规。</p><p><strong>大概表设计如下：</strong></p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/622ed5483de15a276879cab129b21cb.png" alt="622ed5483de15a276879cab129b21cb"></p><p><strong>怎么转移说说表的pics字段的****url</strong> <strong>到新的y_talk_images字段呢？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> y_talk_images (talk_bid, images_url, user_bid, trace_id, is_valid, is_delete, create_time)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    bid,</span><br><span class="line">    SUBSTRING_INDEX(SUBSTRING_INDEX(pics, <span class="string">&#x27;,&#x27;</span>, numbers.n), <span class="string">&#x27;,&#x27;</span>, <span class="number">-1</span>) <span class="keyword">AS</span> images_url,</span><br><span class="line">    y_talk.user_bid,</span><br><span class="line">    <span class="keyword">NULL</span> <span class="keyword">AS</span> trace_id,</span><br><span class="line">    <span class="number">1</span> <span class="keyword">AS</span> is_valid,</span><br><span class="line">    <span class="number">0</span> <span class="keyword">AS</span> is_delete,</span><br><span class="line">    y_talk.create_time <span class="comment">-- 使用此图片对应的说说创建时间作为创建时间</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="number">1</span> n <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">2</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">3</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">4</span></span><br><span class="line">     <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">5</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">6</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">7</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">8</span></span><br><span class="line">     <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="number">9</span>) numbers</span><br><span class="line"><span class="keyword">JOIN</span> y_talk <span class="keyword">ON</span> <span class="keyword">CHAR_LENGTH</span>(pics) <span class="operator">-</span> <span class="keyword">CHAR_LENGTH</span>(REPLACE(pics, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) <span class="operator">&gt;=</span> numbers.n <span class="operator">-</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    pics <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> pics <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> y_talk_images (</span><br><span class="line">id <span class="type">INT</span> ( <span class="number">11</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">image_bid <span class="type">VARCHAR</span> ( <span class="number">255</span> ) COMMENT <span class="string">&#x27;图片的主键id&#x27;</span>,</span><br><span class="line">talk_bid <span class="type">VARCHAR</span> ( <span class="number">255</span> ) COMMENT <span class="string">&#x27;此图片对应的说说的主键id&#x27;</span>,</span><br><span class="line">images_url <span class="type">VARCHAR</span> ( <span class="number">1024</span> ) COMMENT <span class="string">&#x27;图片的url&#x27;</span>,</span><br><span class="line">user_bid <span class="type">VARCHAR</span> ( <span class="number">255</span> ) COMMENT <span class="string">&#x27;发布者的主键id&#x27;</span>,</span><br><span class="line">open_id <span class="type">VARCHAR</span> ( <span class="number">255</span> ) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;微信id&#x27;</span>,</span><br><span class="line">trace_id <span class="type">VARCHAR</span> ( <span class="number">50</span> ) COMMENT <span class="string">&#x27;每张照片微信接口校验时返回的任务id&#x27;</span>,</span><br><span class="line">is_valid <span class="type">INT</span> ( <span class="number">1</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;是否通过校验，0待审核，1审核通过，2审核不通过&#x27;</span>,</span><br><span class="line">is_delete <span class="type">INT</span> ( <span class="number">1</span> ) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;图片url是否被软删除&#x27;</span>,</span><br><span class="line">create_time datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY ( `id` ) <span class="keyword">USING</span> BTREE </span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这样的目的是为了后续方便说说附带的图片进行修改以及调用三方接口校验图片是否违规。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大概表设计如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pengzihao166.oss-cn-beijing.aliyuncs.c</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>微布开发-上传多张图片控制上传顺序</title>
    <link href="http://xiaobazeo.github.io/2023/08/04/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%B8%8A%E4%BC%A0%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%BC%A0%E9%A1%BA%E5%BA%8F/"/>
    <id>http://xiaobazeo.github.io/2023/08/04/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%B8%8A%E4%BC%A0%E5%A4%9A%E5%BC%A0%E5%9B%BE%E7%89%87%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%BC%A0%E9%A1%BA%E5%BA%8F/</id>
    <published>2023-08-04T07:58:14.000Z</published>
    <updated>2023-09-29T08:06:45.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开发思路："><a href="#开发思路：" class="headerlink" title="开发思路："></a>开发思路：</h3><p>串行上传：在前端逐个上传图片，并等待上一个图片上传成功后再上传下一个图片，以保持上传顺序。</p><blockquote><p>刚开始开发是通过一个for循环依次上传，没有考虑到可能因为图片大小、网络等原因导致后端返回的url顺序不一致，可以理解成多并发上传的时候而导致的顺序问题</p></blockquote><h3 id="代码大致实现："><a href="#代码大致实现：" class="headerlink" title="代码大致实现："></a>代码大致实现：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">uploadAllPics</span>(<span class="params">selectedImages, index</span>) &#123;</span><br><span class="line"><span class="comment">//fileListPicStorage 和fileList 都是用于展示组件的时候用的，主要就是存储上传之后的图片url</span></span><br><span class="line">  <span class="keyword">const</span> &#123; fileListPicStorage = [] &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="keyword">const</span> &#123; fileList = [] &#125; = <span class="variable language_">this</span>.<span class="property">data</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= selectedImages.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 所有图片上传完成</span></span><br><span class="line">      <span class="title function_">resolve</span>()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(selectedImages)</span><br><span class="line">    <span class="keyword">const</span> image = selectedImages[index]</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(image)</span><br><span class="line">    wx.<span class="title function_">uploadFile</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: app.<span class="property">globalData</span>.<span class="property">url</span> + app.<span class="property">globalData</span>.<span class="property">apiVersion</span> + <span class="string">&#x27;/upload&#x27;</span>, <span class="comment">// 替换成后端上传接口的URL</span></span><br><span class="line">      <span class="attr">filePath</span>: image.<span class="property">url</span>, <span class="comment">// 图片文件的本地路径</span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;file&#x27;</span>, <span class="comment">// 后端接收图片的字段名</span></span><br><span class="line">      <span class="attr">header</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span>,</span><br><span class="line">        <span class="attr">token</span>: wx.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;token&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 图片上传成功后的处理</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;图片上传成功&#x27;</span>, res)</span><br><span class="line">        <span class="keyword">let</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(res.<span class="property">data</span>)</span><br><span class="line">        fileList.<span class="title function_">push</span>(data.<span class="property">data</span>.<span class="property">result</span>)</span><br><span class="line">        fileListPicStorage.<span class="title function_">push</span>(&#123;</span><br><span class="line">          <span class="attr">url</span>:</span><br><span class="line">            <span class="string">&#x27;******&#x27;</span> +<span class="comment">//****代表图片url的前半部分，因为后端返回的都是后半部分url，需要前端自己补上前半部分的url</span></span><br><span class="line">            data.<span class="property">data</span>.<span class="property">result</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; fileList, fileListPicStorage &#125;)</span><br><span class="line">        <span class="comment">// 继续上传下一张图片</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">uploadAllPics</span>(selectedImages, index + <span class="number">1</span>)</span><br><span class="line">          .<span class="title function_">then</span>(resolve)</span><br><span class="line">          .<span class="title function_">catch</span>(reject)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">fail</span>: <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 处理上传失败情况</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;图片上传失败&#x27;</span>, error)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续上传下一张图片</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">uploadAllPics</span>(selectedImages, index + <span class="number">1</span>)</span><br><span class="line">          .<span class="title function_">then</span>(resolve)</span><br><span class="line">          .<span class="title function_">catch</span>(reject)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//选择照片就上传9张照片</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">afterRead</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  app.<span class="title function_">showLoading</span>(<span class="string">&#x27;图片上传中&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> that = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">//获取照片本地位置的文件数组</span></span><br><span class="line">  <span class="comment">//console.log(event)</span></span><br><span class="line">  <span class="keyword">const</span> &#123; file &#125; = event.<span class="property">detail</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(file)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//选择完并点击确认之后开始上传图片</span></span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">uploadAllPics</span>(file, <span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;所有图片上传完成&#x27;</span>)</span><br><span class="line">    wx.<span class="title function_">hideLoading</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;图片上传失败&#x27;</span>, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;开发思路：&quot;&gt;&lt;a href=&quot;#开发思路：&quot; class=&quot;headerlink&quot; title=&quot;开发思路：&quot;&gt;&lt;/a&gt;开发思路：&lt;/h3&gt;&lt;p&gt;串行上传：在前端逐个上传图片，并等待上一个图片上传成功后再上传下一个图片，以保持上传顺序。&lt;/p&gt;
&lt;blockqu</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>面经-北森后端开发实习一面(线程安全和锁未完成)</title>
    <link href="http://xiaobazeo.github.io/2023/08/03/%E9%9D%A2%E7%BB%8F-%E5%8C%97%E6%A3%AE%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/"/>
    <id>http://xiaobazeo.github.io/2023/08/03/%E9%9D%A2%E7%BB%8F-%E5%8C%97%E6%A3%AE%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E9%9D%A2/</id>
    <published>2023-08-02T17:05:15.000Z</published>
    <updated>2023-08-09T04:52:57.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么离开了法大大实习？"><a href="#为什么离开了法大大实习？" class="headerlink" title="为什么离开了法大大实习？"></a>为什么离开了法大大实习？</h3><p>阿巴阿巴阿巴。。。。。</p><h3 id="为什么当时要用kafka进行UGC消息推送？业务场景是什么？"><a href="#为什么当时要用kafka进行UGC消息推送？业务场景是什么？" class="headerlink" title="为什么当时要用kafka进行UGC消息推送？业务场景是什么？"></a>为什么当时要用kafka进行UGC消息推送？业务场景是什么？</h3><p><strong>原因：</strong></p><ol><li>kakfa是一个高吞吐、低延迟的消息队列，UGC消息需要实时推送给其他用户，比如评论、点赞等，因此kafka可以确保消息被快速处理，从而提供更好的实时性和用户体验。</li><li>因为kafka 的可靠性比较高、消息会被持久化在磁盘上，确保消息不会丢失。</li><li>因为kafka可以支持多个消费组和分区，UGC在高并发的情况下需要处理大量的消息，而kafka可以轻松应对高负载和大规模的UGC</li><li>解耦异步，主要是因为异步的特性，不会因为同步处理的方式导致主线程阻塞，导致性能下降。使用消息队列，可以将这些操作封装成消息，放入消息队列中，异步处理这些操作，不影响主线程的执行，提高系统性能和响应速度。</li></ol><h3 id="kafka的生产和消费逻辑？"><a href="#kafka的生产和消费逻辑？" class="headerlink" title="kafka的生产和消费逻辑？"></a>kafka的生产和消费逻辑？</h3><p>生产实现逻辑：</p><p>1、连接到kafka集群，创建一个producer</p><p>2、生产者通过producer对象将消息发送到指定的topic。消息可以包含键和值，键可以帮助消息路由到特定的分区，如果没有特定的key就会通过自带的负载均衡机制选择一个分区。</p><p>3、通过key实现分区，指定了键的话将使用哈希函数映射到对应的分区，保证相同键的消息将始终被写入相同的分区，从而也可以保持消息的顺序。</p><p>4、生产者发送消息也会把消息持久化到磁盘，即使消息被消费，他也会根据kafka的配置的保留时间内保留在磁盘中。</p><p>消费实现逻辑：</p><p>1、消费者连接到kafka集群，创建一个consumer对象，并订阅一个或者多个主题</p><p>2、消费者使用consumer从指定的主题中拉取消息，其中消费者可以选择从分区的起始位置开始消费或者从上次消费的偏移量继续消费。</p><p>3、进行消息分配的时候，由于每个topic可能有多个partition，多个消费者可以同时消费同一个topic不同的partition，实现负载均衡和并行处理。（这时候可能会有一个问题，一个消费者组可以消费同一个分区吗？为什么每个分区只能被消费者组中的一个消费者消费？一个消费组可以同时消费不同的分区吗？）</p><h3 id="当时开发的过程中，kafka采用的路由分区策略是什么？"><a href="#当时开发的过程中，kafka采用的路由分区策略是什么？" class="headerlink" title="当时开发的过程中，kafka采用的路由分区策略是什么？"></a>当时开发的过程中，kafka采用的路由分区策略是什么？</h3><p>使用的默认的分区策略</p><p>就是会使用消息的key进行哈希，然后根据哈希值对分区总数取模得到一个分区号，将消息路由到对应的分区。这样就可以保证具有相同key的消息被写入同一个分区，保证消息有序。</p><h3 id="kafka如何保证顺序消费？"><a href="#kafka如何保证顺序消费？" class="headerlink" title="kafka如何保证顺序消费？"></a>kafka如何保证顺序消费？</h3><p>保证相关消息都发送到同一个分区这样就可以保证有序了，即通过一个partition消费对应的消息，因为生产者发送消息的时候，消息会逐一添加到该partition的日志中，并会分配一个唯一的offset，以保证从此offset开始进行消息的消费，从而保证消息顺序的有序性。</p><h3 id="如果kafka消息阻塞的话怎么处理？"><a href="#如果kafka消息阻塞的话怎么处理？" class="headerlink" title="如果kafka消息阻塞的话怎么处理？"></a>如果kafka消息阻塞的话怎么处理？</h3><p><strong>生产者角度：</strong></p><p>可能是因为生产者的生产速率太快导致，超过了消费者的消费能力，可以通过控制生产者的生产速率来适配消费者的处理速率</p><p><strong>消费者角度：</strong></p><p>可以创建多个消费者组或消费者实例，对不同的topic下不同的partition进行消费，但是最好是一个partition只被一个消费者消费，但一个消费者可以消费多个partition。</p><p><strong>硬件存储问题：</strong></p><p>由于存储空间满了，导致消息无法写入，因此消费者也无法进行消费，清空一定的磁盘空间即可。</p><h3 id="kafka是怎么保证主从副本的数据一致性？"><a href="#kafka是怎么保证主从副本的数据一致性？" class="headerlink" title="kafka是怎么保证主从副本的数据一致性？"></a>kafka是怎么保证主从副本的数据一致性？</h3><p>1、生产者向kafka的主副本发送消息，主副本会将消息追加到日志里面，进行持久化操作，并将消息分发给从副本。</p><p>2、从副本会周期性从主副本拉取数据保存到自己的本地log以保证同步。</p><p>3、ISR机制（最重要的一点）：Kafka会维护一个ISR的集合，它保存了相对主副本实时同步的从副本，如果某个从副本没有跟上主副本的进度，就会被移出ISR机制，直到它后面又跟上主副本的进度之后才会回到ISR集合中。</p><p>4、当所有ISR的从副本都确认收到了消息，这时候主副本就会把消息标记为已提交，意味着消息写入了足够多的副本中，确保数据的可靠性。</p><h3 id="如果主副本没了、这时候会怎么选择从副本？"><a href="#如果主副本没了、这时候会怎么选择从副本？" class="headerlink" title="如果主副本没了、这时候会怎么选择从副本？"></a>如果主副本没了、这时候会怎么选择从副本？</h3><p>会从ISR中同步的从副本选择作为主副本，然后此时被选举成为主副本的副本就会同步消息到其他的从副本中，来保证数据同步和备份。</p><h3 id="消息丢失的场景有哪些？以及怎么去解决这个问题？"><a href="#消息丢失的场景有哪些？以及怎么去解决这个问题？" class="headerlink" title="消息丢失的场景有哪些？以及怎么去解决这个问题？"></a>消息丢失的场景有哪些？以及怎么去解决这个问题？</h3><ul><li>生产者丢失消息<ul><li>生产者使用producer.send方法的时候，因为这个方法是异步的，会立即返回，如果此时出现了网络波动就会出现消息丢失的情况，导致Broker并没有接收到生产者发过来的消息</li></ul></li><li>Kafka Broker 服务端丢失消息<ul><li>如果因为leader broker宕机了触发选举过程，集群选举了一个落后的leader之后就会出现消息丢失的情况。</li><li>由于broker持久化消息需要先通过写入页缓存，再从页缓存写入磁盘，即通过异步批量刷盘的方式写入磁盘，也就是说需要消息达到一定的量和时间间隔才会去刷盘，具体的刷盘操作一般是由操作系统调度，如果刷盘之前导致broker宕机了也会出现消息丢失的情况。</li></ul></li><li>消费者丢失消息<ul><li>拉取消息之后，先提交offset，后处理消息：如果处理消息的时候突然宕机或者处理错误，但是此时offset又已经提交，等消费者重启恢复之后，就会从offset的下一个开始消费，之前未处理完的消息就会不再做处理，这时候对于消费者来说就是消息丢失了。</li><li>拉取消息之后，先处理消息，再提交offset：如果消息已经处理好了，但是要提交offset的时候突然宕机了，这时候重启服务，就会出现消费者会重新拉取上次消费了的消息进行再次消费的情况，此时会出现重复消费的情况或者直接丢失消息。</li></ul></li></ul><h3 id="有没有调用过一些三方接口？怎么实现的？"><a href="#有没有调用过一些三方接口？怎么实现的？" class="headerlink" title="有没有调用过一些三方接口？怎么实现的？"></a>有没有调用过一些三方接口？怎么实现的？</h3><p>1、文本审核内容审核</p><p>2、音视频内容审核</p><h3 id="对于微信接口的AccessToken怎么处理那个有效时间无效问题？"><a href="#对于微信接口的AccessToken怎么处理那个有效时间无效问题？" class="headerlink" title="对于微信接口的AccessToken怎么处理那个有效时间无效问题？"></a>对于微信接口的AccessToken怎么处理那个有效时间无效问题？</h3><p>定时刷新，将对应的AccessToken存在Redis里面，每次需要使用的时候，先从缓存中找，如果缓存中的东西失效了，那么就重新获取一次token进行令牌刷新并存在Redis里面，但是存取的时间是6000s，防止处理事务处理过程中出现失效的情况。</p><h3 id="如果服务器CPU或者内存满了怎么分析？"><a href="#如果服务器CPU或者内存满了怎么分析？" class="headerlink" title="如果服务器CPU或者内存满了怎么分析？"></a>如果服务器CPU或者内存满了怎么分析？</h3><p>1、使用监控工具确定是什么资源占用率高</p><p>2、使用系统工具查看占用cpu高的进程</p><p>3、查看日志找到异常或者错误信息，来定位具体是什么地方导致线程阻塞从而导致的cpu飙升，并及时优化代码。</p><h3 id="对于高并发问题，要怎么处理数据的一致性问题以及保证线程安全？"><a href="#对于高并发问题，要怎么处理数据的一致性问题以及保证线程安全？" class="headerlink" title="对于高并发问题，要怎么处理数据的一致性问题以及保证线程安全？"></a>对于高并发问题，要怎么处理数据的一致性问题以及保证线程安全？</h3><p><strong>解决方案：</strong></p><ul><li>使用并发容器，如ConcurrentHashMap，它是线程安全的数据结构，可用于高并发场景。</li><li>通过分布式锁的方式，保证数据一致性，确保在同一时间只有一个线程可以访问共享资源。</li><li>根据业务需求，设置合适的数据库隔离级别，如读未提交、读已提交、可重复读、串行化，以保证数据的一致性和隔离性。</li></ul><h3 id="常用的锁有哪些？"><a href="#常用的锁有哪些？" class="headerlink" title="常用的锁有哪些？"></a>常用的锁有哪些？</h3><h3 id="介绍一下互斥锁、自旋锁"><a href="#介绍一下互斥锁、自旋锁" class="headerlink" title="介绍一下互斥锁、自旋锁"></a>介绍一下互斥锁、自旋锁</h3><p>互斥锁：用于保护共享资源，同一时间只允许一个线程访问共享资源，其他线程需要等待锁的释放。</p><h3 id="Redis的Set扩容机制如何实现？"><a href="#Redis的Set扩容机制如何实现？" class="headerlink" title="Redis的Set扩容机制如何实现？"></a>Redis的Set扩容机制如何实现？</h3><p>1、当Set元素数量达到一定的阈值的时候，创建新的哈希表</p><p>2、Redis会逐一将原来哈希表的元素根据新的哈希映射函数分配到新的哈希表中</p><p>3、更新指针，这个指针指向的是存储哈希表的内存地址，以便在扩容过程中可以正确地切换到新的哈希表。</p><h3 id="介绍一下hashmap以及如何解决哈希冲突的？"><a href="#介绍一下hashmap以及如何解决哈希冲突的？" class="headerlink" title="介绍一下hashmap以及如何解决哈希冲突的？"></a>介绍一下hashmap以及如何解决哈希冲突的？</h3><p>问烂了、已经不想打字了，补充几个其他相关的题</p><h4 id="为什么hashmap要在红黑树节点小于等于6的时候转回链表？"><a href="#为什么hashmap要在红黑树节点小于等于6的时候转回链表？" class="headerlink" title="为什么hashmap要在红黑树节点小于等于6的时候转回链表？"></a>为什么hashmap要在红黑树节点小于等于6的时候转回链表？</h4><ul><li>最主要的原因是因为节点数小于等于6的时候，链表和红黑树查询平均时间复杂度几乎一样，都是O（n），在性能差异不大的情况下，红黑树的维护成本远远大于链表的维护成本。</li><li>根据概率论的泊松分布，造成哈希冲突导致桶的的链表长度等于6的概率很大，而查询的平均复杂度和红黑树一样，在同等效率下选择开销更小的链表结构。</li></ul><h4 id="为什么hashmap负载因子是0-75？"><a href="#为什么hashmap负载因子是0-75？" class="headerlink" title="为什么hashmap负载因子是0.75？"></a>为什么hashmap负载因子是0.75？</h4><p>1、避免频繁扩容带来的性能损失</p><p>2、提高空间利用率，负载因子 = 存储的元素数量 / 哈希表可存储元素的总数量</p><p>3、较小的负载因子能够减少哈希冲突，提高性能，这也是经验之谈。</p><h4 id="哈希扩容的时候，是根据什么来扩容的？"><a href="#哈希扩容的时候，是根据什么来扩容的？" class="headerlink" title="哈希扩容的时候，是根据什么来扩容的？"></a>哈希扩容的时候，是根据什么来扩容的？</h4><p>元素数量 / 哈希表的容量与负载因子进行比较，</p><h3 id="索引失效有哪些？"><a href="#索引失效有哪些？" class="headerlink" title="索引失效有哪些？"></a>索引失效有哪些？</h3><p>6种，左右模糊或左模糊，对索引使用函数，对索引隐式类型转换（查询的时候数据类型转换，实际上会用到函数CAST），对索引进行表达式计算(where id + 1 = 10不行)，联合索引非左匹配原则，where子句有OR</p><p>对索引使用函数，对索引隐式类型转换（查询的时候数据类型转换，实际上会用到函数CAST），对索引进行表达式计算(where id + 1 = 10不行)，这三种造成失效的原因就是索引存的是原始的值，而不是使用函数或者通过计算得到的新的值，如果建立对某个字段使用函数或者计算的索引来解决这个问题。例如建立索引<code>alter table t_user add key idx_name_length ((length(name)));</code></p><h3 id="介绍一些JWT，比较一下和Cookie-Session的区别？"><a href="#介绍一些JWT，比较一下和Cookie-Session的区别？" class="headerlink" title="介绍一些JWT，比较一下和Cookie-Session的区别？"></a>介绍一些JWT，比较一下和Cookie-Session的区别？</h3><p>阿巴阿巴阿巴。。。。。</p><h3 id="JWT是怎么解决防篡改问题的？"><a href="#JWT是怎么解决防篡改问题的？" class="headerlink" title="JWT是怎么解决防篡改问题的？"></a>JWT是怎么解决防篡改问题的？</h3><p>阿巴阿巴阿巴。。。。。</p><h3 id="介绍一下如何判断死亡对象的方法以及垃圾收集算法"><a href="#介绍一下如何判断死亡对象的方法以及垃圾收集算法" class="headerlink" title="介绍一下如何判断死亡对象的方法以及垃圾收集算法"></a>介绍一下如何判断死亡对象的方法以及垃圾收集算法</h3><p><strong>判断对象死亡的方法：</strong></p><ol><li>引用计数法：当被引用了就计数+1，引用失效就-1，当计数器的值==0就说明此对象已经死亡。</li><li>可达性分析算法：如果某个对象不能有一条路径到达GC ROOTS，如果没有的话，就说明这个对象已经死亡，有的话就说明，这个对象没有死亡。</li></ol><blockquote><p>这个时候实际上只能表示对象可以回收了，但是不一定代表着一定会回收，宣布一个对象死亡，要进行两次标记，可达性分析算法中不可达对象就会先第一次被标记并进行一次筛选，筛选条件就是此对象是否有必要执行finalize()，如果finalize()方法没有被覆盖，或者被虚拟栈调用过了，就会被认为没有必要被执行。被判定需要执行的对象就会被放入一个队列进行二次标记，除非这个对象跟引用链上的任何一个对象建立关联，否则就会被回收。</p></blockquote><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><blockquote><p><strong>简介</strong></p><ul><li>进程：计算机正在运行的一个程序实例，比如打开微信</li><li>线程：又称轻量级进程，多个线程可以在同一个进程中同时执行，并且共享进程的资源比如：内存空间、网络连接等，举例：你打开的微信就有一个线程专门用来拉取别人发你的最新的消息。</li></ul></blockquote><ol><li>一个进程可以产生多个线程，多个进程间共享堆和方法区，每个线程自己独立的程序计数器、虚拟机栈和本地方法栈。</li><li>进程线程最大的不同就是各进程是独立的，而线程不一定因为同一进程中的线程极有可能会相互影响。</li><li>线程执行开销小，不利于资源的管理和保护但是进程相反。</li></ol><h3 id="介绍一下协程（不会）"><a href="#介绍一下协程（不会）" class="headerlink" title="介绍一下协程（不会）"></a>介绍一下协程（不会）</h3><p>协程是相较于线程更加轻量级的一种执行单位，协程通常不会被内核调度所以协程切换不会涉及内核级的上下文切换，核心思想就是可以暂停和回复的执行单元，一个可以在某一个点挂起，然后执行权交给其他协程，等其他协程执行完毕之后可以恢复，从挂起的地方继续执行。</p><p>协程的并行数也受限于CPU的核心数，多个协程在同一线程中交替执行，充分利用了单线程的资源。但协程并发的时候可以通过调度器来控制哪个协程何时执行。</p><h3 id="平时怎么学习的？"><a href="#平时怎么学习的？" class="headerlink" title="平时怎么学习的？"></a>平时怎么学习的？</h3><p>阿巴阿巴阿巴阿巴阿巴阿巴。。。</p><h3 id="了不了解ElasticSearch？（并不了解）"><a href="#了不了解ElasticSearch？（并不了解）" class="headerlink" title="了不了解ElasticSearch？（并不了解）"></a>了不了解ElasticSearch？（并不了解）</h3><p>所以无解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么离开了法大大实习？&quot;&gt;&lt;a href=&quot;#为什么离开了法大大实习？&quot; class=&quot;headerlink&quot; title=&quot;为什么离开了法大大实习？&quot;&gt;&lt;/a&gt;为什么离开了法大大实习？&lt;/h3&gt;&lt;p&gt;阿巴阿巴阿巴。。。。。&lt;/p&gt;
&lt;h3 id=&quot;为什么当时要</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面经-七牛云测试开发实习一二面</title>
    <link href="http://xiaobazeo.github.io/2023/08/02/%E9%9D%A2%E7%BB%8F-%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%BA%8C%E9%9D%A2/"/>
    <id>http://xiaobazeo.github.io/2023/08/02/%E9%9D%A2%E7%BB%8F-%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%BA%8C%E9%9D%A2/</id>
    <published>2023-08-02T03:37:32.000Z</published>
    <updated>2023-09-29T07:46:35.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="微布校园的分工如何？"><a href="#微布校园的分工如何？" class="headerlink" title="微布校园的分工如何？"></a>微布校园的分工如何？</h3><h3 id="在开发过程中学到了什么？遇到了什么难的问题？"><a href="#在开发过程中学到了什么？遇到了什么难的问题？" class="headerlink" title="在开发过程中学到了什么？遇到了什么难的问题？"></a>在开发过程中学到了什么？遇到了什么难的问题？</h3><h3 id="如何解决缓存雪崩、缓存与数据库一致性问题？"><a href="#如何解决缓存雪崩、缓存与数据库一致性问题？" class="headerlink" title="如何解决缓存雪崩、缓存与数据库一致性问题？"></a>如何解决缓存雪崩、缓存与数据库一致性问题？</h3><h3 id="查询响应速度从超时响应加快到900ms-1s是如何实现的？"><a href="#查询响应速度从超时响应加快到900ms-1s是如何实现的？" class="headerlink" title="查询响应速度从超时响应加快到900ms~1s是如何实现的？"></a>查询响应速度从超时响应加快到900ms~1s是如何实现的？</h3><h3 id="讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）"><a href="#讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）" class="headerlink" title="讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）"></a>讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）</h3><h3 id="使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。"><a href="#使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。" class="headerlink" title="使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。"></a>使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。</h3><h3 id="Redis在哪一部分用的比较多？"><a href="#Redis在哪一部分用的比较多？" class="headerlink" title="Redis在哪一部分用的比较多？"></a>Redis在哪一部分用的比较多？</h3><h3 id="讲一下http的三次握手、四次挥手？"><a href="#讲一下http的三次握手、四次挥手？" class="headerlink" title="讲一下http的三次握手、四次挥手？"></a>讲一下http的三次握手、四次挥手？</h3><h3 id="为什么要进行四次挥手？"><a href="#为什么要进行四次挥手？" class="headerlink" title="为什么要进行四次挥手？"></a>为什么要进行四次挥手？</h3><h3 id="介绍一下udp和tcp之间的区别"><a href="#介绍一下udp和tcp之间的区别" class="headerlink" title="介绍一下udp和tcp之间的区别"></a>介绍一下udp和tcp之间的区别</h3><h3 id="什么时候用UDP？什么时候用TCP？"><a href="#什么时候用UDP？什么时候用TCP？" class="headerlink" title="什么时候用UDP？什么时候用TCP？"></a>什么时候用UDP？什么时候用TCP？</h3><h3 id="介绍一下对HTTP的理解"><a href="#介绍一下对HTTP的理解" class="headerlink" title="介绍一下对HTTP的理解"></a>介绍一下对HTTP的理解</h3><h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><h3 id="介绍一下token"><a href="#介绍一下token" class="headerlink" title="介绍一下token"></a>介绍一下token</h3><h3 id="讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？"><a href="#讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？" class="headerlink" title="讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？"></a>讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？</h3><h3 id="介绍一下Redis的数据类型和持久化"><a href="#介绍一下Redis的数据类型和持久化" class="headerlink" title="介绍一下Redis的数据类型和持久化"></a>介绍一下Redis的数据类型和持久化</h3><h3 id="如何通过Redis实现分布式锁？"><a href="#如何通过Redis实现分布式锁？" class="headerlink" title="如何通过Redis实现分布式锁？"></a>如何通过Redis实现分布式锁？</h3><h3 id="Redis的淘汰策略有哪些？"><a href="#Redis的淘汰策略有哪些？" class="headerlink" title="Redis的淘汰策略有哪些？"></a>Redis的淘汰策略有哪些？</h3><h3 id="介绍一下对多线程的理解"><a href="#介绍一下对多线程的理解" class="headerlink" title="介绍一下对多线程的理解"></a>介绍一下对多线程的理解</h3><h3 id="什么是线程池、为什么要使用线程池？"><a href="#什么是线程池、为什么要使用线程池？" class="headerlink" title="什么是线程池、为什么要使用线程池？"></a>什么是线程池、为什么要使用线程池？</h3><h3 id="Java的异常有哪些？如何捕获异常？"><a href="#Java的异常有哪些？如何捕获异常？" class="headerlink" title="Java的异常有哪些？如何捕获异常？"></a>Java的异常有哪些？如何捕获异常？</h3><h3 id="对文件的上传、下载分别有哪些测试功能点？"><a href="#对文件的上传、下载分别有哪些测试功能点？" class="headerlink" title="对文件的上传、下载分别有哪些测试功能点？"></a>对文件的上传、下载分别有哪些测试功能点？</h3><h3 id="算法题：把两个无序的数组合并成一个有序的数组"><a href="#算法题：把两个无序的数组合并成一个有序的数组" class="headerlink" title="算法题：把两个无序的数组合并成一个有序的数组"></a>算法题：把两个无序的数组合并成一个有序的数组</h3><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><h3 id="为什么要选择面试测试开发这个岗位？"><a href="#为什么要选择面试测试开发这个岗位？" class="headerlink" title="为什么要选择面试测试开发这个岗位？"></a>为什么要选择面试测试开发这个岗位？</h3><h3 id="你觉得测开需要学习些什么方面的东西？"><a href="#你觉得测开需要学习些什么方面的东西？" class="headerlink" title="你觉得测开需要学习些什么方面的东西？"></a>你觉得测开需要学习些什么方面的东西？</h3><h3 id="netty和直接裸写socket有什么区别？"><a href="#netty和直接裸写socket有什么区别？" class="headerlink" title="netty和直接裸写socket有什么区别？"></a>netty和直接裸写socket有什么区别？</h3><h3 id="什么是NIO？"><a href="#什么是NIO？" class="headerlink" title="什么是NIO？"></a>什么是NIO？</h3><h3 id="为什么IO多路复用比多线程更高效？"><a href="#为什么IO多路复用比多线程更高效？" class="headerlink" title="为什么IO多路复用比多线程更高效？"></a>为什么IO多路复用比多线程更高效？</h3><h3 id="Redis是单线程还是多线程的？为什么是单线程还能这么高效？"><a href="#Redis是单线程还是多线程的？为什么是单线程还能这么高效？" class="headerlink" title="Redis是单线程还是多线程的？为什么是单线程还能这么高效？"></a>Redis是单线程还是多线程的？为什么是单线程还能这么高效？</h3><h3 id="在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？"><a href="#在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？" class="headerlink" title="在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？"></a>在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？</h3><h3 id="使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）"><a href="#使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）" class="headerlink" title="使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）"></a>使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）</h3><h3 id="netty的广播怎么实现的？"><a href="#netty的广播怎么实现的？" class="headerlink" title="netty的广播怎么实现的？"></a>netty的广播怎么实现的？</h3><h3 id="如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？"><a href="#如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？" class="headerlink" title="如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？"></a>如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？</h3><h3 id="如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？"><a href="#如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？" class="headerlink" title="如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？"></a>如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？</h3><h3 id="介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？"><a href="#介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？" class="headerlink" title="介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？"></a>介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？</h3><h3 id="说几个Maven的常用命令"><a href="#说几个Maven的常用命令" class="headerlink" title="说几个Maven的常用命令"></a>说几个Maven的常用命令</h3><h3 id="常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）"><a href="#常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）" class="headerlink" title="常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）"></a>常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）</h3><h3 id="怎么实现多线程之间的同步操作？-主线程开启10个任务，-等这10个任务并发结束之后，再执行其他的任务应该怎么实现？"><a href="#怎么实现多线程之间的同步操作？-主线程开启10个任务，-等这10个任务并发结束之后，再执行其他的任务应该怎么实现？" class="headerlink" title="怎么实现多线程之间的同步操作？ 主线程开启10个任务， 等这10个任务并发结束之后，再执行其他的任务应该怎么实现？"></a>怎么实现多线程之间的同步操作？ 主线程开启10个任务， 等这10个任务并发结束之后，再执行其他的任务应该怎么实现？</h3><h3 id="Java的新特性（介绍的Java8的新特性）"><a href="#Java的新特性（介绍的Java8的新特性）" class="headerlink" title="Java的新特性（介绍的Java8的新特性）"></a>Java的新特性（介绍的Java8的新特性）</h3><h3 id="编码：实现a，b两个线程顺序交替执行"><a href="#编码：实现a，b两个线程顺序交替执行" class="headerlink" title="编码：实现a，b两个线程顺序交替执行"></a>编码：实现a，b两个线程顺序交替执行</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h2&gt;&lt;h3 id=&quot;微布校园的分工如何？&quot;&gt;&lt;a href=&quot;#微布校园的分工如何？&quot; class=&quot;headerlink&quot; title=&quot;微布校园的</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面经-万物心选php开发实习</title>
    <link href="http://xiaobazeo.github.io/2023/07/25/%E9%9D%A2%E7%BB%8F-%E4%B8%87%E7%89%A9%E5%BF%83%E9%80%89php%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/"/>
    <id>http://xiaobazeo.github.io/2023/07/25/%E9%9D%A2%E7%BB%8F-%E4%B8%87%E7%89%A9%E5%BF%83%E9%80%89php%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/</id>
    <published>2023-07-25T08:13:52.000Z</published>
    <updated>2023-09-29T07:46:32.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实习项目的监听字段是基于什么实现的？"><a href="#实习项目的监听字段是基于什么实现的？" class="headerlink" title="实习项目的监听字段是基于什么实现的？"></a>实习项目的监听字段是基于什么实现的？</h2><p>前端进行某个字段变更之后，后端提供接口，将修改后的数据打入消息队列，服务端作为消费者进行监听判断某个字段是否等于某个值然后进行对应的业务逻辑操作。</p><h2 id="通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）"><a href="#通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）" class="headerlink" title="通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）"></a>通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）</h2><p>通过业务id来保证，业务id作为锁的key，当消费信息的时候，把工单id作为key去申请锁，如果成功拿到了锁，说明此时不存在竞争关系，如果当前进程被阻塞了，说明有进程对该数据进行了消费。</p><p>不过后面发现如果有两个并发的线程的时候，被阻塞的业务后面拿到了还是可能会造成重复消费，于是又加了一层缓存，缓存已经消费了的业务id，用来表示是否被消费过，也就是保证业务的幂等性。</p><h2 id="当时为什么考虑到设置一个重试机制降低消费的失败率？"><a href="#当时为什么考虑到设置一个重试机制降低消费的失败率？" class="headerlink" title="当时为什么考虑到设置一个重试机制降低消费的失败率？"></a>当时为什么考虑到设置一个重试机制降低消费的失败率？</h2><p>当初实现合同是临时合同的时候，要删除销售合同的主从表，因为当时是两个表，涉及到了一个同步操作，即先删除主表之后再删除从表的操作，要保证事务的一致性和原子性，可能两个删除操作会有一个或者两个操作均失败的情况，就设计了这个重试机制，如果其中一个操作失败就进行事务回滚，然后将两个同步操作打入重试的队列中进行一次重试。</p><h2 id="有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）"><a href="#有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）" class="headerlink" title="有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）"></a>有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）</h2><p><strong>避免消费失败的措施：</strong></p><ol><li>失败重试机制</li><li>死信队列</li><li>消息超时机制：避免因为一个消息阻塞导致后续的所有消息超时</li><li>负载均衡：如果是集群分布式服务，可以通过负载均衡算法分配给多个消费者。</li><li>消息确认机制：当消费者消费成功之后，发送确认信号给消息队列，表示消息处理成功，如果消费者在一定时间内没有返回确认信号，消息队列就重新分发消息给其他的消费者进行消费。</li></ol><p><strong>避免重复消费的措施：</strong></p><ol><li>实现幂等性：即相同的多个操作所产生的影响与仅执行一次的操作所产生的影响相同。确保相同的消息被多次发送之后，只会被处理一次。</li><li>消息确认机制：消息队列消费者消费之后会给生产者发送一个确认信号告诉已经消费信息成功，如果在一定时间内没有发送确认消息，消息队列就会认为此消息未被成功消费，会将该消息重新发送给消费者。</li><li>消费者限流：在高并发的场景中，为了消费者过度消费，就会在一定时间内只允许消费者消费一定数量的消息，以避免被过度消费而导致的重复消费。</li></ol><h2 id="如何解决数据库offset超过10000时失效的问题？"><a href="#如何解决数据库offset超过10000时失效的问题？" class="headerlink" title="如何解决数据库offset超过10000时失效的问题？"></a>如何解决数据库offset超过10000时失效的问题？</h2><p>通过分页查询的方式，偏移量超过一万的情况下，我们可以通过limit的分页查询机制，一直查到第10001条数据的主键id，然后从此id开始进一步根据条件查询需要获取的数据。</p><h2 id="为什么offset超过10000会查询不到数据呢？"><a href="#为什么offset超过10000会查询不到数据呢？" class="headerlink" title="为什么offset超过10000会查询不到数据呢？"></a>为什么offset超过10000会查询不到数据呢？</h2><p>OFFSET工作原理是通过全表扫描，先查询所有匹配的记录，然后再跳过指定数量的记录，如果偏移量特别大，数据库可能会需要一次性加载大量数据到内存中，会导致内存不足的问题。</p><h2 id="实习时候的成长经历"><a href="#实习时候的成长经历" class="headerlink" title="实习时候的成长经历"></a>实习时候的成长经历</h2><p>1、有一次出现过一次消息队列重复消费的情况，当时情况是两个不同的测试环境，做相同业务消费时消费了两次，然后查代码一直也没有查到原因，就去看配置环境，原来是当时运维那边部署消息队列，两个环境都部署到了一个队列上面，没有做环境隔离。。。</p><p>2、在开发流程中先根据需求，写出开发思路，</p><h2 id="JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？"><a href="#JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？" class="headerlink" title="JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？"></a>JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？</h2><p><strong>业务及校验流程：</strong></p><p>用户通过学号+教务密码向Java后端发起请求，然后Java后端调用Python的服务进行校验账号密码是否正确，如果正确就会向前端返回一个token，客户端将Token保存在本地缓存之中，方便以后在一些业务操作的时候，都会从本地缓存中获取Token并将其放在Http请求的Header中发送请求，服务端获取到请求之后从Http的header里面获取token，并通过服务端保存的密匙进行重新生成新的signature和客户端发过来的token的signature进行比较确认token是否有效，再从payload部分获取相关用户信息进行进一步身份校验。</p><p>每次服务端在校验token有效的时候会根据payload的签发token时间+超时时间，当离过期时间只有1天的时候，就会重新签发一个Token给前端。</p><p><strong>Token存放位置：</strong></p><p>HTTP的Header部分。</p><h2 id="Java为什么需要垃圾回收机制呢？"><a href="#Java为什么需要垃圾回收机制呢？" class="headerlink" title="Java为什么需要垃圾回收机制呢？"></a>Java为什么需要垃圾回收机制呢？</h2><p>主要是为了管理内存，自动释放不再使用的对象，以避免内存泄漏和提高程序性能。</p><h2 id="什么情况下会出现资源的浪费（内存泄漏）？"><a href="#什么情况下会出现资源的浪费（内存泄漏）？" class="headerlink" title="什么情况下会出现资源的浪费（内存泄漏）？"></a>什么情况下会出现资源的浪费（内存泄漏）？</h2><p>1、长期存活的对象占用过多内存，就是长生命周期对象持有短生命周期的引用导致部分短生命周期的对象一直没有被释放，进而积累过多的情况下出现内存泄漏的问题。</p><p>2、各种连接：比如数据库连接、网络连接，对于这些连接操作都需要在不使用的时候进行关闭操作，垃圾回收期才会进行回收。</p><p>3、变量作用域不合理：比如要对一个msg进行保存操作，但是msg定义成一个成员变量，然后通过receiveMsg()方法进行相关保存业务逻辑操作，但是因为msg是成员变量，生命周期和类的生命周期一样，所以导致存储操作完成之后，msg还没有被回收释放，可能就会导致内存泄漏。</p><h2 id="创建了一个String类型的数据什么时候会被垃圾回收机制回收？"><a href="#创建了一个String类型的数据什么时候会被垃圾回收机制回收？" class="headerlink" title="创建了一个String类型的数据什么时候会被垃圾回收机制回收？"></a>创建了一个String类型的数据什么时候会被垃圾回收机制回收？</h2><p>1、对象不再引用。</p><p>2、对象引用被显式设置为null。</p><p>3、对象的引用超出作用域：在一个方法内部创建的，那么在这个方法执行完之后就会被收回。</p><p>3、垃圾回收机制触发：Java虚拟机判断系统内存不足就会触发此机制，尝试回收不再被使用的对象。</p><h2 id="了解哪些垃圾回收算法并介绍一下"><a href="#了解哪些垃圾回收算法并介绍一下" class="headerlink" title="了解哪些垃圾回收算法并介绍一下"></a>了解哪些垃圾回收算法并介绍一下</h2><p><strong>标记-清除算法：</strong></p><p>首先标记处所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p><p>导致的问题：</p><p>1、标记清除的过程效率都不高</p><p>2、标记清除后会产生大量不连续的内存碎片。</p><p><strong>复制算法：</strong></p><p>将内存空间分为两半，每次使用其中的一块，当这块使用完之后，将这块还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</p><p>导致的问题：</p><p>1、可用内存变小。</p><p>2、不适合老年代，如果存活对象数量大，复制性能会比较差。</p><p><strong>标记-整理算法：</strong></p><p>标记不需要回收的对象，然后将没有标记的对象统一向一端移动，然后直接清理掉端边界以外的内存。</p><p>导致问题：</p><p>只适合老年代回收频率较低的场景</p><p><strong>分代收集算法：</strong></p><p>根据不同对象的生命周期将内存分为几块。一般将Java堆分为新生代和老年代，可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如：新生代中，每次都会有大量对象死去，可以选择<strong>复制算法</strong>，只需要付出少量对象的复制成本就可以完成垃圾收集。而对于老年代生命周期较长，存活率较高，可以选择<strong>标记-清除算法</strong>或者<strong>标记-整理算法</strong>实现。</p><h2 id="垃圾回收机制为什么要分新生代和老年代呢？"><a href="#垃圾回收机制为什么要分新生代和老年代呢？" class="headerlink" title="垃圾回收机制为什么要分新生代和老年代呢？"></a>垃圾回收机制为什么要分新生代和老年代呢？</h2><p>根据不同对象的生命周期将内存分为几块。一般将Java堆分为新生代和老年代，可以根据各个年代的特点选择合适的垃圾收集算法。</p><h2 id="为什么新生代和老年代不放在一起进行回收呢？"><a href="#为什么新生代和老年代不放在一起进行回收呢？" class="headerlink" title="为什么新生代和老年代不放在一起进行回收呢？"></a>为什么新生代和老年代不放在一起进行回收呢？</h2><p>1、不同对象生命周期：可以根据不同的生命周期对象采用不同的回收策略</p><p>2、不同回收算法：一般新生代会采用复制算法清除，因为可以标记较少的对象复制到另一块内存上面去，然后一次性清理整个区域，效率较高，对于老年代生命周期长且存活率高，就可以采用标记-整理或者标记-删除的办法，将不需要回收的对象进行标记，然后直接删除没有标记的即可。</p><p>3、避免频繁回收老年代：混在一起会导致老年代频繁的回收，降低系统的性能。</p><h2 id="数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？"><a href="#数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？" class="headerlink" title="数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？"></a>数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？</h2><ul><li>数组访问效率比链表高，因为链表通常是动态扩容的，每次的动态调整都会带来一定的开销以及维护指针等，所以访问效率较低。</li><li>链表能灵活进行动态扩容或缩容，但是数组一旦确定大小就不能进行扩容和缩容操作了。</li><li>链表有丰富的api可以直接动态进行增删查改，而数组是一个固定长度的数组，只能按下标访问其中的元素，不具备动态增删的能力。</li><li>链表只能存储对象（对于基本数据类型可以采用包装类进行存储），但是数组既可以存储对象也可以存储基本数据类型。</li><li>链表可以通过泛型保证类型安全，但是数组不可以。</li></ul><h2 id="有没有一个数据结构可以访问元素时间是O-1-，又可以灵活的调整他的容量大小？"><a href="#有没有一个数据结构可以访问元素时间是O-1-，又可以灵活的调整他的容量大小？" class="headerlink" title="有没有一个数据结构可以访问元素时间是O(1)，又可以灵活的调整他的容量大小？"></a>有没有一个数据结构可以访问元素时间是O(1)，又可以灵活的调整他的容量大小？</h2><p>哈希表可以将key映射到存储位置来实现快速访问，使用哈希函数将键转换成索引，然后将值存在对应索引的位置，在理想情况下，能够在O（1）情况下根据键找到对应的值。哈希表具有灵活的扩容机制，当哈希表中元素过多的时候就会自动扩容，重新分配更大的空间。</p><h2 id="HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）"><a href="#HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）" class="headerlink" title="HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）"></a>HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）</h2><p>hashmap是基于数组+链表/红黑树的数据结构来具体实现的，首先hashmap产生哈希冲突的时候会判断链表的长度是否大于8，如果大于的话就会转换成红黑树（此时进入红黑树转换的函数的时候，会判断数组的长度是否大于64，如果数组长度小于64，就不会转换成红黑树，而是选择扩容的机制解决哈希冲突）</p><p>选择红黑树的原因：</p><p>1、如果是<strong>二叉查询树</strong>比较极端的情况下，当子节点都比父节点大或者小的时候，二叉查找树又会退化成链表，此时时间复杂度又是O(n)。</p><p>2、如果是<strong>平衡二叉树（AVL）</strong>，因为它每个节点的左子树和右子树的高度差至多等于1，如果大于1了就会通过左旋或者右旋的方式，使其复杂度一直维持在O(logN)，但是因为这个左旋和右旋的原因，导致插入数据的时候需要消耗大量的时间。</p><h2 id="场景题：现在有路由器a-b-c-d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？"><a href="#场景题：现在有路由器a-b-c-d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？" class="headerlink" title="场景题：现在有路由器a,b,c,d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？"></a>场景题：现在有路由器a,b,c,d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？</h2><p>在IP层遇到循环路由的情况下，数据包会被丢弃。IP协议是一种无连接的、不可靠的协议，它不会主动检查循环路由或处理数据包的循环传递。</p><p>为了防止数据包在网络中无限循环，网络管理员通常会配置路由器使用一些防循环机制，比如距离矢量路由协议中的Split Horizon技术，或链路状态路由协议中的Reverse Path Forwarding（RPF）检查。这些机制有助于检测和避免数据包在网络中形成循环路径。</p><p>但是，即使配置了防循环机制，由于网络的复杂性和问题可能的多样性，有时候循环路由问题仍然可能发生。在这种情况下，IP层不会继续无限传递数据包，而是丢弃它，从而避免对网络产生更严重的影响。丢弃数据包是为了确保网络中的数据传输是可靠和有效的，即使牺牲了某些数据包。</p><h2 id="Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？"><a href="#Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？" class="headerlink" title="Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？"></a>Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？</h2><p>stat的基本单位是块，也就是byte。转换成可识别的大小的话，通过1 kb = 1024byte实现。</p><p>可以通过ls -lh</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实习项目的监听字段是基于什么实现的？&quot;&gt;&lt;a href=&quot;#实习项目的监听字段是基于什么实现的？&quot; class=&quot;headerlink&quot; title=&quot;实习项目的监听字段是基于什么实现的？&quot;&gt;&lt;/a&gt;实习项目的监听字段是基于什么实现的？&lt;/h2&gt;&lt;p&gt;前端进行某个</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面经-快手测开 2023 - 7 - 11</title>
    <link href="http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E5%BF%AB%E6%89%8B%E6%B5%8B%E5%BC%80%E5%AE%9E%E4%B9%A0/"/>
    <id>http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E5%BF%AB%E6%89%8B%E6%B5%8B%E5%BC%80%E5%AE%9E%E4%B9%A0/</id>
    <published>2023-07-23T06:50:54.000Z</published>
    <updated>2023-09-29T07:46:36.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍一下二手市场整体的架构，数据流的实现？"><a href="#简单介绍一下二手市场整体的架构，数据流的实现？" class="headerlink" title="简单介绍一下二手市场整体的架构，数据流的实现？"></a>简单介绍一下二手市场整体的架构，数据流的实现？</h2><p><strong>整体架构：</strong></p><ol><li>持久层和缓存的选型<ol><li>MySQL作为持久层：<ol><li>支持复杂条件数据查询：在二手市场中，用户会根据自身需求筛选不同的条件进行各种复杂的查询，例如按照不同条件筛选商品等，MySQL提供丰富的查询语言和索引支持，能够高效查询相关数据。</li><li>结构化数据存储：二手市场涉及大量的结构化数据，例如：用户信息，商品信息等。而MySQL是关系型数据库，适合存储和管理结构化数据，提供事务支持，保证数据的一致性和完整性。</li></ol></li><li>Redis作为缓存：<ol><li>二手市场是多读少写的场景，用户会频繁的浏览商品，但是对商品的修改变更有限，所以可以将物品信息添加至Redis中有效减轻MySQL的读取压力，提高系统的响应和性能。</li></ol></li></ol></li><li>服务的拆分方式</li></ol><p>暂时因为是单体架构，没有钱去购买太多的服务器，所以服务暂时没有进行具体的划分，如果要进行划分的话我觉得可以划分成以下几种服务：</p><ol><li><p>用户服务：主要是对用户的身份信息进行认证和鉴权。</p></li><li><p>UGC消息通知：可以处理二手市场发布、编辑商品信息后，通过邮件、消息推送的方式告知用户。</p></li><li><p>商品信息服务：负责二手商品信息的发布、编辑、删除、搜索等功能。</p></li><li><p>缓存服务：应对二手市场这种读大于写的场景，可以将最新的50条商品信息放入系统缓存中，优化用户查看商品的体验。</p></li><li><p>支付服务：支付服务负责处理用户的支付请求，与第三方支付平台进行交互，并确保支付的安全性和可靠性。</p></li><li><p>文件服务：用于处理用户上传的图片、视频。</p></li><li><p>服务容灾和负载均衡方式</p><ol><li>服务容灾：<ol><li>定期对系统的数据进行备份</li><li>定期检查维护服务器的实例，修复代码BUG等</li></ol></li><li>负载均衡：<ol><li>CDN服务：将静态资源（图片、视频等）放置在内容分发网络中，加快资源加载速度，减少服务器负载</li><li>缓存数据，使用缓存减轻服务器负担，提高响应速度</li><li>反向代理：通过Nginx反向代理服务实现负载均衡，等后面有多台服务器之后将请求分发给不同的服务器，提高服务可扩展性。</li></ol></li></ol></li></ol><p><strong>数据流实现：</strong></p><ol><li>用户上传商品：<ol><li>用户在应用中填写商品信息，并上传相关照片</li><li>上传的用户信息和照片URL被发送到服务器中进行处理和存储</li><li>服务器对传过来的数据进行数据库存储，并生成一个唯一ID</li></ol></li><li>商品展示和搜索：<ol><li>其他用户访问二手市场时，前端向后端请求商品数据</li><li>后端从数据库中获取数据列表，并返回给前端</li><li>用户可以根据自身的需求条件查询特定的商品，前端将搜索条件发送给后端，后端根据条件查询数据库并返回匹配的商品信息。</li></ol></li><li>商品详情获取：<ol><li>当用户点击某个商品的详情信息之后，前端发送请求，传递对应的商品ID给后端</li><li>后端根据商品ID在数据库中搜索并返回具体商品信息给前端展示</li></ol></li></ol><h2 id="如果检索某个具体商品是如何实现检索的？"><a href="#如果检索某个具体商品是如何实现检索的？" class="headerlink" title="如果检索某个具体商品是如何实现检索的？"></a>如果检索某个具体商品是如何实现检索的？</h2><h2 id="查询的时候如何避免慢查询？"><a href="#查询的时候如何避免慢查询？" class="headerlink" title="查询的时候如何避免慢查询？"></a>查询的时候如何避免慢查询？</h2><ul><li>索引优化，将经常用到的字段创建索引（除去经常更新的字段、重复度很高的字段、数据量较少的情况），比如单列索引和联合索引，从而避免全表扫描。</li><li>分页查询：对于返回大量的数据查询，使用分页查询的方式，限制返回的数据量，避免一次返回大量的数据导致查询速率很慢。</li><li>缓存查询：对于一些比较查询比较频繁的数据可以使用缓存来避免每次都进行数据库查询。</li><li>合理设计数据库的表结构：比如说说评论查询，二级评论可以通过添加一个masterId字段(对应的说说id)来快速定位到此二级评论是归属于哪条说说之下。</li></ul><h2 id="如何正确的创建索引？（即：什么时候创建索引？）"><a href="#如何正确的创建索引？（即：什么时候创建索引？）" class="headerlink" title="如何正确的创建索引？（即：什么时候创建索引？）"></a>如何正确的创建索引？（即：什么时候创建索引？）</h2><ul><li>字段具有唯一性限制，即重复度很低，且不是经常修改的字段</li><li>经常用于where子句查询</li><li>经常用于group by 或者 order by查询</li><li>表的数据量比较多的情况</li></ul><h2 id="二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？"><a href="#二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？" class="headerlink" title="二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？"></a>二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？</h2><ol><li>正确、错误、空物品查询</li><li>物品大小写查询</li><li>高并发查询</li><li>过滤项查询</li><li>物品状态查询</li><li>安全性测试：比如SQL注入</li><li>边界值测试：比如输入极限情况下，很长的字符串验证系统是否能正确处理。</li></ol><h2 id="后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？"><a href="#后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？" class="headerlink" title="后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？"></a>后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？</h2><ol><li>统计性能的方式：<ol><li>日志记录</li><li>性能监控工具的使用：比如New Relic、Prometheus等</li><li>负载测试，模拟大量并发请求，观察系统的响应情况和性能指标。</li></ol></li><li>有，限流操作如下：<ol><li>固定窗口计时器：设置一个固定时间窗口，例如</li></ol></li></ol><h2 id="HashMap、HashSet、HashTable的区别？"><a href="#HashMap、HashSet、HashTable的区别？" class="headerlink" title="HashMap、HashSet、HashTable的区别？"></a>HashMap、HashSet、HashTable的区别？</h2><p><strong>HashMap和HashTable区别：</strong></p><ul><li>线程是否安全：HashMap是非线程安全，HashTable是线程安全（通过synchronized修饰实现）。</li><li>效率：由于HashMap线程不安全，HashMap比HashTable效率高，但是HashTable几乎被淘汰，平时一般不会用HashTable。</li><li>键值对存值问题：HashMap是可存null键和null值，HashTable不允许有null键和null值，否则会抛出异常NPE。</li><li>初始容量大小和每次扩充容量大小不同：HashTable初始化容量是11，每次扩容就是2n+1，HashMap初始化容量是16，每次扩容就是原来的2n倍。</li><li>底层数据结构：HashMap是<strong>数组+<strong><strong>链表</strong></strong>/红黑树</strong>实现，在解决哈希冲突时，当链表长度大于阈值（默认为8），将链表转化成红黑树（将链表转化成红黑树之前，如果数组长度小于64就会进行数组扩容，而不是转换成红黑树），以减少搜索时间，而HashTable是<strong>数组+链表</strong>的形式实现。</li></ul><p><strong>HashMap和<strong><strong>HashSet</strong></strong>的区别：</strong></p><ul><li>HashMap实现Map接口，HashSet实现Set接口。</li><li>HashMap存储键值对，HashSet只存储对象。</li><li>HashMap通过put方法添加元素，HashSet通过add()向Set中添加元素。</li><li>HashMap使用Key计算hashcode，HashSet使用成员对象计算hashcode值。</li></ul><h2 id="HashMap是线程的安全的吗？介绍一下ConcurrentHashMap"><a href="#HashMap是线程的安全的吗？介绍一下ConcurrentHashMap" class="headerlink" title="HashMap是线程的安全的吗？介绍一下ConcurrentHashMap"></a>HashMap是线程的安全的吗？介绍一下ConcurrentHashMap</h2><p>线程<strong>不安全</strong>，因为多线程情况下，HashMap进行键值对存值的时候，可能会因为分配到一个桶里面造成数据覆盖的风险，比如线程1，2同时进行put操作，此时正好发生了hash冲突，线程1执行完hash冲突判断之后，时间片耗尽挂起，此时线程2进行hash冲突判断并对数据插入到链表中，后面等线程1重新获取到时间片，进行插入操作就会覆盖掉线程插入的数据。</p><p><strong>ConcuurentHashMap：</strong></p><p>Java8以上数据结构是Node数组+链表/红黑树，哈希冲突时当链表长度大于一定长度时，链表就会转换成红黑树。</p><h2 id="接口和抽象类的区别？"><a href="#接口和抽象类的区别？" class="headerlink" title="接口和抽象类的区别？"></a>接口和抽象类的区别？</h2><ul><li>接口是对类的行为进行约束，实现了某个接口就是已经拥有了具体的行为，抽象类是代码复用，强调的是类的从属关系。</li><li>接口的成员变量只能用public static final修饰且不可修改和初始化，抽象类的成员变量默认为default类型，可以在子类被重新赋值定义。</li><li>一个类可以实现多个接口但是只能继承一个父类。</li></ul><h2 id="如果某个网页打不开了，排查手段有哪些？"><a href="#如果某个网页打不开了，排查手段有哪些？" class="headerlink" title="如果某个网页打不开了，排查手段有哪些？"></a>如果某个网页打不开了，排查手段有哪些？</h2><h2 id="Linux中查看主目录下以-log结尾的文件？"><a href="#Linux中查看主目录下以-log结尾的文件？" class="headerlink" title="Linux中查看主目录下以.log结尾的文件？"></a>Linux中查看主目录下以.log结尾的文件？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/home/directory -<span class="built_in">type</span> f -name <span class="string">&quot;*.log&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>find</code>：命令本身，用于查找文件和目录。</li><li><code>/path/to/home/directory</code>：替换为你要查找的主目录的路径。例如，如果你要在当前用户的主目录下查找，可以使用<code>~</code>代替这个路径。</li><li><code>-type f</code>：表示只查找普通文件，不包括目录等其他类型的文件。</li><li><code>-name &quot;*.log&quot;</code>：表示查找文件名以<code>.log</code>结尾的文件。<code>*.log</code>是通配符，表示匹配所有以<code>.log</code>结尾的文件名。</li></ul><h2 id="如何查询某个日志的内容？"><a href="#如何查询某个日志的内容？" class="headerlink" title="如何查询某个日志的内容？"></a>如何查询某个日志的内容？</h2><ul><li>Cat</li><li>Head</li><li>Tail</li><li>Less</li><li>More</li></ul><h2 id="比较一下less命令和more命令的区别？"><a href="#比较一下less命令和more命令的区别？" class="headerlink" title="比较一下less命令和more命令的区别？"></a>比较一下less命令和more命令的区别？</h2><ul><li>less支持前后翻页，more只支持向后翻页</li><li>less是根据要展示的内容加载到内存中，加快读取速度，more是将整个文件内容全部加载到内存中，可能会导致崩溃</li></ul><h2 id="算法题：力扣平衡字符串问题"><a href="#算法题：力扣平衡字符串问题" class="headerlink" title="算法题：力扣平衡字符串问题"></a>算法题：力扣平衡字符串问题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单介绍一下二手市场整体的架构，数据流的实现？&quot;&gt;&lt;a href=&quot;#简单介绍一下二手市场整体的架构，数据流的实现？&quot; class=&quot;headerlink&quot; title=&quot;简单介绍一下二手市场整体的架构，数据流的实现？&quot;&gt;&lt;/a&gt;简单介绍一下二手市场整体的架构，数</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
</feed>
