<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HUT菜鸟小八的博客</title>
  
  
  <link href="http://xiaobazeo.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaobazeo.github.io/"/>
  <updated>2023-07-23T06:54:01.314Z</updated>
  <id>http://xiaobazeo.github.io/</id>
  
  <author>
    <name>xiaoba</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快手测开 2023 - 7 - 11</title>
    <link href="http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E5%BF%AB%E6%89%8B%E6%B5%8B%E5%BC%80%E5%AE%9E%E4%B9%A0/"/>
    <id>http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E5%BF%AB%E6%89%8B%E6%B5%8B%E5%BC%80%E5%AE%9E%E4%B9%A0/</id>
    <published>2023-07-23T06:50:54.000Z</published>
    <updated>2023-07-23T06:54:01.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍一下二手市场整体的架构，数据流的实现？"><a href="#简单介绍一下二手市场整体的架构，数据流的实现？" class="headerlink" title="简单介绍一下二手市场整体的架构，数据流的实现？"></a>简单介绍一下二手市场整体的架构，数据流的实现？</h2><h2 id="如果检索某个具体商品是如何实现检索的？"><a href="#如果检索某个具体商品是如何实现检索的？" class="headerlink" title="如果检索某个具体商品是如何实现检索的？"></a>如果检索某个具体商品是如何实现检索的？</h2><h2 id="查询的时候如何避免慢查询？"><a href="#查询的时候如何避免慢查询？" class="headerlink" title="查询的时候如何避免慢查询？"></a>查询的时候如何避免慢查询？</h2><h2 id="如何正确的创建索引？（即：什么时候创建索引？）"><a href="#如何正确的创建索引？（即：什么时候创建索引？）" class="headerlink" title="如何正确的创建索引？（即：什么时候创建索引？）"></a>如何正确的创建索引？（即：什么时候创建索引？）</h2><h2 id="二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？"><a href="#二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？" class="headerlink" title="二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？"></a>二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？</h2><h2 id="后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？"><a href="#后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？" class="headerlink" title="后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？"></a>后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？</h2><h2 id="HashMap、HashSet、HashTable的区别？"><a href="#HashMap、HashSet、HashTable的区别？" class="headerlink" title="HashMap、HashSet、HashTable的区别？"></a>HashMap、HashSet、HashTable的区别？</h2><h2 id="HashMap是线程的安全的吗？介绍一下ConcurrentHashMap"><a href="#HashMap是线程的安全的吗？介绍一下ConcurrentHashMap" class="headerlink" title="HashMap是线程的安全的吗？介绍一下ConcurrentHashMap"></a>HashMap是线程的安全的吗？介绍一下ConcurrentHashMap</h2><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><h2 id="如果某个网页打不开了，排查手段有哪些？"><a href="#如果某个网页打不开了，排查手段有哪些？" class="headerlink" title="如果某个网页打不开了，排查手段有哪些？"></a>如果某个网页打不开了，排查手段有哪些？</h2><h2 id="Linux中查看主目录下以-log结尾的文件？"><a href="#Linux中查看主目录下以-log结尾的文件？" class="headerlink" title="Linux中查看主目录下以.log结尾的文件？"></a>Linux中查看主目录下以.log结尾的文件？</h2><h2 id="如何查询某个日志的内容？"><a href="#如何查询某个日志的内容？" class="headerlink" title="如何查询某个日志的内容？"></a>如何查询某个日志的内容？</h2><h2 id="比较一下less命令和more命令的区别？"><a href="#比较一下less命令和more命令的区别？" class="headerlink" title="比较一下less命令和more命令的区别？"></a>比较一下less命令和more命令的区别？</h2><h2 id="算法题：力扣平衡字符串问题"><a href="#算法题：力扣平衡字符串问题" class="headerlink" title="算法题：力扣平衡字符串问题"></a>算法题：力扣平衡字符串问题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单介绍一下二手市场整体的架构，数据流的实现？&quot;&gt;&lt;a href=&quot;#简单介绍一下二手市场整体的架构，数据流的实现？&quot; class=&quot;headerlink&quot; title=&quot;简单介绍一下二手市场整体的架构，数据流的实现？&quot;&gt;&lt;/a&gt;简单介绍一下二手市场整体的架构，数</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>滴滴golang后端实习 2023 - 07 - 04</title>
    <link href="http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E6%BB%B4%E6%BB%B4Golang%E5%AE%9E%E4%B9%A0/"/>
    <id>http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E6%BB%B4%E6%BB%B4Golang%E5%AE%9E%E4%B9%A0/</id>
    <published>2023-07-23T05:16:20.000Z</published>
    <updated>2023-07-23T06:53:48.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP有哪些请求方式？"><a href="#HTTP有哪些请求方式？" class="headerlink" title="HTTP有哪些请求方式？"></a>HTTP有哪些请求方式？</h2><h2 id="POST和GET的使用场景及区别？"><a href="#POST和GET的使用场景及区别？" class="headerlink" title="POST和GET的使用场景及区别？"></a>POST和GET的使用场景及区别？</h2><h2 id="Token在HTTP请求的时候会放在什么位置？"><a href="#Token在HTTP请求的时候会放在什么位置？" class="headerlink" title="Token在HTTP请求的时候会放在什么位置？"></a>Token在HTTP请求的时候会放在什么位置？</h2><h2 id="GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？"><a href="#GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？" class="headerlink" title="GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？"></a>GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？</h2><h2 id="介绍一下对Spring的理解"><a href="#介绍一下对Spring的理解" class="headerlink" title="介绍一下对Spring的理解"></a>介绍一下对Spring的理解</h2><h2 id="Spring、SpringMVC、SpringleBoot的区别"><a href="#Spring、SpringMVC、SpringleBoot的区别" class="headerlink" title="Spring、SpringMVC、SpringleBoot的区别"></a>Spring、SpringMVC、SpringleBoot的区别</h2><h2 id="解释一下SpringIOC、SpringAOP"><a href="#解释一下SpringIOC、SpringAOP" class="headerlink" title="解释一下SpringIOC、SpringAOP"></a>解释一下SpringIOC、SpringAOP</h2><h2 id="SpringAOP是如何实现的？"><a href="#SpringAOP是如何实现的？" class="headerlink" title="SpringAOP是如何实现的？"></a>SpringAOP是如何实现的？</h2><h2 id="Sql注入攻击是什么？SQL注入是怎么产生的？"><a href="#Sql注入攻击是什么？SQL注入是怎么产生的？" class="headerlink" title="Sql注入攻击是什么？SQL注入是怎么产生的？"></a>Sql注入攻击是什么？SQL注入是怎么产生的？</h2><h2 id="什么时候需要创建索引？"><a href="#什么时候需要创建索引？" class="headerlink" title="什么时候需要创建索引？"></a>什么时候需要创建索引？</h2><h2 id="为什么索引如果重复度比较高的时候会对数据库产生一定的压力？"><a href="#为什么索引如果重复度比较高的时候会对数据库产生一定的压力？" class="headerlink" title="为什么索引如果重复度比较高的时候会对数据库产生一定的压力？"></a>为什么索引如果重复度比较高的时候会对数据库产生一定的压力？</h2><h2 id="创建联合索引失效的情况"><a href="#创建联合索引失效的情况" class="headerlink" title="创建联合索引失效的情况"></a>创建联合索引失效的情况</h2><h2 id="如果有一个联合索引-a-b-c-，如果where子句查询只有a-1-and-c-1，能不能实现走-a-b-c-这个索引查询？"><a href="#如果有一个联合索引-a-b-c-，如果where子句查询只有a-1-and-c-1，能不能实现走-a-b-c-这个索引查询？" class="headerlink" title="如果有一个联合索引(a,b,c)，如果where子句查询只有a = 1 and c = 1，能不能实现走(a,b,c)这个索引查询？"></a>如果有一个联合索引(a,b,c)，如果where子句查询只有a = 1 and c = 1，能不能实现走(a,b,c)这个索引查询？</h2><h2 id="目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？"><a href="#目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？" class="headerlink" title="目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？"></a>目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？</h2><h2 id="有两个集合List如何快速找出相同或两个相关联的元素？"><a href="#有两个集合List如何快速找出相同或两个相关联的元素？" class="headerlink" title="有两个集合List如何快速找出相同或两个相关联的元素？"></a>有两个集合List如何快速找出相同或两个相关联的元素？</h2><h2 id="数据结构：哈希如何使用？"><a href="#数据结构：哈希如何使用？" class="headerlink" title="数据结构：哈希如何使用？"></a>数据结构：哈希如何使用？</h2><h2 id="有一个集合Set怎么批量删除部分元素？"><a href="#有一个集合Set怎么批量删除部分元素？" class="headerlink" title="有一个集合Set怎么批量删除部分元素？"></a>有一个集合Set怎么批量删除部分元素？</h2><h2 id="Linux查询一个日志文件的关键字？查询某个关键字的前后500行？"><a href="#Linux查询一个日志文件的关键字？查询某个关键字的前后500行？" class="headerlink" title="Linux查询一个日志文件的关键字？查询某个关键字的前后500行？"></a>Linux查询一个日志文件的关键字？查询某个关键字的前后500行？</h2><h2 id="怎么保证MySQL和Redis的一致性问题？"><a href="#怎么保证MySQL和Redis的一致性问题？" class="headerlink" title="怎么保证MySQL和Redis的一致性问题？"></a>怎么保证MySQL和Redis的一致性问题？</h2><h2 id="价格类型的数据Java用什么存储？"><a href="#价格类型的数据Java用什么存储？" class="headerlink" title="价格类型的数据Java用什么存储？"></a>价格类型的数据Java用什么存储？</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP有哪些请求方式？&quot;&gt;&lt;a href=&quot;#HTTP有哪些请求方式？&quot; class=&quot;headerlink&quot; title=&quot;HTTP有哪些请求方式？&quot;&gt;&lt;/a&gt;HTTP有哪些请求方式？&lt;/h2&gt;&lt;h2 id=&quot;POST和GET的使用场景及区别？&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用</title>
    <link href="http://xiaobazeo.github.io/2023/05/29/Docker%E4%BD%BF%E7%94%A8/"/>
    <id>http://xiaobazeo.github.io/2023/05/29/Docker%E4%BD%BF%E7%94%A8/</id>
    <published>2023-05-29T15:46:11.000Z</published>
    <updated>2023-05-29T16:25:48.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h2><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230529235020493.png" alt="image-20230529235020493"></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul><li>docker images</li></ul><blockquote><p>罗列出docker的所有的镜像相关信息</p></blockquote><ul><li>docker search 某个xxx镜像的名字</li></ul><blockquote><p>在hub仓库查询是否有相关的镜像 –limit 默认罗列前25个</p></blockquote><ul><li>docker pull 某个xxx镜像名[:tag]</li></ul><blockquote><p>tag:表示版本号    </p></blockquote><ul><li><p>docker system df 查看镜像/容器/数据卷所占空间</p></li><li><p>docker rmi 某个xxx镜像的id或者名字  -f强制删除</p><blockquote><p>docker rmi hello-world 或 docker rmi 9c7a54a9a43c<br>删除多个:</p><pre><code>docker rmi -f 镜像名1:tag 镜像名2:tag....docker rmi -f $(docker images -qa)</code></pre></blockquote><p>什么叫虚悬镜像？</p><p>仓库名、标签都是<none>的，俗称虚悬镜像，通常会把他删掉</none></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;帮助启动类命令&quot;&gt;&lt;a href=&quot;#帮助启动类命令&quot; class=&quot;headerlink&quot; title=&quot;帮助启动类命令&quot;&gt;&lt;/a&gt;帮助启动类命令&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://pengzihao166.oss-cn-beijing.aliy</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://xiaobazeo.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>备份hexo-_o-U盘篇</title>
    <link href="http://xiaobazeo.github.io/2023/05/16/%E5%A4%87%E4%BB%BDhexo-o-U%E7%9B%98%E7%AF%87/"/>
    <id>http://xiaobazeo.github.io/2023/05/16/%E5%A4%87%E4%BB%BDhexo-o-U%E7%9B%98%E7%AF%87/</id>
    <published>2023-05-16T07:06:32.000Z</published>
    <updated>2023-05-16T07:28:46.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新机环境搭建"><a href="#新机环境搭建" class="headerlink" title="新机环境搭建"></a>新机环境搭建</h2><p>​    1、安装Node.js</p><p>​    2、安装Git</p><p>​    3、新建存放Blog的文件夹</p><h2 id="拷贝旧机器中得文件-文件夹"><a href="#拷贝旧机器中得文件-文件夹" class="headerlink" title="拷贝旧机器中得文件/文件夹"></a>拷贝旧机器中得文件/文件夹</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line"><span class="keyword">package</span>.json</span><br><span class="line">scaffolds/</span><br><span class="line"><span class="keyword">source</span>/</span><br><span class="line">themes/</span><br><span class="line">其中/代表拷贝的是文件夹</span><br></pre></td></tr></table></figure><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>右键打开Git bash，依次输入下列命令之后，安装相关依赖</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>安装hexo</span><br><span class="line">   <span class="built_in">npm</span> install -g hexo</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>本地测试的时候需要用hexo server</span><br><span class="line">   <span class="built_in">npm</span> i hexo-server</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>将文章部署到github上的模块</span><br><span class="line">   <span class="built_in">npm</span> install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>安装RSS插件</span><br><span class="line">   <span class="built_in">npm</span> install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>添加Sitemap,加速网页收录速度</span><br><span class="line">   <span class="built_in">npm</span> install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><h2 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s -g == hexo g + hexo s</span><br></pre></td></tr></table></figure><p>在浏览器打开<a href="http://localhost:4000/">http://localhost:4000</a>查看效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新机环境搭建&quot;&gt;&lt;a href=&quot;#新机环境搭建&quot; class=&quot;headerlink&quot; title=&quot;新机环境搭建&quot;&gt;&lt;/a&gt;新机环境搭建&lt;/h2&gt;&lt;p&gt;​    1、安装Node.js&lt;/p&gt;
&lt;p&gt;​    2、安装Git&lt;/p&gt;
&lt;p&gt;​    3、新建存</summary>
      
    
    
    
    
    <category term="备份" scheme="http://xiaobazeo.github.io/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>网络基础篇</title>
    <link href="http://xiaobazeo.github.io/2023/05/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://xiaobazeo.github.io/2023/05/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2023-05-15T18:25:03.000Z</published>
    <updated>2023-05-16T08:27:01.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP网络模型有哪几层？"><a href="#TCP-IP网络模型有哪几层？" class="headerlink" title="TCP/IP网络模型有哪几层？"></a>TCP/IP网络模型有哪几层？</h2><h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><p>&emsp;&emsp;用户直接接触到的就是<strong>应用层</strong>，应用层专注于用户提供应用功能，例如：HTTP、FTP、DNS、Telnet、SMTP等。</p><p>&emsp;&emsp;应用层工作在操作系统中得<strong>用户态</strong>，<strong>传输层及以下</strong>则工作在<strong>内核态</strong>。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>&emsp;&emsp;应用层的数据包会传给传输层，传输层是为应用层提供网络支持。传输层的两个协议：<strong>TCP</strong>和<strong>UDP</strong>。</p><p>&emsp;&emsp;TCP（传输控制协议），TCP相较于UDP的特性，比如：<strong>流量控制，超时重传，拥塞控制</strong>等，为了保证数据包能可靠的传输给对方。</p><p>&emsp;&emsp;UDP只负责发送数据包，<strong>不保证</strong>数据包是否能抵达对方，但是<strong>实时性</strong>相对较好，<strong>传输效率</strong>也较高。如果要实现UDP的可靠传输，可以把TCP的特性在应用层实现。</p><p>&emsp;&emsp;应用传输数据过大，传输层的数据包大小超过MSS(TCP最大报文段长度)，需要将数据包分块，如果中途有一个分块丢失或损坏，只需重新发送此分块即可，而不需要发送整个数据包。在TCP协议中，<strong>每个分块称为一个TCP段</strong>（TCP Segment）。</p><p>&emsp;&emsp;传输层负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，此时需要用一个编号将应用区分开，这个编号就是端口。例如：Web服务器通常使用80端口，22端口通常是远程登录服务器的端口。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>&emsp;&emsp;实现传输功能的是<strong>网络层</strong>，传输层只是作为数据传输的媒介，帮助应用到应用的通信。</p><p>&emsp;&emsp;常见协议是IP协议（Internet Protocol），IP协议会将传输层的报文作为数据部分，再加上IP包头部组装成IP报文，如果IP报文大小超过MTU（一般默认1500Bytes）会<strong>再次进行分片</strong>，得到一个即将发送的到网络的IP报文。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/12.jpg" alt="选自小林coding"></p><h4 id="IP协议寻址功能："><a href="#IP协议寻址功能：" class="headerlink" title="IP协议寻址功能："></a>IP协议寻址功能：</h4><p>&emsp;&emsp;由于网络层需要有区分设备的编号，一般使用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分为四段（比如：192.168.100.1），每段8位。由于IPv4地址有设备上限，无法做到一个设备一个IP地址，所以会将IP地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该IP地址是属于哪个<strong>子网</strong>的</li><li>一个是<strong>主机号</strong>，负责标识<strong>同一子网</strong>下的<strong>不同主机</strong></li></ul><p>此时需要<strong>子网掩码</strong>才能计算出IP地址的网络号和主机号，比如：10.100.122.0/24，后面的/24表示就是255.255.255.0子网掩码，255.255.255.0二进制就是11111111-11111111-11111111-00000000，24个1，为了简化子网掩码的表示，就会用/24代替255.255.255.0</p><p><strong>网络号</strong>将 10.100.122.2 和 255.255.255.0 <strong>按位与运算</strong>。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/16.jpg" alt="取自小林coding"></p><p><strong>主机号：</strong>将 255.255.255.0 <strong>取反</strong>后与IP地址进行进行<strong>按位与运算</strong>。</p><p>在寻址过程中，先匹配相同的网络号（表示要找到同一个子网），才会去找对应的主机号。</p><h4 id="IP协议路由功能"><a href="#IP协议路由功能" class="headerlink" title="IP协议路由功能"></a>IP协议路由功能</h4><p>当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p><p>IP协议的寻址是告诉我们去往下一个目的地朝哪个方向走，路由是根据下一个目的地选择路径。</p><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>网络接口层会在IP头部的前面加上MAC头部，并封装成数据帧发送到网络上。网络接口层主要是为网络层提供链路级别传输的服务，负责以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来表示网络上的设备。</p><p>MAC头部是以以太网的头部，包含了接收方和发送方的MAC地址等信息，可以通过ARP协议获取对方的MAC地址。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络接口层的传输单位是帧，IP的传输单位是包，TCP层传输单位是段，HTTP传输单位是消息或报文，每一层的封装格式如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="取自小林coding"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP-IP网络模型有哪几层？&quot;&gt;&lt;a href=&quot;#TCP-IP网络模型有哪几层？&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP网络模型有哪几层？&quot;&gt;&lt;/a&gt;TCP/IP网络模型有哪几层？&lt;/h2&gt;&lt;h3 id=&quot;应用层：&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="计网" scheme="http://xiaobazeo.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>法大大Java实习 2023.4.6</title>
    <link href="http://xiaobazeo.github.io/2023/04/06/%E9%9D%A2%E7%BB%8F-%E6%B3%95%E5%A4%A7%E5%A4%A7Java%E5%BC%80%E5%8F%91/"/>
    <id>http://xiaobazeo.github.io/2023/04/06/%E9%9D%A2%E7%BB%8F-%E6%B3%95%E5%A4%A7%E5%A4%A7Java%E5%BC%80%E5%8F%91/</id>
    <published>2023-04-06T13:51:08.000Z</published>
    <updated>2023-07-23T06:53:17.463Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E6%B3%95%E5%A4%A7%E5%A4%A7(2023.4.6).png" alt="法大大(2023.4.6)"></p><h2 id="总结：（答得不是很完善的地方总结一下）"><a href="#总结：（答得不是很完善的地方总结一下）" class="headerlink" title="总结：（答得不是很完善的地方总结一下）"></a>总结：（答得不是很完善的地方总结一下）</h2><h3 id="接口和抽象类的共同点和区别："><a href="#接口和抽象类的共同点和区别：" class="headerlink" title="接口和抽象类的共同点和区别："></a>接口和抽象类的共同点和区别：</h3><p><strong>共同点：</strong> </p><ul><li>不可以被实例化</li><li>可以包含抽象方法</li><li>可以有默认的实现方法</li></ul><p><strong>区别：</strong></p><ul><li>接口对类的行为进行约束，实现某接口已经拥有了的具体行为，抽象类代码复用，强调的是从属关系</li><li>接口的成员变量只能用public static final修饰且不可修改并初始化，抽象类默认是default类型，可以在子类被重新定义且重新赋值</li><li>一个类只能继承一个抽象类（单继承），可实现多个接口。</li></ul><h3 id="和-equals-方法"><a href="#和-equals-方法" class="headerlink" title="== 和 equals()方法"></a>== 和 equals()方法</h3><p><strong>== 两种情况：</strong></p><ul><li>对于基本数据类型，直接比较值的大小</li><li>对于引用类型，比较对象的内存地址</li></ul><p><strong>equals（）方法：</strong></p><p>比较对象是否相等，即对象的内存地址是否相等，一般也分为两种情况</p><ul><li>重写了，一般比较两个对象的成员属性是否相等</li><li>未重写，比较的该类型的对象是否相等</li></ul><h3 id="try-catch-finally方法"><a href="#try-catch-finally方法" class="headerlink" title="try-catch-finally方法"></a>try-catch-finally方法</h3><ul><li>如果在catch中return了，那么finally里面的逻辑会在return之前被执行。</li><li>如果catch和finally都有return，那么catch的return会被忽略，</li><li>因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</li><li>finally一般用于资源回收、比如线程、数据库资源回收的情况</li></ul><h3 id="HashMap和HashSet区别"><a href="#HashMap和HashSet区别" class="headerlink" title="HashMap和HashSet区别"></a>HashMap和HashSet区别</h3><ul><li>前者实现了Map接口，后者实现了Set接口</li><li>HashSet底层是HashMap实现存储的</li></ul><h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><ul><li>前者继承了AbstractMap类，后者继承了Dictionary类</li><li>HashMap线程不安全，HashTable线程安全</li><li>contains不一样，HashMap没有contains方法只有containsValue和containsKey方法，但是HashTable这三个方法都有</li><li>key-value是否能为null，HashMap 都可以为null，HashTable都不可以null，否则就是空指针异常</li><li>获取hashCode方法不一样</li></ul><p>&emsp;&emsp;HashMap先调用hashCode获取到了hash值之后，再与右移16位的hash值相异或获取hash值。</p><p>&emsp;&emsp;HashTable直接通过hashCode方法获取</p><ul><li>解决hash冲突方法不一样</li></ul><p>&emsp;&emsp;HashMap通过数组+链表/红黑树，如果链表长度大于8，变成红黑树，若链表长度后面小于6，转回链表格式</p><p>&emsp;&emsp;HashTable只有链表存储</p><h3 id="项目介绍："><a href="#项目介绍：" class="headerlink" title="项目介绍："></a>项目介绍：</h3><p>因为主要是自己写的、在redis那一块也比较熟悉，也自己解决了缓存雪崩的问题，后面也解决了缓存和数据库一致性问题，但是面试的时候忘记提了，可能提了会更加加分~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E6%B3%95%E5%A4%A7%E5%A4%A7(2023.4.6).png&quot; alt=&quot;法大大(2023.4.6)&quot;&gt;&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="程序人生" scheme="http://xiaobazeo.github.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之最长回文子串</title>
    <link href="http://xiaobazeo.github.io/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://xiaobazeo.github.io/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2023-03-21T08:46:39.000Z</published>
    <updated>2023-03-21T08:51:52.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><h2 id="题解如下"><a href="#题解如下" class="headerlink" title="题解如下"></a>题解如下</h2><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230321164819370.png" alt="image-20230321164819370"></p><h5 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">boolean</span> [][]dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">//所有的一个字符的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">//记录回文子串的初始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录回文子串长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">childLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span>; l &lt;= len;l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">                <span class="comment">//j代表子串的尾字符的index，即确定右边界</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果尾字符超出字符串最大长度、跳出循环</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= len)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(charArray[i]!=charArray[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//可能是一个或者两个或者三个字符的子串</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则就依次递归</span></span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若 dp[i][l] == true 成立，就表示s[i....l]是回文，记录此时回文的长度以及起始位置</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; childLen)&#123;</span><br><span class="line">                    childLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin + childLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目如下：&quot;&gt;&lt;a href=&quot;#题目如下：&quot; class=&quot;headerlink&quot; title=&quot;题目如下：&quot;&gt;&lt;/a&gt;题目如下：&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之寻找两个正序数组的中位数</title>
    <link href="http://xiaobazeo.github.io/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://xiaobazeo.github.io/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2023-03-21T08:41:26.000Z</published>
    <updated>2023-03-21T08:46:03.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,3]</span>, nums2 = <span class="comment">[2]</span></span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = <span class="comment">[1,2,3]</span> ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 <span class="comment">(2 + 3)</span> / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>方法1：合并数组之后直接使用Arrays.sort()进行排序，最后返回中位数即可，若为奇数则返回(nums1.length + nums2.length)  / 2的值，偶数则返回(nums2.length + nums2.length) / 2 - 1和(nums1.length + nums2.length) / 2之和的平均数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[m+n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            nums[i] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n; j++)&#123;</span><br><span class="line">            nums[nums1.length + j] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span>(nums.length % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[(m + n) / <span class="number">2</span> - <span class="number">1</span>] + nums[(m + n) / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[(m + n) / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法还在研究ing。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目如下：&quot;&gt;&lt;a href=&quot;#题目如下：&quot; class=&quot;headerlink&quot; title=&quot;题目如下：&quot;&gt;&lt;/a&gt;题目如下：&lt;/h2&gt;&lt;p&gt;给定两个大小分别为 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 的正序（从小到大）数组 &lt;cod</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之无重复字符的最长子串</title>
    <link href="http://xiaobazeo.github.io/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://xiaobazeo.github.io/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2023-03-19T10:02:35.000Z</published>
    <updated>2023-03-19T10:06:59.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下"></a>题目如下</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h2 id="题解如下："><a href="#题解如下：" class="headerlink" title="题解如下："></a>题解如下：</h2><p>主要用到的思想就是滑动窗口，通过HashMap集合的key值不可重复原理来判断是否遇到重复的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//考虑孔字符串的情况</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//统计最大的子串长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左指针指向子串的第一个字符index</span></span><br><span class="line">        <span class="comment">//以字符串的一个字符作为key,其对应的index作为value</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;<span class="comment">//判断是否i位置下的字符是否有对应的value，如果有那么就说明重复了，此时将左指针定位到对应的value下，因为对应的value保存的就是此时此字符的index</span></span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            <span class="comment">//此时最大的子串不重复长度就是i - left + 1(即此时正在扫描的子串长度) 和 maxLength(上一串扫描的子串长度) 二者最大值之一。</span></span><br><span class="line">            maxLength = Math.max(maxLength,i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目如下&quot;&gt;&lt;a href=&quot;#题目如下&quot; class=&quot;headerlink&quot; title=&quot;题目如下&quot;&gt;&lt;/a&gt;题目如下&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之两数相加</title>
    <link href="http://xiaobazeo.github.io/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://xiaobazeo.github.io/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2023-03-19T04:20:14.000Z</published>
    <updated>2023-03-19T04:25:12.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[2,4,3]</span>, l2 = <span class="comment">[5,6,4]</span></span><br><span class="line">输出：<span class="comment">[7,0,8]</span></span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[0]</span>, l2 = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">9,9,9,9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>], l2 = [<span class="number">9,9,9,9</span>]</span><br><span class="line">输出：[<span class="number">8,9,9,9</span>,<span class="number">0,0,0,1</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h2 id="题解如下："><a href="#题解如下：" class="headerlink" title="题解如下："></a>题解如下：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//进位数字</span></span><br><span class="line">        <span class="comment">//定义一个可移动的指针，用来指向存储两个数之和的位置</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">         <span class="comment">//定义一个新联表伪指针，用来指向头指针，返回结果</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="comment">//当l1 不等于null或l2 不等于空时，就进入循环</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果l1 不等于null时，就取他的值，等于null时，就赋值0，保持两个链表具有相同的位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="comment">//将两个链表的值，进行相加，并加上进位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + carry;</span><br><span class="line">            <span class="comment">//计算进位数</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//计算两个数的和，此时排除超过10的请况（大于10，取余数）</span></span><br><span class="line">            sum %= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//将求和数赋值给新链表的节点，</span></span><br><span class="line">            <span class="comment">//注意这个时候不能直接将sum赋值给cur.next = sum。这时候会报，类型不匹配。</span></span><br><span class="line">            <span class="comment">//所以这个时候要创一个新的节点，将值赋予节点</span></span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line">             <span class="comment">//将新链表的节点后移</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="comment">//当链表l1不等于null的时候，将l1 的节点后移</span></span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">null</span>)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果最后两个数，相加的时候有进位数的时候，就将进位数，赋予链表的新节点。</span></span><br><span class="line">        <span class="comment">//两数相加最多小于20，所以的的值最大只能时1</span></span><br><span class="line">            <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目如下：&quot;&gt;&lt;a href=&quot;#题目如下：&quot; class=&quot;headerlink&quot; title=&quot;题目如下：&quot;&gt;&lt;/a&gt;题目如下：&lt;/h2&gt;&lt;p&gt;给你两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表，表示两个非负的整数。它们每位数字都是按照 &lt;strong&gt;</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot开发规范(二)</title>
    <link href="http://xiaobazeo.github.io/2023/02/04/SpringBoot%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83-%E4%BA%8C/"/>
    <id>http://xiaobazeo.github.io/2023/02/04/SpringBoot%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83-%E4%BA%8C/</id>
    <published>2023-02-04T15:37:16.000Z</published>
    <updated>2023-02-04T15:39:01.276Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PO即persistant-Object-持久对象："><a href="#PO即persistant-Object-持久对象：" class="headerlink" title="PO即persistant Object 持久对象："></a><strong>PO即persistant Object 持久对象：</strong></h3><p>&emsp;在O/R 映射（即ORM-ObjectRelationMapping）中出现的概念，通常对应数据模型（数据库），是与数据库汇总的表想影射的java对象，最简单的PO就是对应数据库中某个表中的一条记录，多个记录则用PO的集合。PO中不应该包含任何对数据库的操作。</p><h3 id="DO即Domain-Object-领域对象："><a href="#DO即Domain-Object-领域对象：" class="headerlink" title="DO即Domain Object 领域对象："></a><strong>DO即Domain Object 领域对象：</strong></h3><p>&emsp;是从现实世界中抽象出来的有形或无形的业务实体。</p><h3 id="TO即Transfer-Object数据传输对象："><a href="#TO即Transfer-Object数据传输对象：" class="headerlink" title="TO即Transfer Object数据传输对象："></a><strong>TO即Transfer Object数据传输对象：</strong></h3><p>&emsp;不同应用程序之间传输的对象</p><h3 id="DTO即Data-Transfer-Object-数据传输对象："><a href="#DTO即Data-Transfer-Object-数据传输对象：" class="headerlink" title="DTO即Data Transfer Object:数据传输对象："></a><strong>DTO即Data Transfer Object:数据传输对象：</strong></h3><p>&emsp;泛指用于展示层与服务层之间的数据传输对象</p><h3 id="VO即value-Object："><a href="#VO即value-Object：" class="headerlink" title="VO即value Object："></a><strong>VO即value Object：</strong></h3><p>&emsp;通常用于业务层之间的数据传递，和PO一样仅包含数据，但是抽象出的业务对象，可以和表对应，用new 关键字创建，GC回收</p><h3 id="BO即Business-Object-业务对象"><a href="#BO即Business-Object-业务对象" class="headerlink" title="BO即Business Object 业务对象:"></a><strong>BO即Business Object 业务对象:</strong></h3><p>&emsp;主要是将业务逻辑封装为一个对象，这个对象可以包含一个或多个其他对象，如一个简历中包含教育经历、工作经历、社会关系等，可以将一个教育经历对应一个PO、工作经历对应一个PO、设计关系对应一个PO，然后简历一个对应简历的BO兑现处理简历，每个BO包含这个PO这样处理业务逻辑是，可以针对BO去处理。封装业务逻辑的java对象，通过调用DAO方法，结合PO,VO进行业务操作。</p><h3 id="POJO即Plain-Ordinary-Java-Object"><a href="#POJO即Plain-Ordinary-Java-Object" class="headerlink" title="POJO即Plain Ordinary Java Object:"></a><strong>POJO即Plain Ordinary Java Object:</strong></h3><p>&emsp;简单无规则的java对性，即在一些O/R 映射工具中，能做到维护数据库表记录的PO完全是一个符合Java Bean规范的纯java对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;PO即persistant-Object-持久对象：&quot;&gt;&lt;a href=&quot;#PO即persistant-Object-持久对象：&quot; class=&quot;headerlink&quot; title=&quot;PO即persistant Object 持久对象：&quot;&gt;&lt;/a&gt;&lt;strong&gt;</summary>
      
    
    
    
    
    <category term="SpringBoot开发规范" scheme="http://xiaobazeo.github.io/tags/SpringBoot%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-连续子数组的最大和</title>
    <link href="http://xiaobazeo.github.io/2023/02/02/%E5%89%91%E6%8C%87offer-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://xiaobazeo.github.io/2023/02/02/%E5%89%91%E6%8C%87offer-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</id>
    <published>2023-02-02T14:06:48.000Z</published>
    <updated>2023-02-02T14:25:05.835Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=cug7nw1"><em>剑指 Offer 42. 连续子数组的最大和</em></a></p><p>[TOC]</p><h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230202220726900.png"></p><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h3 id="1、动态规划"><a href="#1、动态规划" class="headerlink" title="1、动态规划"></a>1、动态规划</h3><h4 id="推想："><a href="#推想：" class="headerlink" title="推想："></a>推想：</h4><p>​    若nums数组的长度为n，下标则为0~n-1，用f(i)表示以第i个数结尾的<strong>连续子数组的最大和</strong>，故有：</p><p>​<br>$$<br>max{f(i)},0≤i≤n-1<br>$$</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>​    求出每段以第i个数结尾的子数组的f(i)，返回最大的f(i)即可</p><h4 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h4><p>​    考虑nums[i]单独成一段还是加入f(i-1)这一段子数组，则可以通过判断nums[i] + f(i-1)和nums[i]的大小实现</p><p>$$<br>f(i) = max{nums[i]+f(i-1),nums[i]}<br>$$</p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//存储f(i - 1)的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">           pre = Math.max(x + pre, x);</span><br><span class="line">           maxSum = Math.max(pre , maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、分治法："><a href="#2、分治法：" class="headerlink" title="2、分治法："></a>2、分治法：</h3><p>见<a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solutions/876881/lian-xu-zi-shu-zu-de-zui-da-he-by-leetco-tiui/">leetcode题解</a>(点击即可查看)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/?envType=study-plan&amp;id=lcof&amp;plan=lcof&amp;plan_progress=cug7nw1&quot;&gt;&lt;e</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>谈谈wx和wss</title>
    <link href="http://xiaobazeo.github.io/2023/02/02/%E8%B0%88%E8%B0%88wx%E5%92%8Cwss/"/>
    <id>http://xiaobazeo.github.io/2023/02/02/%E8%B0%88%E8%B0%88wx%E5%92%8Cwss/</id>
    <published>2023-02-02T12:21:50.000Z</published>
    <updated>2023-02-02T13:19:38.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="了解WS和WSS"><a href="#了解WS和WSS" class="headerlink" title="了解WS和WSS"></a>了解WS和WSS</h2><p>&emsp;WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。</p><p>&emsp;WebSocket建立在TCP之上，同HTTP一样通过TCP来传输数据，但是它和HTTP最大不同是：WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/Client Agent都能主动的向对方发送或接收数据，就像Socket一样；WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。</p><p>&emsp;WSS（Web Socket Secure）是WebSocket的加密版本。WS一般默认是80端口，而WSS默认是443端口，大多数网站用的就是80和433端口。（在高防防护过程中，80和433端口的网站是需要备案才可以接入国内的。）</p><p>&emsp;WS体现形式：<strong>TCP+WS AS WS 。</strong></p><p>&emsp;WSS体现形式：<strong>TCP+TLS+WS AS WS。</strong></p><p>&emsp;服务器网址就是 URL。</p><h2 id="WS-WSS出现的原因"><a href="#WS-WSS出现的原因" class="headerlink" title="WS/WSS出现的原因"></a>WS/WSS出现的原因</h2><p>&emsp;目前很多应用要求服务端有能力进行实时推送能力（例如直播间聊天室），以往很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。</p><p>​    这种传统的模式带来很明显的缺点，即浏览器需要不断地向服务器发出请求，但是HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽资源。</p><p>​    此时，WebSocket协议的出现，能更好地节省服务器资源和带宽，并且能够更实时地进行通讯。WebSocket实现了浏览器与服务器全双工（full-duplex）通信，允许服务器主动发送信息给客户端。</p><h2 id="WS特点"><a href="#WS特点" class="headerlink" title="WS特点"></a>WS特点</h2><ul><li>建立在 TCP 协议之上，服务端实现容易；</li><li>与 HTTP 协议有良好的兼容性，握手时不容易被屏蔽，可以通过各种 HTTP 代理服务器；</li><li>数据轻量，实时通讯；</li><li>可以发送文本和二进制数据；</li><li>不限制同源，客户端可以与任意服务器端进行通讯。</li></ul><h2 id="和http-https的关系"><a href="#和http-https的关系" class="headerlink" title="和http/https的关系"></a>和http/https的关系</h2><p>按照标准来是有如下对应关系的：</p><ul><li>http -&gt; new WebSocket(‘ws://xxx’)</li><li>https -&gt; new WebSocket(‘wss://xxx’)</li></ul><p>在https下应该使用wss协议做安全链接，且wss下不支持ip地址的写法，写成域名形式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;了解WS和WSS&quot;&gt;&lt;a href=&quot;#了解WS和WSS&quot; class=&quot;headerlink&quot; title=&quot;了解WS和WSS&quot;&gt;&lt;/a&gt;了解WS和WSS&lt;/h2&gt;&lt;p&gt;&amp;emsp;WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双</summary>
      
    
    
    
    
    <category term="计网" scheme="http://xiaobazeo.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://xiaobazeo.github.io/2023/02/01/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://xiaobazeo.github.io/2023/02/01/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2023-02-01T11:03:12.000Z</published>
    <updated>2023-05-20T05:59:17.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础（一）"><a href="#Java基础（一）" class="headerlink" title="Java基础（一）"></a>Java基础（一）</h2><h3 id="Java语言的特点："><a href="#Java语言的特点：" class="headerlink" title="Java语言的特点："></a>Java语言的特点：</h3><ul><li>简单易学</li><li>面向对象（封装、继承、多态）</li><li>平台无关性（Java虚拟机实现平台无关性）</li><li>支持多线程</li><li>可靠性</li><li>安全性</li><li>支持网络编程并且很方便</li><li>编译与解释并存</li></ul><h3 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a>什么是字节码？采用字节码的好处是什么？</h3><p>JVM可以理解的代码就是字节码（扩展名.class文件），JVM解释器进行对字节码的解释比较慢、引入了JIT编译器，JIT属于运行时编译，当JIT编译完成第一次编译之后，热点代码和方法的字节码对应机器码会被保存下来，下次可以直接进行使用，而不需要再次被解释器进行解释。</p><p>好处：</p><ul><li>面向虚拟机，不面向任何特定的处理器</li><li>通过字节码的方式，在一定程度上解决了传统解释性语言执行效率低的问题，同时又保留了解释型语言可移植的特点</li><li>字节码不针对某一特定机器，所以Java不需要重新编译就可以在不同的操作系统的计算机运行。</li></ul><h3 id="Java源码一次编写，为啥能到处运行？"><a href="#Java源码一次编写，为啥能到处运行？" class="headerlink" title="Java源码一次编写，为啥能到处运行？"></a>Java源码一次编写，为啥能到处运行？</h3><p>&emsp;JVM（Java虚拟机）是关键原因。</p><p>&emsp;<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230204194523252.png" alt="image-20230204194523252"></p><blockquote><p>注意：Java程序是跨平台的程序、JVM是C/C++开发的软件，不同平台下的JVM版本不一样</p></blockquote><h3 id="为什么说Java语言“编译与解释并存”？"><a href="#为什么说Java语言“编译与解释并存”？" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h3><blockquote><p><strong>编译型：</strong>编译型语言可以通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较开，开发效率比较低，常见的编译型语言就是C、C++、GO等</p><p><strong>解释型：</strong>通过解释器将代码一句句解释成机器代码，解释型语言开发快，执行速度慢，常见的解释型语言就是PHP、Python、JavaScript等。</p></blockquote><p>&ensp;因为Java要先通过javac编译器将程序编译成字节码(.class文件)，然后通过Java解释器来解释执行。</p><h3 id="一个Java程序可包含多个类吗？（内部类除外）"><a href="#一个Java程序可包含多个类吗？（内部类除外）" class="headerlink" title="一个Java程序可包含多个类吗？（内部类除外）"></a>一个Java程序可包含多个类吗？（内部类除外）</h3><p>&emsp;可以包含多个类，但是被public修饰的类只有一个，且被public修饰的这个类必须跟类文件名同名</p><h3 id="Java的访问权限：private、protected、default、public"><a href="#Java的访问权限：private、protected、default、public" class="headerlink" title="Java的访问权限：private、protected、default、public"></a>Java的访问权限：private、protected、default、public</h3><p>&emsp;private &lt; default &lt; protected &lt; public：从左到右权限依次变大</p><p>&emsp;对成员变量/成员方法而言：</p><p>&emsp;&emsp;1、private：仅限该类内部成员访问</p><p>&emsp;&emsp;2、default：同包下的其他类成员以及该类内部成员可以访问</p><p>&emsp;&emsp;3、protected：同包下的其他类成员、该类内部成员、以及子类可以访问。</p><p>&emsp;&emsp;4、public：任意包下的任意类的成员均可访问。</p><p>&emsp;修饰类时，仅有default、public两种修饰符：</p><p>&emsp;&emsp;1、default：同包下的其他类可以访问</p><p>&emsp;&emsp;2、public：任意包下的任意类可以访问</p><blockquote><p>注：没有任何修饰符修饰，默认为default</p></blockquote><h3 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h3><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230204213714958.png" alt="image-20230204213714958"></p><p>byte(1 byte = 8 bits)&emsp;&emsp;&emsp;&emsp;&emsp;short(2 byte = 16 bits)&emsp;&emsp;&emsp;&emsp;&emsp;int(4 byte = 32 bits)&emsp;&emsp;&emsp;&emsp;&emsp;long(8 byte = 64 bits)</p><p>float(4 byte = 32 bits)&emsp;&emsp;&emsp;&emsp;double(8 byte = 64bits)&emsp;&emsp;&emsp;&emsp;&emsp;char(2byte = 16bits)&emsp;&emsp;&emsp;&emsp;&emsp;boolean(根据Java规范规定，不同JVM实现机制不同)</p><h3 id="Java语言关键字"><a href="#Java语言关键字" class="headerlink" title="Java语言关键字"></a>Java语言关键字</h3><table><thead><tr><th>分类</th><th>关键字</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td>类、方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p><ul><li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li><li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li><li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li></ul></blockquote><h3 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h3><p>这个需要结合 JVM 的相关知识，主要原因如下：</p><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol><h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><p><strong>1、调用方式</strong></p><p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p><p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staicMethod</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 调用实例方法</span></span><br><span class="line">        person.method();</span><br><span class="line">        <span class="comment">// 调用静态方法</span></span><br><span class="line">        Person.staicMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、访问类成员是否存在限制</strong></p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p><h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><ul><li>成员变量包装类型不赋值就<strong>是 <code>null</code></strong> ，而基本类型**有默认值且不是 <code>null</code>**。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的<strong>局部变量</strong>存放在 Java 虚拟机<strong>栈</strong>中的局部变量表中，基本数据类型的<strong>成员变量（未被 <code>static</code> 修饰 ）</strong>存放在 Java 虚拟机的<strong>堆</strong>中。包装类型属于对象类型，我们知道<strong>几乎所有对象实例都存在于堆中</strong>。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>⚠️ 注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果<strong>没有</strong>被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicTypeVar</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆区、栈区、方法区的区别："><a href="#堆区、栈区、方法区的区别：" class="headerlink" title="堆区、栈区、方法区的区别："></a>堆区、栈区、方法区的区别：</h3><p><strong>堆区:</strong> </p><p>1、存储的全部是对象 ，每个对象都包含一个与之对应的Class的信息。(Class的目的是得到操作指令) </p><p>2、JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 ，即实例对象</p><p><strong>栈区:</strong> </p><p>1、每个线程包含一个栈区 ，栈中 只保存基础数据类型的对象和自定义对象的引用(不是对象) ，对象都存放在堆区中 </p><p>2、每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问 。 </p><p>3、栈分为3个部分： 基本类型变量区、执行环境上下文、操作指令区(存放操作指令) 。 </p><p><strong>方法区:</strong> </p><p>1、又叫 静态区 ，跟堆一样， 被所有的线程共享 。方法区 包含所有的Class和static变量 。</p><p>2、方法区中包含的都是在整个程序中永远唯一的元素，如Class，static变量。</p><h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h3><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p><strong>Integer 缓存源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Character</code> 缓存源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Boolean</code> 缓存源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><p><strong>OS:所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p><h3 id="自动拆箱和自动装箱，原理是什么？"><a href="#自动拆箱和自动装箱，原理是什么？" class="headerlink" title="自动拆箱和自动装箱，原理是什么？"></a>自动拆箱和自动装箱，原理是什么？</h3><ul><li>拆箱：将包装类型转换成基本数据类型</li><li>装箱：将基本数据类型用对应的引用类型（包装类型）包装起来</li></ul><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure><p>装箱其实就是调用了包装类的<strong>valueOf()<strong>方法，</strong>拆箱</strong>其实就是调用了**xxxValue()**方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; =====&gt; <span class="type">Integer</span>  <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>)</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;  ======&gt;  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java基础（一）&quot;&gt;&lt;a href=&quot;#Java基础（一）&quot; class=&quot;headerlink&quot; title=&quot;Java基础（一）&quot;&gt;&lt;/a&gt;Java基础（一）&lt;/h2&gt;&lt;h3 id=&quot;Java语言的特点：&quot;&gt;&lt;a href=&quot;#Java语言的特点：&quot; cla</summary>
      
    
    
    
    
    <category term="八股文" scheme="http://xiaobazeo.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="Java基础" scheme="http://xiaobazeo.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot开发规范（一）</title>
    <link href="http://xiaobazeo.github.io/2022/11/21/springboot-levelFunction/"/>
    <id>http://xiaobazeo.github.io/2022/11/21/springboot-levelFunction/</id>
    <published>2022-11-21T11:52:29.000Z</published>
    <updated>2023-02-04T15:36:34.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="model（entity）"><a href="#model（entity）" class="headerlink" title="model（entity）"></a>model（entity）</h2><p>​        model是模型的意思，与entity、domain、pojo类似，是存放实体的类，类中定义了多个类属性，并与数据库表的字段保持一致，一张表对应一个model类。 主要用于定义与数据库对象应的属性，提供get/set方法,tostring方法,有参无参构造函数。</p><h2 id="dao（mapper）"><a href="#dao（mapper）" class="headerlink" title="dao（mapper）"></a>dao（mapper）</h2><p>​        又被成为mapper层，叫数据持久层，先设计接口，然后在配置文件中进行配置其实现的关联。 dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。 数据持久化操作就是指，把数据放到持久化的介质中，同时提供增删改查操作，比如数据通过hibernate插入到数据库中</p><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>​        业务逻辑层，完成功能的设计 和dao层一样都是先设计接口，再创建要实现的类，然后在配置文件中进行配置其实现的关联。接下来就可以在service层调用dao层的接口进行业务逻辑应用的处理。 service的impl是把mapper和service进行整合的文件 封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。</p><h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>​        控制层，控制业务逻辑service，控制请求和响应，负责前后端交互 controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/2052481-20210417164128180-1418412203.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;model（entity）&quot;&gt;&lt;a href=&quot;#model（entity）&quot; class=&quot;headerlink&quot; title=&quot;model（entity）&quot;&gt;&lt;/a&gt;model（entity）&lt;/h2&gt;&lt;p&gt;​        model是模型的意思，与enti</summary>
      
    
    
    
    
    <category term="SpringBoot开发规范" scheme="http://xiaobazeo.github.io/tags/SpringBoot%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之回文数</title>
    <link href="http://xiaobazeo.github.io/2022/10/27/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://xiaobazeo.github.io/2022/10/27/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E5%9B%9E%E6%96%87%E6%95%B0/</id>
    <published>2022-10-27T08:32:30.000Z</published>
    <updated>2023-07-23T08:21:28.942Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/palindrome-number/description/">9. 回文数</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>看到这题的第一想法就是把数字x进行反转得到数字reverse，然后与x进行比较是否相等即可，刚开始我想的是把数字转成字符串然后使用反转函数直接反转，最后使用eqauls方法进行比较即可，但是我忘记了怎么将数字转换成String类型的字符串。后来遍知道一个数一个数字进行翻转</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>由题可知x&lt;0的时候因为含有负号，故所有小于0的数都不是回文数，直接return false即可，x&gt;0的时候，我用一个temp表示x翻转后的数字，num用于x逐一翻转，直到num/10==0的时候说明翻转完成，得到的结果return num == x的结果即可。</p></blockquote><p>但是，看了题解之后我发现其实翻转一半就行了，就算是奇数个位数，最后return reverse/10 == x即可</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>O(logn)</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>O(1)</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> x;</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">                temp = temp*<span class="number">10</span>+num%<span class="number">10</span>;</span><br><span class="line">                num = num/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x == temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">revertedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/palindrome-number/solutions/281686/hui-wen-shu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/palindrome-number/description/&quot;&gt;9. 回文数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之两数之和</title>
    <link href="http://xiaobazeo.github.io/2022/10/26/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://xiaobazeo.github.io/2022/10/26/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2022-10-26T12:38:24.000Z</published>
    <updated>2023-07-23T08:21:35.483Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和</a></p></blockquote><p>[TOC]</p><h1 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h1><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20221026204201974.png" alt="两数之和"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>看到这一题我首先想到的就是通过类似于冒泡排序的思想，通过两个for循环对数组里面的值进行一一相加并跟target进行比较，如果值等于target那么就返回，否则就进行下一次循环，也就是所谓的暴力解法，不过这样真的非常损耗时间复杂度</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>这里面要注意的是，同一个数x不能进行重复相加，那么就需要我们进行一一枚举，即在数组nums中寻找中有没有一个数是target - x，且当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。如果找到了这个target - x则返回x和target - x的下标index即可</p></blockquote><p>代码</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p> $O(N2)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p> $O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/two-sum/description/&quot;&gt;1. 两数之和&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;题目如下</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>最近的成长</title>
    <link href="http://xiaobazeo.github.io/2022/07/10/%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%90%E9%95%BF/"/>
    <id>http://xiaobazeo.github.io/2022/07/10/%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%90%E9%95%BF/</id>
    <published>2022-07-10T08:10:22.000Z</published>
    <updated>2022-08-24T08:11:34.213Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;你好，我是小八，好久不见，不知不觉停更我的<a href="https://xiaobazeo.com/">blog</a>已经将近半年了，不知道的，可能是觉得大二下的我开始颓废了，我可以在这里说NO，你猜错了，我只是最近在闲暇之余花更多的时间在我前面<a href="https://xiaobazeo.com/2022/01/01/2021-backing/">一篇博客</a>提到的项目中——“微布校园”，我们团队开发了一款基于微信生态环境的微信小程序和APP——微布校园，目前也有很多我校大学生在使用我们的产品，而我负责的主要是小程序端开发和Java后端开发，算得上是个前后端啥都干的小菜鸡吧。</p><p>&emsp;&emsp;不知不觉，微布校园的诞生已经半年之久了，用户量也达到了我们的预期估计。在这段参与开发的过程中，通过向几个在大厂工作的学长请教，交流，我发现了很多开发过程中需要注意的小问题，而这些也丰富积累了我的开发经验。比如 刚开始学习使用mina框架开发小程序的我过于小白，其实有些icon只需要写一个class改变其样式即可，而我当时却给每个icon单独写了一个class样式，现在想起来都觉得自己真的好蠢啊，hhhhhhh~</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220710223856616.png" alt="小白受教ing"></p><p>&emsp;&emsp;还有这样的：当时还记得是因为我们开发的时候，提到了tcp协议，而我又看到过一篇博客说http3.0的TCP被弃用了，就开始了这个话题。。。当时还从计网知识转到了计组的相关探讨，hhhhhhh，而且我才知道一个安卓手机小知识，这里也分享给大家：安卓大多数手机用WiFi给电脑传数据，比用数据线快，因为很多手机接口用的USB2.0协议，虽然协议写的是60M，但一般2.0不超过30M</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220710223300695.png" alt="请教计网相关问题"></p><p>&emsp;&emsp;好在我们的不断努力下，微布校园APP和小程序都成功诞生啦~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;你好，我是小八，好久不见，不知不觉停更我的&lt;a href=&quot;https://xiaobazeo.com/&quot;&gt;blog&lt;/a&gt;已经将近半年了，不知道的，可能是觉得大二下的我开始颓废了，我可以在这里说NO，你猜错了，我只是最近在闲暇之余花更多的时间在我前</summary>
      
    
    
    
    
    <category term="程序人生" scheme="http://xiaobazeo.github.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    <category term="回忆" scheme="http://xiaobazeo.github.io/tags/%E5%9B%9E%E5%BF%86/"/>
    
  </entry>
  
  <entry>
    <title>URI</title>
    <link href="http://xiaobazeo.github.io/2022/02/04/URI/"/>
    <id>http://xiaobazeo.github.io/2022/02/04/URI/</id>
    <published>2022-02-04T07:10:36.000Z</published>
    <updated>2022-02-04T07:18:02.632Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时隔一周，我终于抽空又来分享一些知识了<del>承蒙关注，希望各位小伙伴点赞加关注</del></p></blockquote><p>你好，我是小八，一个分享学习知识和经验的在读大学生。</p><p>前几期我们已经讲了 tcp/ip 协议族、IP，TCP，DNS 的作用，我们再来讲讲我们经常上网都会使用到的 URI 和 URL 吧~</p><h2 id="URL-和-URI"><a href="#URL-和-URI" class="headerlink" title="URL 和 URI"></a>URL 和 URI</h2><p><strong>URL</strong>（Uniform Resource Locator）：统一资源定位符。也就是我们口中所称的网址。</p><p><strong>URI</strong>（Uniform Resource Identifier）：URI 用字符串表示某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。</p><p>也就是说 URL 是 URI 的子集。</p><blockquote><p>所以我们下面讲一讲 URI 的格式，也就能理解什么是 URL 了~</p></blockquote><h2 id="URI-格式"><a href="#URI-格式" class="headerlink" title="URI 格式"></a>URI 格式</h2><p>URI 需要涵盖全部必要信息的绝对 URI、绝对 URL 以及相对 URL，这时候大家肯定很疑惑，什么是<strong>相对</strong>，什么是<strong>绝对</strong>？其实很好理解。</p><p><strong>绝对 URL</strong>（比如说一个完整的通信地址，包含国家，省，市，小区门牌号，姓名。） 包含了指向目录或文件的完整信息，包括指向目录或文件的完整信息，包括模式、主机名和路径。</p><p>绝对 url 本身与被引用的文件实际位置无关，无论在哪个主机上的网页中，某一文件的绝对 URL 都是完全一样的。因此，当引用别人服务器上的文件时，应该总是使用绝对 URL。</p><p><strong>相对 URL</strong> 指出的位置是以信息提供者的位置为参照的。（假设 A 的位置标记为在 B 的向左十米，那么这个位置就是相对地址，相对于 B 的位置而言的）相对 URL 以包含 URL 本身的文件位置为参照点，描述目标文件的位置。因此，相对 URL 可以表达像“指向本页面同一目录的那个文件”的意思。</p><p>下面就是绝对 URI 的格式：</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220124170905495.png" alt="绝对URI格式"></p><p>当然上面的协议方案名也不止一种，还有 https、ftp、mailto、file 等 30 种左右</p><p>说了这么多，我再来解释一下上面的各个小模块的意思吧</p><h3 id="登录信息（认证）"><a href="#登录信息（认证）" class="headerlink" title="登录信息（认证）"></a>登录信息（认证）</h3><p>其实就是为了当你在访问服务器资源的时候，通过用户名账号和密码对你的身份信息进行认证。</p><h3 id="服务器地址"><a href="#服务器地址" class="headerlink" title="服务器地址"></a>服务器地址</h3><p>使用绝对 URI 必须指定待访问的服务器地址。</p><ul><li><p>可以是类似 <a href="https://pengzihao166.work/">pengzihao166.work</a> 这种 DNS 可解析的地址</p></li><li><p>也可以是 192.168.1.1 这类 IPv4 地址</p></li><li><p>再或者是类似[0:0:0:0:0:0:0:1]这种 IPv6 地址名</p></li></ul><h3 id="服务器端口号"><a href="#服务器端口号" class="headerlink" title="服务器端口号"></a>服务器端口号</h3><p>此项和登录信息一样是可选项，可以指定服务器连接的网络端口号，如果省略就会自动使用默认的端口号。</p><h3 id="带层次的文件路径"><a href="#带层次的文件路径" class="headerlink" title="带层次的文件路径"></a>带层次的文件路径</h3><p>就和电脑某个文件的<strong>路径</strong>类似，指定服务器上的文件路径来定位特指的资源。</p><h3 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h3><p>对已指定的文件路径内资源，可以使用查询字符串传入任意参数。</p><h3 id="片段标识符"><a href="#片段标识符" class="headerlink" title="片段标识符"></a>片段标识符</h3><p>使用片段标识符通常可<strong>标记</strong>出已获取资源中的子资源（文档内的某个位置）。</p><p><strong>注意</strong>：登录信息、查询字符号、服务器端口号、片段标识符都是可选项~</p><p>好了~今天的知识分享就到此结束了</p><hr><p>你好，我是小八，承蒙厚爱，能不能点赞加个关注呢~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;时隔一周，我终于抽空又来分享一些知识了&lt;del&gt;承蒙关注，希望各位小伙伴点赞加关注&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你好，我是小八，一个分享学习知识和经验的在读大学生。&lt;/p&gt;
&lt;p&gt;前几期我们已经讲了 tcp/ip 协议族、</summary>
      
    
    
    
    
    <category term="计网" scheme="http://xiaobazeo.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>TCP、IP、DNS</title>
    <link href="http://xiaobazeo.github.io/2022/01/16/TCP%E3%80%81IP%E3%80%81DNS/"/>
    <id>http://xiaobazeo.github.io/2022/01/16/TCP%E3%80%81IP%E3%80%81DNS/</id>
    <published>2022-01-16T15:08:08.000Z</published>
    <updated>2022-01-16T15:09:57.141Z</updated>
    
    <content type="html"><![CDATA[<p>你好，我是小八，最近在备考，考试总算是结束了，终于可以放假，学习更多的技术了<del>干自己想干的事情了</del></p><p>下面分享一些 IP、TCP、DNS 的基础知识点，大家可以看看，绝对通俗易懂！！！</p><h1 id="与-HTTP-关系密切的协议：IP、TCP-和-DNS"><a href="#与-HTTP-关系密切的协议：IP、TCP-和-DNS" class="headerlink" title="与 HTTP 关系密切的协议：IP、TCP 和 DNS"></a>与 HTTP 关系密切的协议：IP、TCP 和 DNS</h1><h4 id="负责传输的-IP-协议："><a href="#负责传输的-IP-协议：" class="headerlink" title="负责传输的 IP 协议："></a>负责传输的 IP 协议：</h4><p>&emsp;&emsp;按层次分，IP（Internet Protocol）网际协议属于网络层。<strong>IP 地址</strong>和<strong>IP</strong>不同，“IP”其实就是一种协议的名称，即：网际协议。</p><p>&emsp;&emsp;IP 协议作用：把各种<strong>数据包</strong>传送给对方，但是必须满足<strong>IP 地址</strong>和<strong>MAC 地址</strong>（Media Access Control Address）两个条件才能确实送到对方那里。</p><p>&emsp;&emsp;<strong>IP 地址</strong>：节点被分配到的地址，</p><p>&emsp;&emsp;<strong>MAC 地址</strong>：网卡所属的固定地址。</p><p>&emsp;&emsp;<strong>注意：</strong> IP 地址可以变换，MAC 地址基本不变。</p><p>&emsp;&emsp;IP 通信依赖 MAC 地址, 因为不同计算机之间通信时，通常是不在一个局域网(LAN)下，此时就需要多个中间计算机和设备（路由器等均可作为中转设备）进行中转，最后连接到你所需要连接的计算机，在中转的过程中，会利用到下一个中转设备的 MAC 地址来寻找到下一个中转目标。这下就要用到了<strong>ARP 协议</strong>(Address Resolution Protocol).</p><p>&emsp;&emsp;<strong>ARP 协议：</strong> 一种解析地址的协议，根据对方的 IP 地址可以反查出对应的 MAC 地址。</p><p>&emsp;&emsp;如果还是不懂的话，就拿快递公司的收发货方式来打一个比方吧，我们要是双十一买了东西（“东西”就是我们在网络上要传递给某个设备的信息），卖家需要把东西寄给我们（”我们“就是接收信息的设备），那么他们就会把自己的货物送到某快递的集散中心，然后集散中心通过核对收件人地址，来确定送到下一个集散中心（这里的“集散中心”就是类似于一个中转设备），最后到达离收件地址最近的集散中心之后，再送到我们手上（这时候就实现了发起设备和接收设备的信息传递）。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/IP%E3%80%81TCP%E5%92%8CDNS/ARP%E5%8D%8F%E8%AE%AE.png?versionId=CAEQGRiBgID_98q58hciIGU2NDAxY2JlNmQ5MzQ2YjViYzQyZTgyZTQ3NmI0ZDY1" alt="img"></p><h4 id="确保可靠性的-TCP-协议"><a href="#确保可靠性的-TCP-协议" class="headerlink" title="确保可靠性的 TCP 协议"></a>确保可靠性的 TCP 协议</h4><p>&emsp;&emsp;TCP 和 UDP 都位于传输层，这个前面说过，其中 TCP 是用来提供可靠的字节流服务。</p><p>&emsp;&emsp;其中 TCP 协议能够准确确定数据是否送达目标处，这样的实现的过程就是通过三次握手（three-way handshaking）策略，其中握手过程中使用了 TCP 的标志（flag）——ACK 和 SYN，原理如下：</p><p>&emsp;&emsp;第一次由发起端首先发送一个 SYN 标志的数据包给接收端，第二次握手就是在接收端接收这个标志之后，接收端再反馈一个 SYN 和 ACK 的数据包给发起端，来表达自己已经接收到了发起端的请求，最后一次握手就是在收到接收端的确认信息之后，发起端回传一个 ACK 的数据包给接收端，代表“握手”结束。</p><p>&emsp;&emsp;如果其中有某一次握手中断，那就会延续上一次握手进行重复的请求，但要是请求超时之后就会重新开始由发送端进行第一次握手。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/IP%E3%80%81TCP%E5%92%8CDNS/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png?versionId=CAEQGRiBgMDa98q58hciIGZjNTZlZWU4OWI1MzRjYjdhMDIyMzEzYWYyNWNiMGE2" alt="image-20211230200934379"></p><h4 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h4><p>就是当你在访问某个网站的时候，会有一个网址(比如：<code>www.baidu.com</code>也就是此网站的域名)，而在访问某个计算机的时候也可以通过赋予此计算机一个域名，最后通过 DNS 解析域名来获取其 IP 地址，最后访问到此计算机。</p><p>DNS 的作用便是通过域名查找对应的设备的 IP 地址，或者逆向从 IP 地址查域名的服务。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/IP%E3%80%81TCP%E5%92%8CDNS/DNS.png?versionId=CAEQGRiBgMDIlN658hciIGI1YTcxNDhjZjNlMjQxNTdiMTA1OTVkYjJjZjE5ODg5" alt="image-20211230202446976"></p><hr><p>你好，我是小八，一个分享学习经历和知识的在读大学生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你好，我是小八，最近在备考，考试总算是结束了，终于可以放假，学习更多的技术了&lt;del&gt;干自己想干的事情了&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;下面分享一些 IP、TCP、DNS 的基础知识点，大家可以看看，绝对通俗易懂！！！&lt;/p&gt;
&lt;h1 id=&quot;与-HTTP-关系密切的协议：IP</summary>
      
    
    
    
    
    <category term="计网" scheme="http://xiaobazeo.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
</feed>
