<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HUT菜鸟小八的博客</title>
  
  
  <link href="http://xiaobazeo.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaobazeo.github.io/"/>
  <updated>2023-08-03T02:42:02.112Z</updated>
  <id>http://xiaobazeo.github.io/</id>
  
  <author>
    <name>xiaoba</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微布开发-二手市场开发思路(小程序+Java后端 尚未完更)</title>
    <link href="http://xiaobazeo.github.io/2023/08/03/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/"/>
    <id>http://xiaobazeo.github.io/2023/08/03/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E4%BA%8C%E6%89%8B%E5%B8%82%E5%9C%BA%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/</id>
    <published>2023-08-03T02:39:05.000Z</published>
    <updated>2023-08-03T02:42:02.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小程序端"><a href="#小程序端" class="headerlink" title="小程序端"></a>小程序端</h3><p>categoryBid：二级分类类别的主键id</p><p>allList：全部商品列表</p><p>sellList：转卖商品列表</p><p>askBuyList：求购商品列表</p><p>type：一级分类</p><h4 id="开发思路如下："><a href="#开发思路如下：" class="headerlink" title="开发思路如下："></a>开发思路如下：</h4><ol><li>默认获取全部所有的商品list用于初始化加载页面</li><li>滑动一级分类，确认一级分类type类型<ol><li>Type = 转卖<ol><li>初始化<ol><li>默认转卖一级分类的所有商品列表</li><li>滑动到二级分类，根据二级分类类型对应的categoryBid拉取列表</li></ol></li><li>下拉刷新<ol><li>若为一级分类的所有商品列表，categoryBid = null</li><li>若具体到二级分类的具体类型，categoryBid = 对应的二级分类bid</li></ol></li><li>上滑加载<ol><li>根据一级分类和二级分类(categoryBid )的类别确定获取什么类型的list并且赋值到allList/sellList/askBuyList</li></ol></li></ol></li><li>Type = 求购<ol><li>初始化<ol><li>默认求购一级分类的所有商品列表</li><li>滑动到二级分类，根据二级分类类型对应的categoryBid拉取列表</li></ol></li><li>下拉刷新<ol><li>若为一级分类的所有商品列表，categoryBid = null</li><li>若具体到二级分类的具体类型，categoryBid = 对应的二级分类bid</li></ol></li><li>上滑加载<ol><li>根据一级分类和二级分类的类别确定获取什么类型的list并且赋值到allList/sellList/askBuyList</li></ol></li></ol></li></ol></li></ol><h4 id="Java后端："><a href="#Java后端：" class="headerlink" title="Java后端："></a>Java后端：</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;小程序端&quot;&gt;&lt;a href=&quot;#小程序端&quot; class=&quot;headerlink&quot; title=&quot;小程序端&quot;&gt;&lt;/a&gt;小程序端&lt;/h3&gt;&lt;p&gt;categoryBid：二级分类类别的主键id&lt;/p&gt;
&lt;p&gt;allList：全部商品列表&lt;/p&gt;
&lt;p&gt;sellList：</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>面经-七牛云测试开发实习一二面</title>
    <link href="http://xiaobazeo.github.io/2023/08/02/%E9%9D%A2%E7%BB%8F-%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%BA%8C%E9%9D%A2/"/>
    <id>http://xiaobazeo.github.io/2023/08/02/%E9%9D%A2%E7%BB%8F-%E4%B8%83%E7%89%9B%E4%BA%91%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%BA%8C%E9%9D%A2/</id>
    <published>2023-08-02T03:37:32.000Z</published>
    <updated>2023-08-02T03:48:32.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><h3 id="微布校园的分工如何？"><a href="#微布校园的分工如何？" class="headerlink" title="微布校园的分工如何？"></a>微布校园的分工如何？</h3><h3 id="在开发过程中学到了什么？遇到了什么难的问题？"><a href="#在开发过程中学到了什么？遇到了什么难的问题？" class="headerlink" title="在开发过程中学到了什么？遇到了什么难的问题？"></a>在开发过程中学到了什么？遇到了什么难的问题？</h3><h3 id="如何解决缓存雪崩、缓存与数据库一致性问题？"><a href="#如何解决缓存雪崩、缓存与数据库一致性问题？" class="headerlink" title="如何解决缓存雪崩、缓存与数据库一致性问题？"></a>如何解决缓存雪崩、缓存与数据库一致性问题？</h3><h3 id="查询响应速度从超时响应加快到900ms-1s是如何实现的？"><a href="#查询响应速度从超时响应加快到900ms-1s是如何实现的？" class="headerlink" title="查询响应速度从超时响应加快到900ms~1s是如何实现的？"></a>查询响应速度从超时响应加快到900ms~1s是如何实现的？</h3><h3 id="讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）"><a href="#讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）" class="headerlink" title="讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）"></a>讲一下雪花算法（当时从组成，为什么可以作为分布式id角度回答）</h3><h3 id="使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。"><a href="#使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。" class="headerlink" title="使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。"></a>使用kafka实现UGC消息异步推送，起到削峰、解耦的作用，讲一下对削峰、解耦的理解。</h3><h3 id="Redis在哪一部分用的比较多？"><a href="#Redis在哪一部分用的比较多？" class="headerlink" title="Redis在哪一部分用的比较多？"></a>Redis在哪一部分用的比较多？</h3><h3 id="讲一下http的三次握手、四次挥手？"><a href="#讲一下http的三次握手、四次挥手？" class="headerlink" title="讲一下http的三次握手、四次挥手？"></a>讲一下http的三次握手、四次挥手？</h3><h3 id="为什么要进行四次挥手？"><a href="#为什么要进行四次挥手？" class="headerlink" title="为什么要进行四次挥手？"></a>为什么要进行四次挥手？</h3><h3 id="介绍一下udp和tcp之间的区别"><a href="#介绍一下udp和tcp之间的区别" class="headerlink" title="介绍一下udp和tcp之间的区别"></a>介绍一下udp和tcp之间的区别</h3><h3 id="什么时候用UDP？什么时候用TCP？"><a href="#什么时候用UDP？什么时候用TCP？" class="headerlink" title="什么时候用UDP？什么时候用TCP？"></a>什么时候用UDP？什么时候用TCP？</h3><h3 id="介绍一下对HTTP的理解"><a href="#介绍一下对HTTP的理解" class="headerlink" title="介绍一下对HTTP的理解"></a>介绍一下对HTTP的理解</h3><h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3><h3 id="介绍一下token"><a href="#介绍一下token" class="headerlink" title="介绍一下token"></a>介绍一下token</h3><h3 id="讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？"><a href="#讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？" class="headerlink" title="讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？"></a>讲一下MySQL的索引，什么时候用到了索引，以及什么时候遇到过索引失效的？</h3><h3 id="介绍一下Redis的数据类型和持久化"><a href="#介绍一下Redis的数据类型和持久化" class="headerlink" title="介绍一下Redis的数据类型和持久化"></a>介绍一下Redis的数据类型和持久化</h3><h3 id="如何通过Redis实现分布式锁？"><a href="#如何通过Redis实现分布式锁？" class="headerlink" title="如何通过Redis实现分布式锁？"></a>如何通过Redis实现分布式锁？</h3><h3 id="Redis的淘汰策略有哪些？"><a href="#Redis的淘汰策略有哪些？" class="headerlink" title="Redis的淘汰策略有哪些？"></a>Redis的淘汰策略有哪些？</h3><h3 id="介绍一下对多线程的理解"><a href="#介绍一下对多线程的理解" class="headerlink" title="介绍一下对多线程的理解"></a>介绍一下对多线程的理解</h3><h3 id="什么是线程池、为什么要使用线程池？"><a href="#什么是线程池、为什么要使用线程池？" class="headerlink" title="什么是线程池、为什么要使用线程池？"></a>什么是线程池、为什么要使用线程池？</h3><h3 id="Java的异常有哪些？如何捕获异常？"><a href="#Java的异常有哪些？如何捕获异常？" class="headerlink" title="Java的异常有哪些？如何捕获异常？"></a>Java的异常有哪些？如何捕获异常？</h3><h3 id="对文件的上传、下载分别有哪些测试功能点？"><a href="#对文件的上传、下载分别有哪些测试功能点？" class="headerlink" title="对文件的上传、下载分别有哪些测试功能点？"></a>对文件的上传、下载分别有哪些测试功能点？</h3><h3 id="算法题：把两个无序的数组合并成一个有序的数组"><a href="#算法题：把两个无序的数组合并成一个有序的数组" class="headerlink" title="算法题：把两个无序的数组合并成一个有序的数组"></a>算法题：把两个无序的数组合并成一个有序的数组</h3><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><h3 id="为什么要选择面试测试开发这个岗位？"><a href="#为什么要选择面试测试开发这个岗位？" class="headerlink" title="为什么要选择面试测试开发这个岗位？"></a>为什么要选择面试测试开发这个岗位？</h3><h3 id="你觉得测开需要学习些什么方面的东西？"><a href="#你觉得测开需要学习些什么方面的东西？" class="headerlink" title="你觉得测开需要学习些什么方面的东西？"></a>你觉得测开需要学习些什么方面的东西？</h3><h3 id="netty和直接裸写socket有什么区别？"><a href="#netty和直接裸写socket有什么区别？" class="headerlink" title="netty和直接裸写socket有什么区别？"></a>netty和直接裸写socket有什么区别？</h3><h3 id="什么是NIO？"><a href="#什么是NIO？" class="headerlink" title="什么是NIO？"></a>什么是NIO？</h3><h3 id="为什么IO多路复用比多线程更高效？"><a href="#为什么IO多路复用比多线程更高效？" class="headerlink" title="为什么IO多路复用比多线程更高效？"></a>为什么IO多路复用比多线程更高效？</h3><h3 id="Redis是单线程还是多线程的？为什么是单线程还能这么高效？"><a href="#Redis是单线程还是多线程的？为什么是单线程还能这么高效？" class="headerlink" title="Redis是单线程还是多线程的？为什么是单线程还能这么高效？"></a>Redis是单线程还是多线程的？为什么是单线程还能这么高效？</h3><h3 id="在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？"><a href="#在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？" class="headerlink" title="在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？"></a>在多路复用的场景下，做一个哈希计算可行吗？会不会有什么问题？</h3><h3 id="使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）"><a href="#使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）" class="headerlink" title="使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）"></a>使用netty实现IM实时通讯为什么不只使用websocket协议，而还要加上rpc协议呢？（应该是json-rpc协议。。。当时简历写错了）</h3><h3 id="netty的广播怎么实现的？"><a href="#netty的广播怎么实现的？" class="headerlink" title="netty的广播怎么实现的？"></a>netty的广播怎么实现的？</h3><h3 id="如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？"><a href="#如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？" class="headerlink" title="如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？"></a>如果在通信过程中，客户端突然断开或者服务端进行升级，应该怎么解决这两个问题？</h3><h3 id="如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？"><a href="#如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？" class="headerlink" title="如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？"></a>如果出现了断开重连的情况，用户重新登录会继续看到以前的消息吗？怎么实现的消息持久化？</h3><h3 id="介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？"><a href="#介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？" class="headerlink" title="介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？"></a>介绍一下jwt和session的区别？（说一些token的优势）介绍一下CSRF攻击的应用场景，如何避免CSRF的攻击？</h3><h3 id="说几个Maven的常用命令"><a href="#说几个Maven的常用命令" class="headerlink" title="说几个Maven的常用命令"></a>说几个Maven的常用命令</h3><h3 id="常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）"><a href="#常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）" class="headerlink" title="常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）"></a>常用的map有哪些？TreeMap和HashMap的区别（实现的接口，时间复杂度，应用场景）</h3><h3 id="怎么实现多线程之间的同步操作？-主线程开启10个任务，-等这10个任务并发结束之后，再执行其他的任务应该怎么实现？"><a href="#怎么实现多线程之间的同步操作？-主线程开启10个任务，-等这10个任务并发结束之后，再执行其他的任务应该怎么实现？" class="headerlink" title="怎么实现多线程之间的同步操作？ 主线程开启10个任务， 等这10个任务并发结束之后，再执行其他的任务应该怎么实现？"></a>怎么实现多线程之间的同步操作？ 主线程开启10个任务， 等这10个任务并发结束之后，再执行其他的任务应该怎么实现？</h3><h3 id="Java的新特性（介绍的Java8的新特性）"><a href="#Java的新特性（介绍的Java8的新特性）" class="headerlink" title="Java的新特性（介绍的Java8的新特性）"></a>Java的新特性（介绍的Java8的新特性）</h3><h3 id="编码：实现a，b两个线程顺序交替执行"><a href="#编码：实现a，b两个线程顺序交替执行" class="headerlink" title="编码：实现a，b两个线程顺序交替执行"></a>编码：实现a，b两个线程顺序交替执行</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h2&gt;&lt;h3 id=&quot;微布校园的分工如何？&quot;&gt;&lt;a href=&quot;#微布校园的分工如何？&quot; class=&quot;headerlink&quot; title=&quot;微布校园的</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面经-万物心选php开发实习</title>
    <link href="http://xiaobazeo.github.io/2023/07/25/%E9%9D%A2%E7%BB%8F-%E4%B8%87%E7%89%A9%E5%BF%83%E9%80%89php%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/"/>
    <id>http://xiaobazeo.github.io/2023/07/25/%E9%9D%A2%E7%BB%8F-%E4%B8%87%E7%89%A9%E5%BF%83%E9%80%89php%E5%BC%80%E5%8F%91%E5%AE%9E%E4%B9%A0/</id>
    <published>2023-07-25T08:13:52.000Z</published>
    <updated>2023-07-31T05:33:35.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实习项目的监听字段是基于什么实现的？"><a href="#实习项目的监听字段是基于什么实现的？" class="headerlink" title="实习项目的监听字段是基于什么实现的？"></a>实习项目的监听字段是基于什么实现的？</h2><p>前端进行某个字段变更之后，后端提供接口，将修改后的数据打入消息队列，服务端作为消费者进行监听判断某个字段是否等于某个值然后进行对应的业务逻辑操作。</p><h2 id="通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）"><a href="#通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）" class="headerlink" title="通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）"></a>通过redis作为缓存层，实现分布式锁，保证消息不会被多次消费怎么实现的？（具体的数据流程）</h2><p>通过业务id来保证，业务id作为锁的key，当消费信息的时候，把工单id作为key去申请锁，如果成功拿到了锁，说明此时不存在竞争关系，如果当前进程被阻塞了，说明有进程对该数据进行了消费。</p><p>不过后面发现如果有两个并发的线程的时候，被阻塞的业务后面拿到了还是可能会造成重复消费，于是又加了一层缓存，缓存已经消费了的业务id，用来表示是否被消费过，也就是保证业务的幂等性。</p><h2 id="当时为什么考虑到设置一个重试机制降低消费的失败率？"><a href="#当时为什么考虑到设置一个重试机制降低消费的失败率？" class="headerlink" title="当时为什么考虑到设置一个重试机制降低消费的失败率？"></a>当时为什么考虑到设置一个重试机制降低消费的失败率？</h2><p>当初实现合同是临时合同的时候，要删除销售合同的主从表，因为当时是两个表，涉及到了一个同步操作，即先删除主表之后再删除从表的操作，要保证事务的一致性和原子性，可能两个删除操作会有一个或者两个操作均失败的情况，就设计了这个重试机制，如果其中一个操作失败就进行事务回滚，然后将两个同步操作打入重试的队列中进行一次重试。</p><h2 id="有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）"><a href="#有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）" class="headerlink" title="有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）"></a>有没有其他的措施避免消费失败和重复消费？（除开分布式锁的方式）</h2><p><strong>避免消费失败的措施：</strong></p><ol><li>失败重试机制</li><li>死信队列</li><li>消息超时机制：避免因为一个消息阻塞导致后续的所有消息超时</li><li>负载均衡：如果是集群分布式服务，可以通过负载均衡算法分配给多个消费者。</li><li>消息确认机制：当消费者消费成功之后，发送确认信号给消息队列，表示消息处理成功，如果消费者在一定时间内没有返回确认信号，消息队列就重新分发消息给其他的消费者进行消费。</li></ol><p><strong>避免重复消费的措施：</strong></p><ol><li>实现幂等性：即相同的多个操作所产生的影响与仅执行一次的操作所产生的影响相同。确保相同的消息被多次发送之后，只会被处理一次。</li><li>消息确认机制：消息队列消费者消费之后会给生产者发送一个确认信号告诉已经消费信息成功，如果在一定时间内没有发送确认消息，消息队列就会认为此消息未被成功消费，会将该消息重新发送给消费者。</li><li>消费者限流：在高并发的场景中，为了消费者过度消费，就会在一定时间内只允许消费者消费一定数量的消息，以避免被过度消费而导致的重复消费。</li></ol><h2 id="如何解决数据库offset超过10000时失效的问题？"><a href="#如何解决数据库offset超过10000时失效的问题？" class="headerlink" title="如何解决数据库offset超过10000时失效的问题？"></a>如何解决数据库offset超过10000时失效的问题？</h2><p>通过分页查询的方式，偏移量超过一万的情况下，我们可以通过limit的分页查询机制，一直查到第10001条数据的主键id，然后从此id开始进一步根据条件查询需要获取的数据。</p><h2 id="为什么offset超过10000会查询不到数据呢？"><a href="#为什么offset超过10000会查询不到数据呢？" class="headerlink" title="为什么offset超过10000会查询不到数据呢？"></a>为什么offset超过10000会查询不到数据呢？</h2><p>OFFSET工作原理是通过全表扫描，先查询所有匹配的记录，然后再跳过指定数量的记录，如果偏移量特别大，数据库可能会需要一次性加载大量数据到内存中，会导致内存不足的问题。</p><h2 id="实习时候的成长经历"><a href="#实习时候的成长经历" class="headerlink" title="实习时候的成长经历"></a>实习时候的成长经历</h2><p>1、有一次出现过一次消息队列重复消费的情况，当时情况是两个不同的测试环境，做相同业务消费时消费了两次，然后查代码一直也没有查到原因，就去看配置环境，原来是当时运维那边部署消息队列，两个环境都部署到了一个队列上面，没有做环境隔离。。。</p><p>2、在</p><h2 id="JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？"><a href="#JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？" class="headerlink" title="JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？"></a>JWT代替Cookie-Session机制的业务流程，以及如何管理用户状态？token的存在什么位置？服务端是如何校验token是否有效的？</h2><p><strong>业务及校验流程：</strong></p><p>用户通过学号+教务密码向Java后端发起请求，然后Java后端调用Python的服务进行校验账号密码是否正确，如果正确就会向前端返回一个token，客户端将Token保存在本地缓存之中，方便以后在一些业务操作的时候，都会从本地缓存中获取Token并将其放在Http请求的Header中发送请求，服务端获取到请求之后从Http的header里面获取token，并通过服务端保存的密匙进行重新生成新的signature和客户端发过来的token的signature进行比较确认token是否有效，再从payload部分获取相关用户信息进行进一步身份校验。</p><p>每次服务端在校验token有效的时候会根据payload的签发token时间+超时时间，当离过期时间只有1天的时候，就会重新签发一个Token给前端。</p><p><strong>Token存放位置：</strong></p><p>HTTP的Header部分。</p><h2 id="Java为什么需要垃圾回收机制呢？"><a href="#Java为什么需要垃圾回收机制呢？" class="headerlink" title="Java为什么需要垃圾回收机制呢？"></a>Java为什么需要垃圾回收机制呢？</h2><p>主要是为了管理内存，自动释放不再使用的对象，以避免内存泄漏和提高程序性能。</p><h2 id="什么情况下会出现资源的浪费（内存泄漏）？"><a href="#什么情况下会出现资源的浪费（内存泄漏）？" class="headerlink" title="什么情况下会出现资源的浪费（内存泄漏）？"></a>什么情况下会出现资源的浪费（内存泄漏）？</h2><p>1、长期存活的对象占用过多内存，就是长生命周期对象持有短生命周期的引用导致部分短生命周期的对象一直没有被释放，进而积累过多的情况下出现内存泄漏的问题。</p><p>2、各种连接：比如数据库连接、网络连接，对于这些连接操作都需要在不使用的时候进行关闭操作，垃圾回收期才会进行回收。</p><p>3、变量作用域不合理：比如要对一个msg进行保存操作，但是msg定义成一个成员变量，然后通过receiveMsg()方法进行相关保存业务逻辑操作，但是因为msg是成员变量，生命周期和类的生命周期一样，所以导致存储操作完成之后，msg还没有被回收释放，可能就会导致内存泄漏。</p><h2 id="创建了一个String类型的数据什么时候会被垃圾回收机制回收？"><a href="#创建了一个String类型的数据什么时候会被垃圾回收机制回收？" class="headerlink" title="创建了一个String类型的数据什么时候会被垃圾回收机制回收？"></a>创建了一个String类型的数据什么时候会被垃圾回收机制回收？</h2><p>1、对象不再引用。</p><p>2、对象引用被显式设置为null。</p><p>3、对象的引用超出作用域：在一个方法内部创建的，那么在这个方法执行完之后就会被收回。</p><p>3、垃圾回收机制触发：Java虚拟机判断系统内存不足就会触发此机制，尝试回收不再被使用的对象。</p><h2 id="了解哪些垃圾回收算法并介绍一下"><a href="#了解哪些垃圾回收算法并介绍一下" class="headerlink" title="了解哪些垃圾回收算法并介绍一下"></a>了解哪些垃圾回收算法并介绍一下</h2><p><strong>标记-清除算法：</strong></p><p>首先标记处所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p><p>导致的问题：</p><p>1、标记清除的过程效率都不高</p><p>2、标记清除后会产生大量不连续的内存碎片。</p><p><strong>复制算法：</strong></p><p>将内存空间分为两半，每次使用其中的一块，当这块使用完之后，将这块还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</p><p>导致的问题：</p><p>1、可用内存变小。</p><p>2、不适合老年代，如果存活对象数量大，复制性能会比较差。</p><p><strong>标记-整理算法：</strong></p><p>标记不需要回收的对象，然后将没有标记的对象统一向一端移动，然后直接清理掉端边界以外的内存。</p><p>导致问题：</p><p>只适合老年代回收频率较低的场景</p><p><strong>分代收集算法：</strong></p><p>根据不同对象的生命周期将内存分为几块。一般将Java堆分为新生代和老年代，可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如：新生代中，每次都会有大量对象死去，可以选择<strong>复制算法</strong>，只需要付出少量对象的复制成本就可以完成垃圾收集。而对于老年代生命周期较长，存活率较高，可以选择<strong>标记-清除算法</strong>或者<strong>标记-整理算法</strong>实现。</p><h2 id="垃圾回收机制为什么要分新生代和老年代呢？"><a href="#垃圾回收机制为什么要分新生代和老年代呢？" class="headerlink" title="垃圾回收机制为什么要分新生代和老年代呢？"></a>垃圾回收机制为什么要分新生代和老年代呢？</h2><p>根据不同对象的生命周期将内存分为几块。一般将Java堆分为新生代和老年代，可以根据各个年代的特点选择合适的垃圾收集算法。</p><h2 id="为什么新生代和老年代不放在一起进行回收呢？"><a href="#为什么新生代和老年代不放在一起进行回收呢？" class="headerlink" title="为什么新生代和老年代不放在一起进行回收呢？"></a>为什么新生代和老年代不放在一起进行回收呢？</h2><p>1、不同对象生命周期：可以根据不同的生命周期对象采用不同的回收策略</p><p>2、不同回收算法：一般新生代会采用复制算法清除，因为可以标记较少的对象复制到另一块内存上面去，然后一次性清理整个区域，效率较高，对于老年代生命周期长且存活率高，就可以采用标记-整理或者标记-删除的办法，将不需要回收的对象进行标记，然后直接删除没有标记的即可。</p><p>3、避免频繁回收老年代：混在一起会导致老年代频繁的回收，降低系统的性能。</p><h2 id="数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？"><a href="#数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？" class="headerlink" title="数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？"></a>数组和链表的优缺点（Array和ArrayList），谁的访问效率会更高？</h2><ul><li>数组访问效率比链表高，因为链表通常是动态扩容的，每次的动态调整都会带来一定的开销以及维护指针等，所以访问效率较低。</li><li>链表能灵活进行动态扩容或缩容，但是数组一旦确定大小就不能进行扩容和缩容操作了。</li><li>链表有丰富的api可以直接动态进行增删查改，而数组是一个固定长度的数组，只能按下标访问其中的元素，不具备动态增删的能力。</li><li>链表只能存储对象（对于基本数据类型可以采用包装类进行存储），但是数组既可以存储对象也可以存储基本数据类型。</li><li>链表可以通过泛型保证类型安全，但是数组不可以。</li></ul><h2 id="有没有一个数据结构可以访问元素时间是O-1-，又可以灵活的调整他的容量大小？"><a href="#有没有一个数据结构可以访问元素时间是O-1-，又可以灵活的调整他的容量大小？" class="headerlink" title="有没有一个数据结构可以访问元素时间是O(1)，又可以灵活的调整他的容量大小？"></a>有没有一个数据结构可以访问元素时间是O(1)，又可以灵活的调整他的容量大小？</h2><p>哈希表可以将key映射到存储位置来实现快速访问，使用哈希函数将键转换成索引，然后将值存在对应索引的位置，在理想情况下，能够在O（1）情况下根据键找到对应的值。哈希表具有灵活的扩容机制，当哈希表中元素过多的时候就会自动扩容，重新分配更大的空间。</p><h2 id="HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）"><a href="#HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）" class="headerlink" title="HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）"></a>HashMap是如何解决哈希冲突的呢？为什么要选择红黑树来作为解决哈希冲突的数据结构？（即：选择红黑树的优势是什么？）</h2><p>hashmap是基于数组+链表/红黑树的数据结构来具体实现的，首先hashmap产生哈希冲突的时候会判断链表的长度是否大于8，如果大于的话就会转换成红黑树（此时进入红黑树转换的函数的时候，会判断数组的长度是否大于64，如果数组长度小于64，就不会转换成红黑树，而是选择扩容的机制解决哈希冲突）</p><p>选择红黑树的原因：</p><p>1、如果是<strong>二叉查询树</strong>比较极端的情况下，当子节点都比父节点大或者小的时候，二叉查找树又会退化成链表，此时时间复杂度又是O(n)。</p><p>2、如果是<strong>平衡二叉树（AVL）</strong>，因为它每个节点的左子树和右子树的高度差至多等于1，如果大于1了就会通过左旋或者右旋的方式，使其复杂度一直维持在O(logN)，但是因为这个左旋和右旋的原因，导致插入数据的时候需要消耗大量的时间。</p><h2 id="场景题：现在有路由器a-b-c-d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？"><a href="#场景题：现在有路由器a-b-c-d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？" class="headerlink" title="场景题：现在有路由器a,b,c,d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？"></a>场景题：现在有路由器a,b,c,d，有一个数据包按照正常情况下应该是从a转发到b，从b转发到c，从c转发到d，但是由于路由器c配置出错了，导致从a转发到b，再从b转发到c，最后又从c转发回了a，形成了一个循环路由，这时候这个数据包在IP层会被怎么处理掉呢？</h2><p>在IP层遇到循环路由的情况下，数据包会被丢弃。IP协议是一种无连接的、不可靠的协议，它不会主动检查循环路由或处理数据包的循环传递。</p><p>为了防止数据包在网络中无限循环，网络管理员通常会配置路由器使用一些防循环机制，比如距离矢量路由协议中的Split Horizon技术，或链路状态路由协议中的Reverse Path Forwarding（RPF）检查。这些机制有助于检测和避免数据包在网络中形成循环路径。</p><p>但是，即使配置了防循环机制，由于网络的复杂性和问题可能的多样性，有时候循环路由问题仍然可能发生。在这种情况下，IP层不会继续无限传递数据包，而是丢弃它，从而避免对网络产生更严重的影响。丢弃数据包是为了确保网络中的数据传输是可靠和有效的，即使牺牲了某些数据包。</p><h2 id="Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？"><a href="#Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？" class="headerlink" title="Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？"></a>Linux看文件大小怎么做？stat命令显示的文件大小是以块为单位，怎么转换成人类可识别的大小？</h2><p>stat的基本单位是块，也就是byte。转换成可识别的大小的话，通过1 kb = 1024byte实现。</p><p>可以通过ls -lh</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实习项目的监听字段是基于什么实现的？&quot;&gt;&lt;a href=&quot;#实习项目的监听字段是基于什么实现的？&quot; class=&quot;headerlink&quot; title=&quot;实习项目的监听字段是基于什么实现的？&quot;&gt;&lt;/a&gt;实习项目的监听字段是基于什么实现的？&lt;/h2&gt;&lt;p&gt;前端进行某个</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>快手测开 2023 - 7 - 11</title>
    <link href="http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E5%BF%AB%E6%89%8B%E6%B5%8B%E5%BC%80%E5%AE%9E%E4%B9%A0/"/>
    <id>http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E5%BF%AB%E6%89%8B%E6%B5%8B%E5%BC%80%E5%AE%9E%E4%B9%A0/</id>
    <published>2023-07-23T06:50:54.000Z</published>
    <updated>2023-07-31T05:33:15.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍一下二手市场整体的架构，数据流的实现？"><a href="#简单介绍一下二手市场整体的架构，数据流的实现？" class="headerlink" title="简单介绍一下二手市场整体的架构，数据流的实现？"></a>简单介绍一下二手市场整体的架构，数据流的实现？</h2><p><strong>整体架构：</strong></p><ol><li>持久层和缓存的选型<ol><li>MySQL作为持久层：<ol><li>支持复杂条件数据查询：在二手市场中，用户会根据自身需求筛选不同的条件进行各种复杂的查询，例如按照不同条件筛选商品等，MySQL提供丰富的查询语言和索引支持，能够高效查询相关数据。</li><li>结构化数据存储：二手市场涉及大量的结构化数据，例如：用户信息，商品信息等。而MySQL是关系型数据库，适合存储和管理结构化数据，提供事务支持，保证数据的一致性和完整性。</li></ol></li><li>Redis作为缓存：<ol><li>二手市场是多读少写的场景，用户会频繁的浏览商品，但是对商品的修改变更有限，所以可以将物品信息添加至Redis中有效减轻MySQL的读取压力，提高系统的响应和性能。</li></ol></li></ol></li><li>服务的拆分方式</li></ol><p>暂时因为是单体架构，没有钱去购买太多的服务器，所以服务暂时没有进行具体的划分，如果要进行划分的话我觉得可以划分成以下几种服务：</p><ol><li><p>用户服务：主要是对用户的身份信息进行认证和鉴权。</p></li><li><p>UGC消息通知：可以处理二手市场发布、编辑商品信息后，通过邮件、消息推送的方式告知用户。</p></li><li><p>商品信息服务：负责二手商品信息的发布、编辑、删除、搜索等功能。</p></li><li><p>缓存服务：应对二手市场这种读大于写的场景，可以将最新的50条商品信息放入系统缓存中，优化用户查看商品的体验。</p></li><li><p>支付服务：支付服务负责处理用户的支付请求，与第三方支付平台进行交互，并确保支付的安全性和可靠性。</p></li><li><p>文件服务：用于处理用户上传的图片、视频。</p></li><li><p>服务容灾和负载均衡方式</p><ol><li>服务容灾：<ol><li>定期对系统的数据进行备份</li><li>定期检查维护服务器的实例，修复代码BUG等</li></ol></li><li>负载均衡：<ol><li>CDN服务：将静态资源（图片、视频等）放置在内容分发网络中，加快资源加载速度，减少服务器负载</li><li>缓存数据，使用缓存减轻服务器负担，提高响应速度</li><li>反向代理：通过Nginx反向代理服务实现负载均衡，等后面有多台服务器之后将请求分发给不同的服务器，提高服务可扩展性。</li></ol></li></ol></li></ol><p><strong>数据流实现：</strong></p><ol><li>用户上传商品：<ol><li>用户在应用中填写商品信息，并上传相关照片</li><li>上传的用户信息和照片URL被发送到服务器中进行处理和存储</li><li>服务器对传过来的数据进行数据库存储，并生成一个唯一ID</li></ol></li><li>商品展示和搜索：<ol><li>其他用户访问二手市场时，前端向后端请求商品数据</li><li>后端从数据库中获取数据列表，并返回给前端</li><li>用户可以根据自身的需求条件查询特定的商品，前端将搜索条件发送给后端，后端根据条件查询数据库并返回匹配的商品信息。</li></ol></li><li>商品详情获取：<ol><li>当用户点击某个商品的详情信息之后，前端发送请求，传递对应的商品ID给后端</li><li>后端根据商品ID在数据库中搜索并返回具体商品信息给前端展示</li></ol></li></ol><h2 id="如果检索某个具体商品是如何实现检索的？"><a href="#如果检索某个具体商品是如何实现检索的？" class="headerlink" title="如果检索某个具体商品是如何实现检索的？"></a>如果检索某个具体商品是如何实现检索的？</h2><h2 id="查询的时候如何避免慢查询？"><a href="#查询的时候如何避免慢查询？" class="headerlink" title="查询的时候如何避免慢查询？"></a>查询的时候如何避免慢查询？</h2><ul><li>索引优化，将经常用到的字段创建索引（除去经常更新的字段、重复度很高的字段、数据量较少的情况），比如单列索引和联合索引，从而避免全表扫描。</li><li>分页查询：对于返回大量的数据查询，使用分页查询的方式，限制返回的数据量，避免一次返回大量的数据导致查询速率很慢。</li><li>缓存查询：对于一些比较查询比较频繁的数据可以使用缓存来避免每次都进行数据库查询。</li><li>合理设计数据库的表结构：比如说说评论查询，二级评论可以通过添加一个masterId字段(对应的说说id)来快速定位到此二级评论是归属于哪条说说之下。</li></ul><h2 id="如何正确的创建索引？（即：什么时候创建索引？）"><a href="#如何正确的创建索引？（即：什么时候创建索引？）" class="headerlink" title="如何正确的创建索引？（即：什么时候创建索引？）"></a>如何正确的创建索引？（即：什么时候创建索引？）</h2><ul><li>字段具有唯一性限制，即重复度很低，且不是经常修改的字段</li><li>经常用于where子句查询</li><li>经常用于group by 或者 order by查询</li><li>表的数据量比较多的情况</li></ul><h2 id="二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？"><a href="#二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？" class="headerlink" title="二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？"></a>二手市场进行物品查询，做测试的话会进行设计使用哪些测试用例？</h2><ol><li>正确、错误、空物品查询</li><li>物品大小写查询</li><li>高并发查询</li><li>过滤项查询</li><li>物品状态查询</li><li>安全性测试：比如SQL注入</li><li>边界值测试：比如输入极限情况下，很长的字符串验证系统是否能正确处理。</li></ol><h2 id="后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？"><a href="#后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？" class="headerlink" title="后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？"></a>后端如何进行统计服务的性能？是否对请求进行一些限流的操作？如何进行限流的操作？</h2><ol><li>统计性能的方式：<ol><li>日志记录</li><li>性能监控工具的使用：比如New Relic、Prometheus等</li><li>负载测试，模拟大量并发请求，观察系统的响应情况和性能指标。</li></ol></li><li>有，限流操作如下：<ol><li>固定窗口计时器：设置一个固定时间窗口，例如</li></ol></li></ol><h2 id="HashMap、HashSet、HashTable的区别？"><a href="#HashMap、HashSet、HashTable的区别？" class="headerlink" title="HashMap、HashSet、HashTable的区别？"></a>HashMap、HashSet、HashTable的区别？</h2><p><strong>HashMap和HashTable区别：</strong></p><ul><li>线程是否安全：HashMap是非线程安全，HashTable是线程安全（通过synchronized修饰实现）。</li><li>效率：由于HashMap线程不安全，HashMap比HashTable效率高，但是HashTable几乎被淘汰，平时一般不会用HashTable。</li><li>键值对存值问题：HashMap是可存null键和null值，HashTable不允许有null键和null值，否则会抛出异常NPE。</li><li>初始容量大小和每次扩充容量大小不同：HashTable初始化容量是11，每次扩容就是2n+1，HashMap初始化容量是16，每次扩容就是原来的2n倍。</li><li>底层数据结构：HashMap是<strong>数组+<strong><strong>链表</strong></strong>/红黑树</strong>实现，在解决哈希冲突时，当链表长度大于阈值（默认为8），将链表转化成红黑树（将链表转化成红黑树之前，如果数组长度小于64就会进行数组扩容，而不是转换成红黑树），以减少搜索时间，而HashTable是<strong>数组+链表</strong>的形式实现。</li></ul><p><strong>HashMap和<strong><strong>HashSet</strong></strong>的区别：</strong></p><ul><li>HashMap实现Map接口，HashSet实现Set接口。</li><li>HashMap存储键值对，HashSet只存储对象。</li><li>HashMap通过put方法添加元素，HashSet通过add()向Set中添加元素。</li><li>HashMap使用Key计算hashcode，HashSet使用成员对象计算hashcode值。</li></ul><h2 id="HashMap是线程的安全的吗？介绍一下ConcurrentHashMap"><a href="#HashMap是线程的安全的吗？介绍一下ConcurrentHashMap" class="headerlink" title="HashMap是线程的安全的吗？介绍一下ConcurrentHashMap"></a>HashMap是线程的安全的吗？介绍一下ConcurrentHashMap</h2><p>线程<strong>不安全</strong>，因为多线程情况下，HashMap进行键值对存值的时候，可能会因为分配到一个桶里面造成数据覆盖的风险，比如线程1，2同时进行put操作，此时正好发生了hash冲突，线程1执行完hash冲突判断之后，时间片耗尽挂起，此时线程2进行hash冲突判断并对数据插入到链表中，后面等线程1重新获取到时间片，进行插入操作就会覆盖掉线程插入的数据。</p><p><strong>ConcuurentHashMap：</strong></p><p>Java8以上数据结构是Node数组+链表/红黑树，哈希冲突时当链表长度大于一定长度时，链表就会转换成红黑树。</p><h2 id="接口和抽象类的区别？"><a href="#接口和抽象类的区别？" class="headerlink" title="接口和抽象类的区别？"></a>接口和抽象类的区别？</h2><ul><li>接口是对类的行为进行约束，实现了某个接口就是已经拥有了具体的行为，抽象类是代码复用，强调的是类的从属关系。</li><li>接口的成员变量只能用public static final修饰且不可修改和初始化，抽象类的成员变量默认为default类型，可以在子类被重新赋值定义。</li><li>一个类可以实现多个接口但是只能继承一个父类。</li></ul><h2 id="如果某个网页打不开了，排查手段有哪些？"><a href="#如果某个网页打不开了，排查手段有哪些？" class="headerlink" title="如果某个网页打不开了，排查手段有哪些？"></a>如果某个网页打不开了，排查手段有哪些？</h2><h2 id="Linux中查看主目录下以-log结尾的文件？"><a href="#Linux中查看主目录下以-log结尾的文件？" class="headerlink" title="Linux中查看主目录下以.log结尾的文件？"></a>Linux中查看主目录下以.log结尾的文件？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/home/directory -<span class="built_in">type</span> f -name <span class="string">&quot;*.log&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>find</code>：命令本身，用于查找文件和目录。</li><li><code>/path/to/home/directory</code>：替换为你要查找的主目录的路径。例如，如果你要在当前用户的主目录下查找，可以使用<code>~</code>代替这个路径。</li><li><code>-type f</code>：表示只查找普通文件，不包括目录等其他类型的文件。</li><li><code>-name &quot;*.log&quot;</code>：表示查找文件名以<code>.log</code>结尾的文件。<code>*.log</code>是通配符，表示匹配所有以<code>.log</code>结尾的文件名。</li></ul><h2 id="如何查询某个日志的内容？"><a href="#如何查询某个日志的内容？" class="headerlink" title="如何查询某个日志的内容？"></a>如何查询某个日志的内容？</h2><ul><li>Cat</li><li>Head</li><li>Tail</li><li>Less</li><li>More</li></ul><h2 id="比较一下less命令和more命令的区别？"><a href="#比较一下less命令和more命令的区别？" class="headerlink" title="比较一下less命令和more命令的区别？"></a>比较一下less命令和more命令的区别？</h2><ul><li>less支持前后翻页，more只支持向后翻页</li><li>less是根据要展示的内容加载到内存中，加快读取速度，more是将整个文件内容全部加载到内存中，可能会导致崩溃</li></ul><h2 id="算法题：力扣平衡字符串问题"><a href="#算法题：力扣平衡字符串问题" class="headerlink" title="算法题：力扣平衡字符串问题"></a>算法题：力扣平衡字符串问题</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单介绍一下二手市场整体的架构，数据流的实现？&quot;&gt;&lt;a href=&quot;#简单介绍一下二手市场整体的架构，数据流的实现？&quot; class=&quot;headerlink&quot; title=&quot;简单介绍一下二手市场整体的架构，数据流的实现？&quot;&gt;&lt;/a&gt;简单介绍一下二手市场整体的架构，数</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>滴滴golang后端实习 2023 - 07 - 04</title>
    <link href="http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E6%BB%B4%E6%BB%B4Golang%E5%AE%9E%E4%B9%A0/"/>
    <id>http://xiaobazeo.github.io/2023/07/23/%E9%9D%A2%E7%BB%8F-%E6%BB%B4%E6%BB%B4Golang%E5%AE%9E%E4%B9%A0/</id>
    <published>2023-07-23T05:16:20.000Z</published>
    <updated>2023-07-31T05:32:49.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP有哪些请求方式？"><a href="#HTTP有哪些请求方式？" class="headerlink" title="HTTP有哪些请求方式？"></a>HTTP有哪些请求方式？</h2><ul><li>PUT：将数据存储在服务器，覆盖指定URL，常用于更新资源</li><li>GET：从服务器获取数据，GET请求是幂等的，即多次请求相同的URL会返回相同的结果</li><li>POST：向服务器提交数据，通常用于向服务器发送数据，比如提交表单</li><li>DELETE：从服务器删除指定的URL资源。</li><li>HEAD：类似于GET请求，但服务器只返回头部信息，不返回实际数据。主要用于检查资源的元数据，例如确认资源是否存在或最后修改日期等。</li><li>OPTIONS：获取目标URL支持的请求方法信息。用于查询服务器支持哪些HTTP方法。</li><li>PATCH：用于对资源进行局部更新，更新指定的字段而不是像PUT一样更新整个资源。</li><li>TRACE：用于目标服务器上执行一个消息环回测试，主要用于诊断。</li><li>CONNECT：用于代理服务器请求，通常用于建立代理服务器的隧道。</li></ul><h2 id="POST和GET的使用场景及区别？"><a href="#POST和GET的使用场景及区别？" class="headerlink" title="POST和GET的使用场景及区别？"></a>POST和GET的使用场景及区别？</h2><p>POST主要用于客户端向服务端提交数据的时候使用，GET主要用于客户端向服务端获取请求的时候使用。</p><p>POST和GET实际上没有什么区别，如果硬要说有区别可见如下：</p><ul><li>GET方法产生一个数据包，POST方法产生两个数据包。<ul><li>GET方法会将header和data一并发给服务器，服务器响应200。</li><li>POST方法会先发送header给服务器，等服务器返回100之后发送data给服务器，然后服务器响应200。此方法在网络差的情况下，会稍微好一点，因为分两次发可能丢包率会小一些。（POST请求，数据包Firefox只会发一次）</li></ul></li><li>GET请求URL传递的参数会有长度限制，POST没有</li><li>GET请求传递参数放在URL中，POST放在Body部分</li><li>GET请求只接受ASCII字符，POST无限制</li><li>GET请求比POST更不安全，因为参数会外漏在URL，所以不能传递敏感信息。</li></ul><h2 id="Token在HTTP请求的时候会放在什么位置？"><a href="#Token在HTTP请求的时候会放在什么位置？" class="headerlink" title="Token在HTTP请求的时候会放在什么位置？"></a>Token在HTTP请求的时候会放在什么位置？</h2><p>一般存在header里面的Authorization字段，Java获取的此字段信息的代码一般如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 获取Authorization头的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorizationHeader</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        System.out.println(authorizationHeader);</span><br><span class="line"></span><br><span class="line">        response.getWriter().write(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？"><a href="#GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？" class="headerlink" title="GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？"></a>GET请求的时候URL有长度限制？是HTTP本身限制了这个URL长度吗？怎么去解决URL超长的问题？</h2><ol><li>有长度限制。</li><li>不是HTTP本身限制了这个URL长度，一般是指定的浏览器或者服务器对它进行了长度的限制，超过一定的限制，服务器可能会直接返回错误或者截断URL，发生错误的请求。</li><li>解决URL超长问题方法如下：<ol><li>采取POST请求，因为POST请求对数据传输的长度没有限制</li><li>分割请求，如果传输的数据量很大，可以分割成很多小的请求分批次进行数据发送，然后服务端进行整合。</li><li>避免GET请求传输大量的数据。</li><li>压缩URL参数：通过将GET请求的URL参数进行压缩，转换成Base64来压缩参数，减少URL长度。</li></ol></li></ol><h2 id="介绍一下对Spring的理解"><a href="#介绍一下对Spring的理解" class="headerlink" title="介绍一下对Spring的理解"></a>介绍一下对Spring的理解</h2><p>是一款开源的轻量级开发框架，是多个模块的集合，比如：Spring IOC、Spring AOP等。</p><ol><li>SpringIOC（DI）</li><li>SpringAOP</li><li>可以整合其他技术开发</li></ol><h2 id="Spring、SpringMVC、SpringleBoot的区别"><a href="#Spring、SpringMVC、SpringleBoot的区别" class="headerlink" title="Spring、SpringMVC、SpringleBoot的区别"></a>Spring、SpringMVC、SpringleBoot的区别</h2><ul><li>Spring的核心模块就是Spring-Core（主要负责SpringIOC容器的依赖注入的支持），Spring其他所有功能都依赖此模块（包括SpringMVC）。</li><li>SpringMVC是Spring中得一个模块，主要赋予Spring快速构建MVC架构的Web程序能力，MVC（Model、View、Controller），其核心思想就是将业务逻辑、数据处理、视图显示分离来组织代码。</li><li>SpringBoot只是简化了配置，减少配置文件（比如xml文件、Java显示配置，开箱即用）</li></ul><h2 id="解释一下SpringIOC、SpringAOP"><a href="#解释一下SpringIOC、SpringAOP" class="headerlink" title="解释一下SpringIOC、SpringAOP"></a>解释一下SpringIOC、SpringAOP</h2><p><strong>Spring</strong> <strong>IOC<strong><strong>（</strong></strong>inversion of control<strong><strong>，</strong></strong>控制反转****）</strong></p><p>是一种设计思想，其思想就是把原本在程序创建对象的控制权，统一交给SpringIOC容器去管理，控制：创建对象实例的权利，反转：控制权交给Spring框架、IOC容器去管理。</p><p>有了SpringIOC之后，我们只需要直接从容器中获取对象即可，而对象的创建是交给SpringIOC容器去创建管理的。</p><p>实现方式：</p><p>1、从配置元数据获取DI的业务POJO（配置元数据：xml、Configuration、注解等）</p><p>2、将业务POJO形成BeanDefinition注入到Spring Container中</p><p>3、使用方通过AppllicationContext从SpringContainer中获取即可</p><p><strong>Spring AOP（Aspect Object Programming，<strong><strong>面向切面编程</strong></strong>）</strong></p><p>就是把公共逻辑抽出来，让开发者更加专注于业务逻辑开发。AOP是一种设计思想，是OOP的补充，OOP是面向类和对象的，但是AOP是面向不同切面的，一个切面可以横跨多个类和对象去操作，极大的提高了开发效率。</p><p>比如一个订单的创建，大致流程是：</p><p>1、权限校验</p><p>2、事务管理</p><p>3、创建订单</p><p>4、日志管理</p><p>使用AOP思想就可以把这四个步骤当作四个切面，让开发者专注于第三个切面，其他三个切面则使用基础的通用逻辑统一交给AOP封装管理。</p><h2 id="SpringAOP是如何实现的？"><a href="#SpringAOP是如何实现的？" class="headerlink" title="SpringAOP是如何实现的？"></a>SpringAOP是如何实现的？</h2><p>AOP实现原理：</p><p>AOP实现有两种方式，一种是Java原生的动态代理，一种是基于cglib的动态代理。默认的一般是原生的JDK的动态代理，但是这种代理方式无法代理没有接口的类，此时就会使用cglib代理这个没有接口实现的类。</p><h2 id="Sql注入攻击是什么？SQL注入是怎么产生的？"><a href="#Sql注入攻击是什么？SQL注入是怎么产生的？" class="headerlink" title="Sql注入攻击是什么？SQL注入是怎么产生的？"></a>Sql注入攻击是什么？SQL注入是怎么产生的？</h2><p><strong>SQL注入攻击****：</strong>针对使用SQL进行数据查询和操作的应用程序，基本原理是通过在用户输入的数据中插入恶意的SQL代码，从而让应用程序执行未经授权的数据库操作或者或者泄露敏感信息。</p><p>比如SQL = select * from user where username = ‘#{username}’ and password = ‘#{password}’，攻击者在用户名框或者密码输入框中输入恶意的SQL代码：<code>&#39; OR 1 = 1 --</code> 就会变成<code>select * from user where username = &#39;&#39; or 1 = 1  --&#39;and password=&#39;&#39;</code> ，此时<code>-- &#39; and password = &#39;&#39;</code> 已经被注释掉了实际上就是<code>select * from user where username = &#39;&#39; or 1 = 1;</code> 此时就会将所有用户的数据信息全部返回给前端。</p><p><strong>SQL注入的产生</strong></p><p>1、参数未校验，用户不正确的输入</p><p>2、特殊字符未转义，例如：=、–这种类型的符号</p><h2 id="什么时候需要创建索引？"><a href="#什么时候需要创建索引？" class="headerlink" title="什么时候需要创建索引？"></a>什么时候需要创建索引？</h2><ul><li>字段具有唯一性限制</li><li>经常用于where子句查询的字段</li><li>经常用于group by 和 order by查询的字段</li></ul><h2 id="为什么索引如果重复度比较高的时候会对数据库产生一定的压力？"><a href="#为什么索引如果重复度比较高的时候会对数据库产生一定的压力？" class="headerlink" title="为什么索引如果重复度比较高的时候会对数据库产生一定的压力？"></a>为什么索引如果重复度比较高的时候会对数据库产生一定的压力？</h2><ul><li>导致页分裂，占用物理空间大：每次数据更新的话，会导致索引进行重新排序，甚至造成页分裂的问题，导致索引查询效率下降，也会在一定程度上造成空间不必要的浪费。</li><li>维护成本高：索引重复度比较高也会导致索引字段大小很大，维护空间和时间成本就会变大，占用一定的冗余物理空间</li><li>查询效率低：索引重复度比较高可能会匹配到多个符合条件的索引项，进而增加查询的开销，导致查询效率下降。</li><li>内存消耗大：如果是5.7的版本，由于MySQL的索引缓存存在的原因，索引重复度高，索引大小也会变大，需要更多的内存去存储这些数据，高内存可能会导致服务器崩溃。</li></ul><h2 id="创建联合索引失效的情况"><a href="#创建联合索引失效的情况" class="headerlink" title="创建联合索引失效的情况"></a>创建联合索引失效的情况</h2><p>当where子句查询或者order by或者group by查询的时候没有遵循最左匹配原则则会导致查询时联合索引部分失效。</p><p>比如:创建索引(a,b,c)，此时<code>select * from user where a = 1 and b = 1 and c = 1;</code>此时均用到了联合索引。</p><p>若改成<code>select * from user where a = 1 and b &gt; 1 and c = 1;</code>此时用到了索引的只有a,b，因为索引查询是先对a进行排序，在a相等的情况下，对b再进行排序，最后在b相同的情况下对c进行排序，此时因为b &gt; 1无法直接定位到从哪个索引列开始顺序查询，也就是说对c再进行排序的话无法进一步提高查询速率，所以只有a，b用到了联合索引。</p><blockquote><p>一条查询语句的顺序是from -&gt; where -&gt; group by -&gt; Having -&gt; select -&gt; order by</p></blockquote><h2 id="如果有一个联合索引-a-b-c-，如果where子句查询只有a-1-and-c-1，能不能实现走-a-b-c-这个索引查询？"><a href="#如果有一个联合索引-a-b-c-，如果where子句查询只有a-1-and-c-1，能不能实现走-a-b-c-这个索引查询？" class="headerlink" title="如果有一个联合索引(a,b,c)，如果where子句查询只有a = 1 and c = 1，能不能实现走(a,b,c)这个索引查询？"></a>如果有一个联合索引(a,b,c)，如果where子句查询只有a = 1 and c = 1，能不能实现走(a,b,c)这个索引查询？</h2><p>1、如果能够修改a,b,c联合索引的顺序的话，就可以实现，比如改成<code>(a,c,b)</code> 因为联合索引遵循<strong>最左匹配原则</strong>，即先对a排序，在a相同的情况下，对c排序，在c相同的情况下再对b进行排序，最终形成索引B+树。</p><p>2、如果不可以修改联合索引的顺序，那么将无法实现走a,b,c形成的联合索引查询，此时只有a = 1能走到联合索引。</p><h2 id="目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？"><a href="#目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？" class="headerlink" title="目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？"></a>目前有一个人员表，有姓名，年龄，性别字段，要求统计不同年龄下不同性别的人数？统计不同年龄下的人数？</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> age , sex , count<span class="comment">(*) from user group by age , sex;</span></span><br><span class="line"><span class="comment">select age , count(*)</span> <span class="keyword">from</span> user <span class="keyword">group</span> <span class="keyword">by</span> age<span class="punctuation">;</span> </span><br></pre></td></tr></table></figure><h2 id="有两个集合List如何快速找出相同的元素？"><a href="#有两个集合List如何快速找出相同的元素？" class="headerlink" title="有两个集合List如何快速找出相同的元素？"></a>有两个集合List如何快速找出相同的元素？</h2><p>思路大致如下：</p><ol><li>创建并初始化两个List类型的链表</li><li>将两个List类型的列表转换成HashSet类型</li><li>使用HashSet自带的取交集方法<code>set1.retainAll(set2)</code> ，此时set1中保存的就是原set1和set2的交集，即两个集合相同的元素。</li></ol><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindCommonElements</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例数据</span></span><br><span class="line">        List&lt;Integer&gt; list1 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        List&lt;Integer&gt; list2 = Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用HashSet找出相同元素</span></span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list1);</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(list2);</span><br><span class="line"></span><br><span class="line">        set1.retainAll(set2); <span class="comment">// 保留set1中与set2的交集</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set1); <span class="comment">// 输出：[3, 4, 5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构：哈希如何使用？"><a href="#数据结构：哈希如何使用？" class="headerlink" title="数据结构：哈希如何使用？"></a>数据结构：哈希如何使用？</h2><p>「哈希表 Hash Table」通过建立键 <code>key</code> 与值 <code>value</code> 之间的映射，实现高效的元素查询。具体而言，我们向哈希表输入一个 <code>key</code> ，则可以在O(1)时间内获取对应的 <code>value</code> 。</p><p>详情见下：</p><p><a href="https://www.hello-algo.com/chapter_hashing/hash_map/">哈希表（Hello算法）</a></p><h2 id="有一个集合Set怎么批量删除部分元素？"><a href="#有一个集合Set怎么批量删除部分元素？" class="headerlink" title="有一个集合Set怎么批量删除部分元素？"></a>有一个集合Set怎么批量删除部分元素？</h2><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoveElementsFromSet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 原始Set</span></span><br><span class="line">        Set&lt;Integer&gt; originalSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        originalSet.add(<span class="number">1</span>);</span><br><span class="line">        originalSet.add(<span class="number">2</span>);</span><br><span class="line">        originalSet.add(<span class="number">3</span>);</span><br><span class="line">        originalSet.add(<span class="number">4</span>);</span><br><span class="line">        originalSet.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要删除的元素集合</span></span><br><span class="line">        Set&lt;Integer&gt; elementsToRemove = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        elementsToRemove.add(<span class="number">3</span>);</span><br><span class="line">        elementsToRemove.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 批量删除部分元素</span></span><br><span class="line">        originalSet.removeAll(elementsToRemove);</span><br><span class="line"></span><br><span class="line">        System.out.println(originalSet); <span class="comment">// 输出：[1, 2, 4]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Linux查询一个日志文件的关键字？查询某个关键字的前后500行？"><a href="#Linux查询一个日志文件的关键字？查询某个关键字的前后500行？" class="headerlink" title="Linux查询一个日志文件的关键字？查询某个关键字的前后500行？"></a>Linux查询一个日志文件的关键字？查询某个关键字的前后500行？</h2><p>查询日志文件的某个关键字可以使用grep命令实现，例如:grep ‘关键字’ filePath</p><p>查询某个关键字的前后500行：grep -AB 500或者 grep -C 500（-C == -AB）</p><h2 id="怎么保证MySQL和Redis的一致性问题"><a href="#怎么保证MySQL和Redis的一致性问题" class="headerlink" title="怎么保证MySQL和Redis的一致性问题"></a>怎么保证MySQL和Redis的一致性问题</h2><p>读请求：先读缓存，如果缓存失效或不存在就让先获取到互斥锁的线程查数据库并回写缓存，让后续的请求直接都缓存即可</p><p>写请求：先更新数据库，再删缓存即可（此时可能会出现删缓存失败的场景，可以通过消息队列的方式，采取重试机制，如果删除缓存失败，则通过消息队列再进行一次删除缓存的操作，如果删除成功，则把消息队列里面的删除缓存操作删除即可，避免重复消费，造成不必要的资源浪费）</p><h2 id="价格类型的数据Java用什么存储？"><a href="#价格类型的数据Java用什么存储？" class="headerlink" title="价格类型的数据Java用什么存储？"></a>价格类型的数据Java用什么存储？</h2><p>1、BigDecimal（使用String类型的进行转换，才不会导致精度丢失)</p><p>2、整数存储（比如：3.14存为314）</p><p>3、自定义存储方式，数据库一个字段存整数，一个字段存小数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP有哪些请求方式？&quot;&gt;&lt;a href=&quot;#HTTP有哪些请求方式？&quot; class=&quot;headerlink&quot; title=&quot;HTTP有哪些请求方式？&quot;&gt;&lt;/a&gt;HTTP有哪些请求方式？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;PUT：将数据存储在服务器，覆盖指定URL，常用</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用</title>
    <link href="http://xiaobazeo.github.io/2023/05/29/Docker%E4%BD%BF%E7%94%A8/"/>
    <id>http://xiaobazeo.github.io/2023/05/29/Docker%E4%BD%BF%E7%94%A8/</id>
    <published>2023-05-29T15:46:11.000Z</published>
    <updated>2023-05-29T16:25:48.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h2><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230529235020493.png" alt="image-20230529235020493"></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><ul><li>docker images</li></ul><blockquote><p>罗列出docker的所有的镜像相关信息</p></blockquote><ul><li>docker search 某个xxx镜像的名字</li></ul><blockquote><p>在hub仓库查询是否有相关的镜像 –limit 默认罗列前25个</p></blockquote><ul><li>docker pull 某个xxx镜像名[:tag]</li></ul><blockquote><p>tag:表示版本号    </p></blockquote><ul><li><p>docker system df 查看镜像/容器/数据卷所占空间</p></li><li><p>docker rmi 某个xxx镜像的id或者名字  -f强制删除</p><blockquote><p>docker rmi hello-world 或 docker rmi 9c7a54a9a43c<br>删除多个:</p><pre><code>docker rmi -f 镜像名1:tag 镜像名2:tag....docker rmi -f $(docker images -qa)</code></pre></blockquote><p>什么叫虚悬镜像？</p><p>仓库名、标签都是<none>的，俗称虚悬镜像，通常会把他删掉</none></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;帮助启动类命令&quot;&gt;&lt;a href=&quot;#帮助启动类命令&quot; class=&quot;headerlink&quot; title=&quot;帮助启动类命令&quot;&gt;&lt;/a&gt;帮助启动类命令&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://pengzihao166.oss-cn-beijing.aliy</summary>
      
    
    
    
    
    <category term="Docker" scheme="http://xiaobazeo.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>微布开发-微信三方接口文本校验校验开发思路</title>
    <link href="http://xiaobazeo.github.io/2023/05/27/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%BE%AE%E4%BF%A1%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E6%96%87%E6%9C%AC%E6%A0%A1%E9%AA%8C%E6%A0%A1%E9%AA%8C%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/"/>
    <id>http://xiaobazeo.github.io/2023/05/27/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91-%E5%BE%AE%E4%BF%A1%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E6%96%87%E6%9C%AC%E6%A0%A1%E9%AA%8C%E6%A0%A1%E9%AA%8C%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/</id>
    <published>2023-05-27T02:12:14.000Z</published>
    <updated>2023-08-03T02:42:13.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="根据文档要求总结分为以下的情况："><a href="#根据文档要求总结分为以下的情况：" class="headerlink" title="根据文档要求总结分为以下的情况："></a>根据文档要求总结分为以下的情况：</h3><ol><li>文本内容正常 (suggest: “pass”, label: 100)：<ol><li>情况处理：如果文本内容被判定为正常，可以允许发布该文本内容。</li></ol></li><li>文本内容命中关键词，但不违规 (suggest: “pass”, label: 20006)：<ol><li>情况处理：如果文本内容命中自定义关键词但不违规，可以允许发布该文本内容，同时可能根据需要记录命中的关键词和概率信息。</li></ol></li><li>文本内容建议审核 (suggest: “review”)：<ol><li>情况处理：如果文本内容被建议进行审核，您可以将该内容设置为待审核状态，让人工审核来决定是否发布该内容。</li></ol></li><li>文本内容命中违规标签 (suggest: “risky”)：<ol><li>情况处理：如果文本内容被判定为违规，应禁止发布该内容，并通知用户违规原因。</li></ol></li><li>文本内容属于广告 (label: 10001)：<ol><li>情况处理：如果文本内容被判定为广告，应禁止发布该内容，并通知用户不允许发布广告内容。</li></ol></li><li>文本内容属于色情、辱骂、违法犯罪等 (label: 20002, 20003, 20006等)：<ol><li>情况处理：如果文本内容被判定为色情、辱骂、违法犯罪等，应禁止发布该内容，并根据需要采取进一步的处理措施，比如记录日志或进行用户封禁等。</li></ol></li></ol><h3 id="开发思路如下："><a href="#开发思路如下：" class="headerlink" title="开发思路如下："></a>开发思路如下：</h3><ol><li>从Redis中获取到AccessToken</li><li>查库获取发布者微信的openid</li><li>调用<a href="https://api.weixin.qq.com/wxa/msg_sec_check?access_token=%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%A0%A1%E9%AA%8C%E8%BF%94%E5%9B%9E%E5%8F%82%E6%95%B0">https://api.weixin.qq.com/wxa/msg_sec_check?access_token=接口，校验返回参数</a><ol><li>errocode == 0<ol><li>获取result对象的suggest参数值并进行比较<ol><li>如果文本内容建议审核，则根据实际需求执行人工审核流程，”review”.equals(suggest)</li><li>如果文本内容正常或命中关键词但不违规，允许发布，”pass”.equals(suggest)</li><li>如果文本内容被判定为违规，禁止发布，并输出违规信息，”risky”.equals(suggest)<ol><li>此时可以遍历detail数组，并获取对应的prob如果其中有敏感词汇prob&gt;50就不准发布。</li></ol></li></ol></li></ol></li></ol></li></ol><h3 id="大致代码逻辑如下："><a href="#大致代码逻辑如下：" class="headerlink" title="大致代码逻辑如下："></a>大致代码逻辑如下：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(String result)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">JSONObject</span> <span class="variable">responseJson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(result);</span><br><span class="line">          <span class="type">int</span> <span class="variable">errcode</span> <span class="operator">=</span> responseJson.getInt(<span class="string">&quot;errcode&quot;</span>);</span><br><span class="line">          <span class="type">String</span> <span class="variable">errmsg</span> <span class="operator">=</span> responseJson.getString(<span class="string">&quot;errmsg&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (errcode == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 获取综合结果信息</span></span><br><span class="line">              <span class="type">JSONObject</span> <span class="variable">resultObject</span> <span class="operator">=</span> responseJson.getJSONObject(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">              <span class="type">String</span> <span class="variable">suggest</span> <span class="operator">=</span> resultObject.getString(<span class="string">&quot;suggest&quot;</span>);</span><br><span class="line">              <span class="type">int</span> <span class="variable">label</span> <span class="operator">=</span> resultObject.getInt(<span class="string">&quot;label&quot;</span>);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 输出综合结果信息</span></span><br><span class="line">              System.out.println(<span class="string">&quot;综合结果：&quot;</span>);</span><br><span class="line">              System.out.println(<span class="string">&quot;建议：&quot;</span> + suggest);</span><br><span class="line">              System.out.println(<span class="string">&quot;标签：&quot;</span> + label);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果文本内容建议审核，则根据实际需求执行人工审核流程</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="string">&quot;review&quot;</span>.equals(suggest)) &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;该文本内容建议进行人工审核！&quot;</span>);</span><br><span class="line">                  <span class="comment">// 可以将内容设置为待审核状态，由人工审核决定是否发布</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;pass&quot;</span>.equals(suggest)) &#123;</span><br><span class="line">                  <span class="comment">// 如果文本内容正常或命中关键词但不违规，允许发布</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;文本内容合规，可以发布！&quot;</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;risky&quot;</span>.equals(suggest)) &#123;</span><br><span class="line">                  <span class="comment">// 如果文本内容被判定为违规，禁止发布，并输出违规信息</span></span><br><span class="line">                  System.out.println(<span class="string">&quot;文本内容违规，请修改后重新提交！&quot;</span>);</span><br><span class="line">                  <span class="type">JSONArray</span> <span class="variable">detailArray</span> <span class="operator">=</span> responseJson.getJSONArray(<span class="string">&quot;detail&quot;</span>);</span><br><span class="line">                  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; detailArray.length(); i++) &#123;</span><br><span class="line">                      <span class="type">JSONObject</span> <span class="variable">detailObject</span> <span class="operator">=</span> detailArray.getJSONObject(i);</span><br><span class="line">                      <span class="type">String</span> <span class="variable">strategy</span> <span class="operator">=</span> detailObject.getString(<span class="string">&quot;strategy&quot;</span>);</span><br><span class="line">                      <span class="keyword">if</span> (<span class="string">&quot;keyword&quot;</span>.equals(strategy)) &#123;</span><br><span class="line">                          <span class="type">String</span> <span class="variable">keyword</span> <span class="operator">=</span> detailObject.getString(<span class="string">&quot;keyword&quot;</span>);</span><br><span class="line">                          <span class="type">int</span> <span class="variable">prob</span> <span class="operator">=</span> detailObject.getInt(<span class="string">&quot;prob&quot;</span>);</span><br><span class="line">                          System.out.println(<span class="string">&quot;命中关键词：&quot;</span> + keyword + <span class="string">&quot;，概率：&quot;</span> + prob);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  System.out.println(<span class="string">&quot;未知建议类型：&quot;</span> + suggest);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 输出错误信息</span></span><br><span class="line">              System.out.println(<span class="string">&quot;接口调用失败，错误码：&quot;</span> + errcode + <span class="string">&quot;，错误信息：&quot;</span> + errmsg);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;接口调用失败！&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;根据文档要求总结分为以下的情况：&quot;&gt;&lt;a href=&quot;#根据文档要求总结分为以下的情况：&quot; class=&quot;headerlink&quot; title=&quot;根据文档要求总结分为以下的情况：&quot;&gt;&lt;/a&gt;根据文档要求总结分为以下的情况：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;文本内容正常 (</summary>
      
    
    
    
    
    <category term="微布开发思路总结" scheme="http://xiaobazeo.github.io/tags/%E5%BE%AE%E5%B8%83%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>备份hexo-_o-U盘篇</title>
    <link href="http://xiaobazeo.github.io/2023/05/16/%E5%A4%87%E4%BB%BDhexo-o-U%E7%9B%98%E7%AF%87/"/>
    <id>http://xiaobazeo.github.io/2023/05/16/%E5%A4%87%E4%BB%BDhexo-o-U%E7%9B%98%E7%AF%87/</id>
    <published>2023-05-16T07:06:32.000Z</published>
    <updated>2023-08-03T02:21:34.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新机环境搭建"><a href="#新机环境搭建" class="headerlink" title="新机环境搭建"></a>新机环境搭建</h2><p>​    1、安装Node.js</p><p>​    2、安装Git</p><p>​    3、新建存放Blog的文件夹</p><h2 id="拷贝旧机器中得文件-文件夹"><a href="#拷贝旧机器中得文件-文件夹" class="headerlink" title="拷贝旧机器中得文件/文件夹"></a>拷贝旧机器中得文件/文件夹</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line"><span class="keyword">package</span>.json</span><br><span class="line">scaffolds/</span><br><span class="line"><span class="keyword">source</span>/</span><br><span class="line">themes/</span><br><span class="line">其中/代表拷贝的是文件夹</span><br></pre></td></tr></table></figure><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>右键打开Git bash，依次输入下列命令之后，安装相关依赖</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>安装hexo</span><br><span class="line">   <span class="built_in">npm</span> install -g hexo</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>本地测试的时候需要用hexo server</span><br><span class="line">   <span class="built_in">npm</span> i hexo-server</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>将文章部署到github上的模块</span><br><span class="line">   <span class="built_in">npm</span> install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>安装RSS插件</span><br><span class="line">   <span class="built_in">npm</span> install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>添加Sitemap,加速网页收录速度</span><br><span class="line">   <span class="built_in">npm</span> install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><h2 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s -g == hexo g + hexo s</span><br></pre></td></tr></table></figure><p>在浏览器打开<a href="http://localhost:4000/">http://localhost:4000</a>查看效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新机环境搭建&quot;&gt;&lt;a href=&quot;#新机环境搭建&quot; class=&quot;headerlink&quot; title=&quot;新机环境搭建&quot;&gt;&lt;/a&gt;新机环境搭建&lt;/h2&gt;&lt;p&gt;​    1、安装Node.js&lt;/p&gt;
&lt;p&gt;​    2、安装Git&lt;/p&gt;
&lt;p&gt;​    3、新建存</summary>
      
    
    
    
    
    <category term="程序人生" scheme="http://xiaobazeo.github.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>网络基础篇</title>
    <link href="http://xiaobazeo.github.io/2023/05/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://xiaobazeo.github.io/2023/05/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2023-05-15T18:25:03.000Z</published>
    <updated>2023-05-16T08:27:01.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP网络模型有哪几层？"><a href="#TCP-IP网络模型有哪几层？" class="headerlink" title="TCP/IP网络模型有哪几层？"></a>TCP/IP网络模型有哪几层？</h2><h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><p>&emsp;&emsp;用户直接接触到的就是<strong>应用层</strong>，应用层专注于用户提供应用功能，例如：HTTP、FTP、DNS、Telnet、SMTP等。</p><p>&emsp;&emsp;应用层工作在操作系统中得<strong>用户态</strong>，<strong>传输层及以下</strong>则工作在<strong>内核态</strong>。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>&emsp;&emsp;应用层的数据包会传给传输层，传输层是为应用层提供网络支持。传输层的两个协议：<strong>TCP</strong>和<strong>UDP</strong>。</p><p>&emsp;&emsp;TCP（传输控制协议），TCP相较于UDP的特性，比如：<strong>流量控制，超时重传，拥塞控制</strong>等，为了保证数据包能可靠的传输给对方。</p><p>&emsp;&emsp;UDP只负责发送数据包，<strong>不保证</strong>数据包是否能抵达对方，但是<strong>实时性</strong>相对较好，<strong>传输效率</strong>也较高。如果要实现UDP的可靠传输，可以把TCP的特性在应用层实现。</p><p>&emsp;&emsp;应用传输数据过大，传输层的数据包大小超过MSS(TCP最大报文段长度)，需要将数据包分块，如果中途有一个分块丢失或损坏，只需重新发送此分块即可，而不需要发送整个数据包。在TCP协议中，<strong>每个分块称为一个TCP段</strong>（TCP Segment）。</p><p>&emsp;&emsp;传输层负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，此时需要用一个编号将应用区分开，这个编号就是端口。例如：Web服务器通常使用80端口，22端口通常是远程登录服务器的端口。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>&emsp;&emsp;实现传输功能的是<strong>网络层</strong>，传输层只是作为数据传输的媒介，帮助应用到应用的通信。</p><p>&emsp;&emsp;常见协议是IP协议（Internet Protocol），IP协议会将传输层的报文作为数据部分，再加上IP包头部组装成IP报文，如果IP报文大小超过MTU（一般默认1500Bytes）会<strong>再次进行分片</strong>，得到一个即将发送的到网络的IP报文。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/12.jpg" alt="选自小林coding"></p><h4 id="IP协议寻址功能："><a href="#IP协议寻址功能：" class="headerlink" title="IP协议寻址功能："></a>IP协议寻址功能：</h4><p>&emsp;&emsp;由于网络层需要有区分设备的编号，一般使用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分为四段（比如：192.168.100.1），每段8位。由于IPv4地址有设备上限，无法做到一个设备一个IP地址，所以会将IP地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该IP地址是属于哪个<strong>子网</strong>的</li><li>一个是<strong>主机号</strong>，负责标识<strong>同一子网</strong>下的<strong>不同主机</strong></li></ul><p>此时需要<strong>子网掩码</strong>才能计算出IP地址的网络号和主机号，比如：10.100.122.0/24，后面的/24表示就是255.255.255.0子网掩码，255.255.255.0二进制就是11111111-11111111-11111111-00000000，24个1，为了简化子网掩码的表示，就会用/24代替255.255.255.0</p><p><strong>网络号</strong>将 10.100.122.2 和 255.255.255.0 <strong>按位与运算</strong>。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/16.jpg" alt="取自小林coding"></p><p><strong>主机号：</strong>将 255.255.255.0 <strong>取反</strong>后与IP地址进行进行<strong>按位与运算</strong>。</p><p>在寻址过程中，先匹配相同的网络号（表示要找到同一个子网），才会去找对应的主机号。</p><h4 id="IP协议路由功能"><a href="#IP协议路由功能" class="headerlink" title="IP协议路由功能"></a>IP协议路由功能</h4><p>当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p><p>IP协议的寻址是告诉我们去往下一个目的地朝哪个方向走，路由是根据下一个目的地选择路径。</p><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>网络接口层会在IP头部的前面加上MAC头部，并封装成数据帧发送到网络上。网络接口层主要是为网络层提供链路级别传输的服务，负责以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来表示网络上的设备。</p><p>MAC头部是以以太网的头部，包含了接收方和发送方的MAC地址等信息，可以通过ARP协议获取对方的MAC地址。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络接口层的传输单位是帧，IP的传输单位是包，TCP层传输单位是段，HTTP传输单位是消息或报文，每一层的封装格式如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="取自小林coding"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP-IP网络模型有哪几层？&quot;&gt;&lt;a href=&quot;#TCP-IP网络模型有哪几层？&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP网络模型有哪几层？&quot;&gt;&lt;/a&gt;TCP/IP网络模型有哪几层？&lt;/h2&gt;&lt;h3 id=&quot;应用层：&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="计网" scheme="http://xiaobazeo.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>法大大Java实习 2023.4.6</title>
    <link href="http://xiaobazeo.github.io/2023/04/06/%E9%9D%A2%E7%BB%8F-%E6%B3%95%E5%A4%A7%E5%A4%A7Java%E5%BC%80%E5%8F%91/"/>
    <id>http://xiaobazeo.github.io/2023/04/06/%E9%9D%A2%E7%BB%8F-%E6%B3%95%E5%A4%A7%E5%A4%A7Java%E5%BC%80%E5%8F%91/</id>
    <published>2023-04-06T13:51:08.000Z</published>
    <updated>2023-08-03T02:21:17.013Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E6%B3%95%E5%A4%A7%E5%A4%A7(2023.4.6).png" alt="法大大(2023.4.6)"></p><h2 id="总结：（答得不是很完善的地方总结一下）"><a href="#总结：（答得不是很完善的地方总结一下）" class="headerlink" title="总结：（答得不是很完善的地方总结一下）"></a>总结：（答得不是很完善的地方总结一下）</h2><h3 id="接口和抽象类的共同点和区别："><a href="#接口和抽象类的共同点和区别：" class="headerlink" title="接口和抽象类的共同点和区别："></a>接口和抽象类的共同点和区别：</h3><p><strong>共同点：</strong> </p><ul><li>不可以被实例化</li><li>可以包含抽象方法</li><li>可以有默认的实现方法</li></ul><p><strong>区别：</strong></p><ul><li>接口对类的行为进行约束，实现某接口已经拥有了的具体行为，抽象类代码复用，强调的是从属关系</li><li>接口的成员变量只能用public static final修饰且不可修改并初始化，抽象类默认是default类型，可以在子类被重新定义且重新赋值</li><li>一个类只能继承一个抽象类（单继承），可实现多个接口。</li></ul><h3 id="和-equals-方法"><a href="#和-equals-方法" class="headerlink" title="== 和 equals()方法"></a>== 和 equals()方法</h3><p><strong>== 两种情况：</strong></p><ul><li>对于基本数据类型，直接比较值的大小</li><li>对于引用类型，比较对象的内存地址</li></ul><p><strong>equals（）方法：</strong></p><p>比较对象是否相等，即对象的内存地址是否相等，一般也分为两种情况</p><ul><li>重写了，一般比较两个对象的成员属性是否相等</li><li>未重写，比较的该类型的对象是否相等</li></ul><h3 id="try-catch-finally方法"><a href="#try-catch-finally方法" class="headerlink" title="try-catch-finally方法"></a>try-catch-finally方法</h3><ul><li>如果在catch中return了，那么finally里面的逻辑会在return之前被执行。</li><li>如果catch和finally都有return，那么catch的return会被忽略，</li><li>因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</li><li>finally一般用于资源回收、比如线程、数据库资源回收的情况</li></ul><h3 id="HashMap和HashSet区别"><a href="#HashMap和HashSet区别" class="headerlink" title="HashMap和HashSet区别"></a>HashMap和HashSet区别</h3><ul><li>前者实现了Map接口，后者实现了Set接口</li><li>HashSet底层是HashMap实现存储的</li></ul><h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><ul><li>前者继承了AbstractMap类，后者继承了Dictionary类</li><li>HashMap线程不安全，HashTable线程安全</li><li>contains不一样，HashMap没有contains方法只有containsValue和containsKey方法，但是HashTable这三个方法都有</li><li>key-value是否能为null，HashMap 都可以为null，HashTable都不可以null，否则就是空指针异常</li><li>获取hashCode方法不一样</li></ul><p>&emsp;&emsp;HashMap先调用hashCode获取到了hash值之后，再与右移16位的hash值相异或获取hash值。</p><p>&emsp;&emsp;HashTable直接通过hashCode方法获取</p><ul><li>解决hash冲突方法不一样</li></ul><p>&emsp;&emsp;HashMap通过数组+链表/红黑树，如果链表长度大于8，变成红黑树，若链表长度后面小于6，转回链表格式</p><p>&emsp;&emsp;HashTable只有链表存储</p><h3 id="项目介绍："><a href="#项目介绍：" class="headerlink" title="项目介绍："></a>项目介绍：</h3><p>因为主要是自己写的、在redis那一块也比较熟悉，也自己解决了缓存雪崩的问题，后面也解决了缓存和数据库一致性问题，但是面试的时候忘记提了，可能提了会更加加分~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E6%B3%95%E5%A4%A7%E5%A4%A7(2023.4.6).png&quot; alt=&quot;法大大(2023.4.6)&quot;&gt;&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之最长回文子串</title>
    <link href="http://xiaobazeo.github.io/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://xiaobazeo.github.io/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2023-03-21T08:46:39.000Z</published>
    <updated>2023-03-21T08:51:52.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><h2 id="题解如下"><a href="#题解如下" class="headerlink" title="题解如下"></a>题解如下</h2><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230321164819370.png" alt="image-20230321164819370"></p><h5 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">boolean</span> [][]dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">//所有的一个字符的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">//记录回文子串的初始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录回文子串长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">childLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span>; l &lt;= len;l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">                <span class="comment">//j代表子串的尾字符的index，即确定右边界</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果尾字符超出字符串最大长度、跳出循环</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= len)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(charArray[i]!=charArray[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//可能是一个或者两个或者三个字符的子串</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则就依次递归</span></span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若 dp[i][l] == true 成立，就表示s[i....l]是回文，记录此时回文的长度以及起始位置</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; childLen)&#123;</span><br><span class="line">                    childLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin + childLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目如下：&quot;&gt;&lt;a href=&quot;#题目如下：&quot; class=&quot;headerlink&quot; title=&quot;题目如下：&quot;&gt;&lt;/a&gt;题目如下：&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之寻找两个正序数组的中位数</title>
    <link href="http://xiaobazeo.github.io/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://xiaobazeo.github.io/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2023-03-21T08:41:26.000Z</published>
    <updated>2023-08-03T02:21:49.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,3]</span>, nums2 = <span class="comment">[2]</span></span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = <span class="comment">[1,2,3]</span> ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 <span class="comment">(2 + 3)</span> / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>xxxxxxxxxx ​class Solution {    public int[] twoSum(int[] nums, int target) {        for(int i = 0;i&lt;nums.length;i++){            for(int j=i+1;j&lt;nums.length;j++){                if(nums[i]+nums[j]==target){                    return new int[]{i,j};                }            }        }         return new int[0];    }}Java []</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[m+n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            nums[i] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n; j++)&#123;</span><br><span class="line">            nums[nums1.length + j] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span>(nums.length % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[(m + n) / <span class="number">2</span> - <span class="number">1</span>] + nums[(m + n) / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[(m + n) / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法还在研究ing。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目如下：&quot;&gt;&lt;a href=&quot;#题目如下：&quot; class=&quot;headerlink&quot; title=&quot;题目如下：&quot;&gt;&lt;/a&gt;题目如下：&lt;/h2&gt;&lt;p&gt;给定两个大小分别为 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 的正序（从小到大）数组 &lt;cod</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之无重复字符的最长子串</title>
    <link href="http://xiaobazeo.github.io/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://xiaobazeo.github.io/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2023-03-19T10:02:35.000Z</published>
    <updated>2023-03-19T10:06:59.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下"></a>题目如下</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h2 id="题解如下："><a href="#题解如下：" class="headerlink" title="题解如下："></a>题解如下：</h2><p>主要用到的思想就是滑动窗口，通过HashMap集合的key值不可重复原理来判断是否遇到重复的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//考虑孔字符串的情况</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//统计最大的子串长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左指针指向子串的第一个字符index</span></span><br><span class="line">        <span class="comment">//以字符串的一个字符作为key,其对应的index作为value</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;<span class="comment">//判断是否i位置下的字符是否有对应的value，如果有那么就说明重复了，此时将左指针定位到对应的value下，因为对应的value保存的就是此时此字符的index</span></span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            <span class="comment">//此时最大的子串不重复长度就是i - left + 1(即此时正在扫描的子串长度) 和 maxLength(上一串扫描的子串长度) 二者最大值之一。</span></span><br><span class="line">            maxLength = Math.max(maxLength,i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目如下&quot;&gt;&lt;a href=&quot;#题目如下&quot; class=&quot;headerlink&quot; title=&quot;题目如下&quot;&gt;&lt;/a&gt;题目如下&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之两数相加</title>
    <link href="http://xiaobazeo.github.io/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://xiaobazeo.github.io/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2023-03-19T04:20:14.000Z</published>
    <updated>2023-08-03T02:21:21.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[2,4,3]</span>, l2 = <span class="comment">[5,6,4]</span></span><br><span class="line">输出：<span class="comment">[7,0,8]</span></span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[0]</span>, l2 = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">9,9,9,9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>], l2 = [<span class="number">9,9,9,9</span>]</span><br><span class="line">输出：[<span class="number">8,9,9,9</span>,<span class="number">0,0,0,1</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h2 id="题解如下："><a href="#题解如下：" class="headerlink" title="题解如下："></a>题解如下：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//进位数字</span></span><br><span class="line">        <span class="comment">//定义一个可移动的指针，用来指向存储两个数之和的位置</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">         <span class="comment">//定义一个新联表伪指针，用来指向头指针，返回结果</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="comment">//当l1 不等于null或l2 不等于空时，就进入循环</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果l1 不等于null时，就取他的值，等于null时，就赋值0，保持两个链表具有相同的位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="comment">//将两个链表的值，进行相加，并加上进位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + carry;</span><br><span class="line">            <span class="comment">//计算进位数</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//计算两个数的和，此时排除超过10的请况（大于10，取余数）</span></span><br><span class="line">            sum %= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//将求和数赋值给新链表的节点，</span></span><br><span class="line">            <span class="comment">//注意这个时候不能直接将sum赋值给cur.next = sum。这时候会报，类型不匹配。</span></span><br><span class="line">            <span class="comment">//所以这个时候要创一个新的节点，将值赋予节点</span></span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line">             <span class="comment">//将新链表的节点后移</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="comment">//当链表l1不等于null的时候，将l1 的节点后移</span></span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">null</span>)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果最后两个数，相加的时候有进位数的时候，就将进位数，赋予链表的新节点。</span></span><br><span class="line">        <span class="comment">//两数相加最多小于20，所以的的值最大只能时1</span></span><br><span class="line">            <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目如下：&quot;&gt;&lt;a href=&quot;#题目如下：&quot; class=&quot;headerlink&quot; title=&quot;题目如下：&quot;&gt;&lt;/a&gt;题目如下：&lt;/h2&gt;&lt;p&gt;给你两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表，表示两个非负的整数。它们每位数字都是按照 &lt;strong&gt;</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot开发规范(二)</title>
    <link href="http://xiaobazeo.github.io/2023/02/04/SpringBoot%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83-%E4%BA%8C/"/>
    <id>http://xiaobazeo.github.io/2023/02/04/SpringBoot%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83-%E4%BA%8C/</id>
    <published>2023-02-04T15:37:16.000Z</published>
    <updated>2023-08-03T02:19:28.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PO即persistant-Object-持久对象："><a href="#PO即persistant-Object-持久对象：" class="headerlink" title="PO即persistant Object 持久对象："></a><strong>PO即persistant Object 持久对象：</strong></h3><p>&emsp;在O/R 映射（即ORM-ObjectRelationMapping）中出现的概念，通常对应数据模型（数据库），是与数据库汇总的表想影射的java对象，最简单的PO就是对应数据库中某个表中的一条记录，多个记录则用PO的集合。PO中不应该包含任何对数据库的操作。</p><h3 id="DO即Domain-Object-领域对象："><a href="#DO即Domain-Object-领域对象：" class="headerlink" title="DO即Domain Object 领域对象："></a><strong>DO即Domain Object 领域对象：</strong></h3><p>&emsp;是从现实世界中抽象出来的有形或无形的业务实体。</p><h3 id="TO即Transfer-Object数据传输对象："><a href="#TO即Transfer-Object数据传输对象：" class="headerlink" title="TO即Transfer Object数据传输对象："></a><strong>TO即Transfer Object数据传输对象：</strong></h3><p>&emsp;不同应用程序之间传输的对象</p><h3 id="DTO即Data-Transfer-Object-数据传输对象："><a href="#DTO即Data-Transfer-Object-数据传输对象：" class="headerlink" title="DTO即Data Transfer Object:数据传输对象："></a><strong>DTO即Data Transfer Object:数据传输对象：</strong></h3><p>&emsp;泛指用于展示层与服务层之间的数据传输对象</p><h3 id="VO即value-Object："><a href="#VO即value-Object：" class="headerlink" title="VO即value Object："></a><strong>VO即value Object：</strong></h3><p>&emsp;通常用于业务层之间的数据传递，和PO一样仅包含数据，但是抽象出的业务对象，可以和表对应，用new 关键字创建，GC回收</p><h3 id="BO即Business-Object-业务对象"><a href="#BO即Business-Object-业务对象" class="headerlink" title="BO即Business Object 业务对象:"></a><strong>BO即Business Object 业务对象:</strong></h3><p>&emsp;主要是将业务逻辑封装为一个对象，这个对象可以包含一个或多个其他对象，如一个简历中包含教育经历、工作经历、社会关系等，可以将一个教育经历对应一个PO、工作经历对应一个PO、设计关系对应一个PO，然后简历一个对应简历的BO兑现处理简历，每个BO包含这个PO这样处理业务逻辑是，可以针对BO去处理。封装业务逻辑的java对象，通过调用DAO方法，结合PO,VO进行业务操作。</p><h3 id="POJO即Plain-Ordinary-Java-Object"><a href="#POJO即Plain-Ordinary-Java-Object" class="headerlink" title="POJO即Plain Ordinary Java Object:"></a><strong>POJO即Plain Ordinary Java Object:</strong></h3><p>&emsp;简单无规则的java对性，即在一些O/R 映射工具中，能做到维护数据库表记录的PO完全是一个符合Java Bean规范的纯java对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;PO即persistant-Object-持久对象：&quot;&gt;&lt;a href=&quot;#PO即persistant-Object-持久对象：&quot; class=&quot;headerlink&quot; title=&quot;PO即persistant Object 持久对象：&quot;&gt;&lt;/a&gt;&lt;strong&gt;</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="http://xiaobazeo.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之连续子数组的最大和</title>
    <link href="http://xiaobazeo.github.io/2023/02/02/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://xiaobazeo.github.io/2023/02/02/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</id>
    <published>2023-02-02T14:06:48.000Z</published>
    <updated>2023-08-03T02:21:48.141Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=cug7nw1"><em>剑指 Offer 42. 连续子数组的最大和</em></a></p><p>[TOC]</p><h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230202220726900.png"></p><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h3 id="1、动态规划"><a href="#1、动态规划" class="headerlink" title="1、动态规划"></a>1、动态规划</h3><h4 id="推想："><a href="#推想：" class="headerlink" title="推想："></a>推想：</h4><p>​    若nums数组的长度为n，下标则为0~n-1，用f(i)表示以第i个数结尾的<strong>连续子数组的最大和</strong>，故有：</p><p>​<br>$$<br>max{f(i)},0≤i≤n-1<br>$$</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>​    求出每段以第i个数结尾的子数组的f(i)，返回最大的f(i)即可</p><h4 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h4><p>​    考虑nums[i]单独成一段还是加入f(i-1)这一段子数组，则可以通过判断nums[i] + f(i-1)和nums[i]的大小实现</p><p>$$<br>f(i) = max{nums[i]+f(i-1),nums[i]}<br>$$</p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//存储f(i - 1)的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">           pre = Math.max(x + pre, x);</span><br><span class="line">           maxSum = Math.max(pre , maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、分治法："><a href="#2、分治法：" class="headerlink" title="2、分治法："></a>2、分治法：</h3><p>见<a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solutions/876881/lian-xu-zi-shu-zu-de-zui-da-he-by-leetco-tiui/">leetcode题解</a>(点击即可查看)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/?envType=study-plan&amp;id=lcof&amp;plan=lcof&amp;plan_progress=cug7nw1&quot;&gt;&lt;e</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>谈谈wx和wss</title>
    <link href="http://xiaobazeo.github.io/2023/02/02/%E8%B0%88%E8%B0%88wx%E5%92%8Cwss/"/>
    <id>http://xiaobazeo.github.io/2023/02/02/%E8%B0%88%E8%B0%88wx%E5%92%8Cwss/</id>
    <published>2023-02-02T12:21:50.000Z</published>
    <updated>2023-02-02T13:19:38.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="了解WS和WSS"><a href="#了解WS和WSS" class="headerlink" title="了解WS和WSS"></a>了解WS和WSS</h2><p>&emsp;WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。</p><p>&emsp;WebSocket建立在TCP之上，同HTTP一样通过TCP来传输数据，但是它和HTTP最大不同是：WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/Client Agent都能主动的向对方发送或接收数据，就像Socket一样；WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。</p><p>&emsp;WSS（Web Socket Secure）是WebSocket的加密版本。WS一般默认是80端口，而WSS默认是443端口，大多数网站用的就是80和433端口。（在高防防护过程中，80和433端口的网站是需要备案才可以接入国内的。）</p><p>&emsp;WS体现形式：<strong>TCP+WS AS WS 。</strong></p><p>&emsp;WSS体现形式：<strong>TCP+TLS+WS AS WS。</strong></p><p>&emsp;服务器网址就是 URL。</p><h2 id="WS-WSS出现的原因"><a href="#WS-WSS出现的原因" class="headerlink" title="WS/WSS出现的原因"></a>WS/WSS出现的原因</h2><p>&emsp;目前很多应用要求服务端有能力进行实时推送能力（例如直播间聊天室），以往很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。</p><p>​    这种传统的模式带来很明显的缺点，即浏览器需要不断地向服务器发出请求，但是HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽资源。</p><p>​    此时，WebSocket协议的出现，能更好地节省服务器资源和带宽，并且能够更实时地进行通讯。WebSocket实现了浏览器与服务器全双工（full-duplex）通信，允许服务器主动发送信息给客户端。</p><h2 id="WS特点"><a href="#WS特点" class="headerlink" title="WS特点"></a>WS特点</h2><ul><li>建立在 TCP 协议之上，服务端实现容易；</li><li>与 HTTP 协议有良好的兼容性，握手时不容易被屏蔽，可以通过各种 HTTP 代理服务器；</li><li>数据轻量，实时通讯；</li><li>可以发送文本和二进制数据；</li><li>不限制同源，客户端可以与任意服务器端进行通讯。</li></ul><h2 id="和http-https的关系"><a href="#和http-https的关系" class="headerlink" title="和http/https的关系"></a>和http/https的关系</h2><p>按照标准来是有如下对应关系的：</p><ul><li>http -&gt; new WebSocket(‘ws://xxx’)</li><li>https -&gt; new WebSocket(‘wss://xxx’)</li></ul><p>在https下应该使用wss协议做安全链接，且wss下不支持ip地址的写法，写成域名形式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;了解WS和WSS&quot;&gt;&lt;a href=&quot;#了解WS和WSS&quot; class=&quot;headerlink&quot; title=&quot;了解WS和WSS&quot;&gt;&lt;/a&gt;了解WS和WSS&lt;/h2&gt;&lt;p&gt;&amp;emsp;WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双</summary>
      
    
    
    
    
    <category term="计网" scheme="http://xiaobazeo.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://xiaobazeo.github.io/2023/02/01/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://xiaobazeo.github.io/2023/02/01/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2023-02-01T11:03:12.000Z</published>
    <updated>2023-08-03T02:26:41.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础（一）"><a href="#Java基础（一）" class="headerlink" title="Java基础（一）"></a>Java基础（一）</h2><h3 id="Java语言的特点："><a href="#Java语言的特点：" class="headerlink" title="Java语言的特点："></a>Java语言的特点：</h3><ul><li>简单易学</li><li>面向对象（封装、继承、多态）</li><li>平台无关性（Java虚拟机实现平台无关性）</li><li>支持多线程</li><li>可靠性</li><li>安全性</li><li>支持网络编程并且很方便</li><li>编译与解释并存</li></ul><h3 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a>什么是字节码？采用字节码的好处是什么？</h3><p>JVM可以理解的代码就是字节码（扩展名.class文件），JVM解释器进行对字节码的解释比较慢、引入了JIT编译器，JIT属于运行时编译，当JIT编译完成第一次编译之后，热点代码和方法的字节码对应机器码会被保存下来，下次可以直接进行使用，而不需要再次被解释器进行解释。</p><p>好处：</p><ul><li>面向虚拟机，不面向任何特定的处理器</li><li>通过字节码的方式，在一定程度上解决了传统解释性语言执行效率低的问题，同时又保留了解释型语言可移植的特点</li><li>字节码不针对某一特定机器，所以Java不需要重新编译就可以在不同的操作系统的计算机运行。</li></ul><h3 id="Java源码一次编写，为啥能到处运行？"><a href="#Java源码一次编写，为啥能到处运行？" class="headerlink" title="Java源码一次编写，为啥能到处运行？"></a>Java源码一次编写，为啥能到处运行？</h3><p>&emsp;JVM（Java虚拟机）是关键原因。</p><p>&emsp;<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230204194523252.png" alt="image-20230204194523252"></p><blockquote><p>注意：Java程序是跨平台的程序、JVM是C/C++开发的软件，不同平台下的JVM版本不一样</p></blockquote><h3 id="为什么说Java语言“编译与解释并存”？"><a href="#为什么说Java语言“编译与解释并存”？" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h3><blockquote><p><strong>编译型：</strong>编译型语言可以通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较开，开发效率比较低，常见的编译型语言就是C、C++、GO等</p><p><strong>解释型：</strong>通过解释器将代码一句句解释成机器代码，解释型语言开发快，执行速度慢，常见的解释型语言就是PHP、Python、JavaScript等。</p></blockquote><p>&ensp;因为Java要先通过javac编译器将程序编译成字节码(.class文件)，然后通过Java解释器来解释执行。</p><h3 id="一个Java程序可包含多个类吗？（内部类除外）"><a href="#一个Java程序可包含多个类吗？（内部类除外）" class="headerlink" title="一个Java程序可包含多个类吗？（内部类除外）"></a>一个Java程序可包含多个类吗？（内部类除外）</h3><p>&emsp;可以包含多个类，但是被public修饰的类只有一个，且被public修饰的这个类必须跟类文件名同名</p><h3 id="Java的访问权限：private、protected、default、public"><a href="#Java的访问权限：private、protected、default、public" class="headerlink" title="Java的访问权限：private、protected、default、public"></a>Java的访问权限：private、protected、default、public</h3><p>&emsp;private &lt; default &lt; protected &lt; public：从左到右权限依次变大</p><p>&emsp;对成员变量/成员方法而言：</p><p>&emsp;&emsp;1、private：仅限该类内部成员访问</p><p>&emsp;&emsp;2、default：同包下的其他类成员以及该类内部成员可以访问</p><p>&emsp;&emsp;3、protected：同包下的其他类成员、该类内部成员、以及子类可以访问。</p><p>&emsp;&emsp;4、public：任意包下的任意类的成员均可访问。</p><p>&emsp;修饰类时，仅有default、public两种修饰符：</p><p>&emsp;&emsp;1、default：同包下的其他类可以访问</p><p>&emsp;&emsp;2、public：任意包下的任意类可以访问</p><blockquote><p>注：没有任何修饰符修饰，默认为default</p></blockquote><h3 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h3><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230204213714958.png" alt="image-20230204213714958"></p><p>byte(1 byte = 8 bits)&emsp;&emsp;&emsp;&emsp;&emsp;short(2 byte = 16 bits)&emsp;&emsp;&emsp;&emsp;&emsp;int(4 byte = 32 bits)&emsp;&emsp;&emsp;&emsp;&emsp;long(8 byte = 64 bits)</p><p>float(4 byte = 32 bits)&emsp;&emsp;&emsp;&emsp;double(8 byte = 64bits)&emsp;&emsp;&emsp;&emsp;&emsp;char(2byte = 16bits)&emsp;&emsp;&emsp;&emsp;&emsp;boolean(根据Java规范规定，不同JVM实现机制不同)</p><table><thead><tr><th>分类</th><th>关键字</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td>类、方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p><ul><li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li><li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li><li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li></ul></blockquote><h3 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h3><p>这个需要结合 JVM 的相关知识，主要原因如下：</p><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol><h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><p><strong>1、调用方式</strong></p><p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p><p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staicMethod</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 调用实例方法</span></span><br><span class="line">        person.method();</span><br><span class="line">        <span class="comment">// 调用静态方法</span></span><br><span class="line">        Person.staicMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、访问类成员是否存在限制</strong></p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p><h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><ul><li>成员变量包装类型不赋值就<strong>是 <code>null</code></strong> ，而基本类型**有默认值且不是 <code>null</code>**。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的<strong>局部变量</strong>存放在 Java 虚拟机<strong>栈</strong>中的局部变量表中，基本数据类型的<strong>成员变量（未被 <code>static</code> 修饰 ）</strong>存放在 Java 虚拟机的<strong>堆</strong>中。包装类型属于对象类型，我们知道<strong>几乎所有对象实例都存在于堆中</strong>。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>⚠️ 注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果<strong>没有</strong>被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicTypeVar</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆区、栈区、方法区的区别："><a href="#堆区、栈区、方法区的区别：" class="headerlink" title="堆区、栈区、方法区的区别："></a>堆区、栈区、方法区的区别：</h3><p><strong>堆区:</strong> </p><p>1、存储的全部是对象 ，每个对象都包含一个与之对应的Class的信息。(Class的目的是得到操作指令) </p><p>2、JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 ，即实例对象</p><p><strong>栈区:</strong> </p><p>1、每个线程包含一个栈区 ，栈中 只保存基础数据类型的对象和自定义对象的引用(不是对象) ，对象都存放在堆区中 </p><p>2、每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问 。 </p><p>3、栈分为3个部分： 基本类型变量区、执行环境上下文、操作指令区(存放操作指令) 。 </p><p><strong>方法区:</strong> </p><p>1、又叫 静态区 ，跟堆一样， 被所有的线程共享 。方法区 包含所有的Class和static变量 。</p><p>2、方法区中包含的都是在整个程序中永远唯一的元素，如Class，static变量。</p><h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h3><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p><strong>Integer 缓存源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Character</code> 缓存源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Boolean</code> 缓存源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><p><strong>OS:所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p><h3 id="自动拆箱和自动装箱，原理是什么？"><a href="#自动拆箱和自动装箱，原理是什么？" class="headerlink" title="自动拆箱和自动装箱，原理是什么？"></a>自动拆箱和自动装箱，原理是什么？</h3><ul><li>拆箱：将包装类型转换成基本数据类型</li><li>装箱：将基本数据类型用对应的引用类型（包装类型）包装起来</li></ul><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">L1</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">8</span> L1</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> BIPUSH <span class="number">10</span></span><br><span class="line"></span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line">L2</span><br><span class="line"></span><br><span class="line"> LINENUMBER <span class="number">9</span> L2</span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> ALOAD <span class="number">0</span></span><br><span class="line"></span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line"></span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line"></span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line"></span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure><p>装箱其实就是调用了包装类的<strong>valueOf()<strong>方法，</strong>拆箱</strong>其实就是调用了**xxxValue()**方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; =====&gt; <span class="type">Integer</span>  <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>)</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;  ======&gt;  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java基础（一）&quot;&gt;&lt;a href=&quot;#Java基础（一）&quot; class=&quot;headerlink&quot; title=&quot;Java基础（一）&quot;&gt;&lt;/a&gt;Java基础（一）&lt;/h2&gt;&lt;h3 id=&quot;Java语言的特点：&quot;&gt;&lt;a href=&quot;#Java语言的特点：&quot; cla</summary>
      
    
    
    
    
    <category term="Java基础" scheme="http://xiaobazeo.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot开发规范（一）</title>
    <link href="http://xiaobazeo.github.io/2022/11/21/springboot-levelFunction/"/>
    <id>http://xiaobazeo.github.io/2022/11/21/springboot-levelFunction/</id>
    <published>2022-11-21T11:52:29.000Z</published>
    <updated>2023-08-03T02:19:24.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="model（entity）"><a href="#model（entity）" class="headerlink" title="model（entity）"></a>model（entity）</h2><p>​        model是模型的意思，与entity、domain、pojo类似，是存放实体的类，类中定义了多个类属性，并与数据库表的字段保持一致，一张表对应一个model类。 主要用于定义与数据库对象应的属性，提供get/set方法,tostring方法,有参无参构造函数。</p><h2 id="dao（mapper）"><a href="#dao（mapper）" class="headerlink" title="dao（mapper）"></a>dao（mapper）</h2><p>​        又被成为mapper层，叫数据持久层，先设计接口，然后在配置文件中进行配置其实现的关联。 dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。 数据持久化操作就是指，把数据放到持久化的介质中，同时提供增删改查操作，比如数据通过hibernate插入到数据库中</p><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>​        业务逻辑层，完成功能的设计 和dao层一样都是先设计接口，再创建要实现的类，然后在配置文件中进行配置其实现的关联。接下来就可以在service层调用dao层的接口进行业务逻辑应用的处理。 service的impl是把mapper和service进行整合的文件 封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。</p><h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>​        控制层，控制业务逻辑service，控制请求和响应，负责前后端交互 controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/2052481-20210417164128180-1418412203.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;model（entity）&quot;&gt;&lt;a href=&quot;#model（entity）&quot; class=&quot;headerlink&quot; title=&quot;model（entity）&quot;&gt;&lt;/a&gt;model（entity）&lt;/h2&gt;&lt;p&gt;​        model是模型的意思，与enti</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="http://xiaobazeo.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之回文数</title>
    <link href="http://xiaobazeo.github.io/2022/10/27/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://xiaobazeo.github.io/2022/10/27/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E5%9B%9E%E6%96%87%E6%95%B0/</id>
    <published>2022-10-27T08:32:30.000Z</published>
    <updated>2023-08-03T02:20:30.162Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/palindrome-number/description/">9. 回文数</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>看到这题的第一想法就是把数字x进行反转得到数字reverse，然后与x进行比较是否相等即可，刚开始我想的是把数字转成字符串然后使用反转函数直接反转，最后使用eqauls方法进行比较即可，但是我忘记了怎么将数字转换成String类型的字符串。后来遍知道一个数一个数字进行翻转</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>由题可知x&lt;0的时候因为含有负号，故所有小于0的数都不是回文数，直接return false即可，x&gt;0的时候，我用一个temp表示x翻转后的数字，num用于x逐一翻转，直到num/10==0的时候说明翻转完成，得到的结果return num == x的结果即可。</p></blockquote><p>但是，看了题解之后我发现其实翻转一半就行了，就算是奇数个位数，最后return reverse/10 == x即可</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>O(logn)</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>O(1)</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> x;</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">                temp = temp*<span class="number">10</span>+num%<span class="number">10</span>;</span><br><span class="line">                num = num/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x == temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">revertedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/palindrome-number/solutions/281686/hui-wen-shu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/palindrome-number/description/&quot;&gt;9. 回文数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
