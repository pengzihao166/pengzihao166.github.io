<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HUT菜鸟小八的博客</title>
  
  
  <link href="http://xiaobazeo.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaobazeo.github.io/"/>
  <updated>2023-05-16T07:28:46.505Z</updated>
  <id>http://xiaobazeo.github.io/</id>
  
  <author>
    <name>xiaoba</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>备份hexo-_o-U盘篇</title>
    <link href="http://xiaobazeo.github.io/2023/05/16/%E5%A4%87%E4%BB%BDhexo-o-U%E7%9B%98%E7%AF%87/"/>
    <id>http://xiaobazeo.github.io/2023/05/16/%E5%A4%87%E4%BB%BDhexo-o-U%E7%9B%98%E7%AF%87/</id>
    <published>2023-05-16T07:06:32.000Z</published>
    <updated>2023-05-16T07:28:46.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新机环境搭建"><a href="#新机环境搭建" class="headerlink" title="新机环境搭建"></a>新机环境搭建</h2><p>​    1、安装Node.js</p><p>​    2、安装Git</p><p>​    3、新建存放Blog的文件夹</p><h2 id="拷贝旧机器中得文件-文件夹"><a href="#拷贝旧机器中得文件-文件夹" class="headerlink" title="拷贝旧机器中得文件/文件夹"></a>拷贝旧机器中得文件/文件夹</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line"><span class="keyword">package</span>.json</span><br><span class="line">scaffolds/</span><br><span class="line"><span class="keyword">source</span>/</span><br><span class="line">themes/</span><br><span class="line">其中/代表拷贝的是文件夹</span><br></pre></td></tr></table></figure><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>右键打开Git bash，依次输入下列命令之后，安装相关依赖</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>安装hexo</span><br><span class="line">   <span class="built_in">npm</span> install -g hexo</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>本地测试的时候需要用hexo server</span><br><span class="line">   <span class="built_in">npm</span> i hexo-server</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>将文章部署到github上的模块</span><br><span class="line">   <span class="built_in">npm</span> install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>安装RSS插件</span><br><span class="line">   <span class="built_in">npm</span> install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>添加Sitemap,加速网页收录速度</span><br><span class="line">   <span class="built_in">npm</span> install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><h2 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo s -g == hexo g + hexo s</span><br></pre></td></tr></table></figure><p>在浏览器打开<a href="http://localhost:4000/">http://localhost:4000</a>查看效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新机环境搭建&quot;&gt;&lt;a href=&quot;#新机环境搭建&quot; class=&quot;headerlink&quot; title=&quot;新机环境搭建&quot;&gt;&lt;/a&gt;新机环境搭建&lt;/h2&gt;&lt;p&gt;​    1、安装Node.js&lt;/p&gt;
&lt;p&gt;​    2、安装Git&lt;/p&gt;
&lt;p&gt;​    3、新建存</summary>
      
    
    
    
    
    <category term="备份" scheme="http://xiaobazeo.github.io/tags/%E5%A4%87%E4%BB%BD/"/>
    
  </entry>
  
  <entry>
    <title>网络基础篇</title>
    <link href="http://xiaobazeo.github.io/2023/05/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://xiaobazeo.github.io/2023/05/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/</id>
    <published>2023-05-15T18:25:03.000Z</published>
    <updated>2023-05-16T08:27:01.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP网络模型有哪几层？"><a href="#TCP-IP网络模型有哪几层？" class="headerlink" title="TCP/IP网络模型有哪几层？"></a>TCP/IP网络模型有哪几层？</h2><h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><p>&emsp;&emsp;用户直接接触到的就是<strong>应用层</strong>，应用层专注于用户提供应用功能，例如：HTTP、FTP、DNS、Telnet、SMTP等。</p><p>&emsp;&emsp;应用层工作在操作系统中得<strong>用户态</strong>，<strong>传输层及以下</strong>则工作在<strong>内核态</strong>。</p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>&emsp;&emsp;应用层的数据包会传给传输层，传输层是为应用层提供网络支持。传输层的两个协议：<strong>TCP</strong>和<strong>UDP</strong>。</p><p>&emsp;&emsp;TCP（传输控制协议），TCP相较于UDP的特性，比如：<strong>流量控制，超时重传，拥塞控制</strong>等，为了保证数据包能可靠的传输给对方。</p><p>&emsp;&emsp;UDP只负责发送数据包，<strong>不保证</strong>数据包是否能抵达对方，但是<strong>实时性</strong>相对较好，<strong>传输效率</strong>也较高。如果要实现UDP的可靠传输，可以把TCP的特性在应用层实现。</p><p>&emsp;&emsp;应用传输数据过大，传输层的数据包大小超过MSS(TCP最大报文段长度)，需要将数据包分块，如果中途有一个分块丢失或损坏，只需重新发送此分块即可，而不需要发送整个数据包。在TCP协议中，<strong>每个分块称为一个TCP段</strong>（TCP Segment）。</p><p>&emsp;&emsp;传输层负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，此时需要用一个编号将应用区分开，这个编号就是端口。例如：Web服务器通常使用80端口，22端口通常是远程登录服务器的端口。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>&emsp;&emsp;实现传输功能的是<strong>网络层</strong>，传输层只是作为数据传输的媒介，帮助应用到应用的通信。</p><p>&emsp;&emsp;常见协议是IP协议（Internet Protocol），IP协议会将传输层的报文作为数据部分，再加上IP包头部组装成IP报文，如果IP报文大小超过MTU（一般默认1500Bytes）会<strong>再次进行分片</strong>，得到一个即将发送的到网络的IP报文。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/12.jpg" alt="选自小林coding"></p><h4 id="IP协议寻址功能："><a href="#IP协议寻址功能：" class="headerlink" title="IP协议寻址功能："></a>IP协议寻址功能：</h4><p>&emsp;&emsp;由于网络层需要有区分设备的编号，一般使用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分为四段（比如：192.168.100.1），每段8位。由于IPv4地址有设备上限，无法做到一个设备一个IP地址，所以会将IP地址分成两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该IP地址是属于哪个<strong>子网</strong>的</li><li>一个是<strong>主机号</strong>，负责标识<strong>同一子网</strong>下的<strong>不同主机</strong></li></ul><p>此时需要<strong>子网掩码</strong>才能计算出IP地址的网络号和主机号，比如：10.100.122.0/24，后面的/24表示就是255.255.255.0子网掩码，255.255.255.0二进制就是11111111-11111111-11111111-00000000，24个1，为了简化子网掩码的表示，就会用/24代替255.255.255.0</p><p><strong>网络号</strong>将 10.100.122.2 和 255.255.255.0 <strong>按位与运算</strong>。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/16.jpg" alt="取自小林coding"></p><p><strong>主机号：</strong>将 255.255.255.0 <strong>取反</strong>后与IP地址进行进行<strong>按位与运算</strong>。</p><p>在寻址过程中，先匹配相同的网络号（表示要找到同一个子网），才会去找对应的主机号。</p><h4 id="IP协议路由功能"><a href="#IP协议路由功能" class="headerlink" title="IP协议路由功能"></a>IP协议路由功能</h4><p>当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。</p><p>IP协议的寻址是告诉我们去往下一个目的地朝哪个方向走，路由是根据下一个目的地选择路径。</p><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>网络接口层会在IP头部的前面加上MAC头部，并封装成数据帧发送到网络上。网络接口层主要是为网络层提供链路级别传输的服务，负责以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址来表示网络上的设备。</p><p>MAC头部是以以太网的头部，包含了接收方和发送方的MAC地址等信息，可以通过ARP协议获取对方的MAC地址。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络接口层的传输单位是帧，IP的传输单位是包，TCP层传输单位是段，HTTP传输单位是消息或报文，每一层的封装格式如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="取自小林coding"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TCP-IP网络模型有哪几层？&quot;&gt;&lt;a href=&quot;#TCP-IP网络模型有哪几层？&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP网络模型有哪几层？&quot;&gt;&lt;/a&gt;TCP/IP网络模型有哪几层？&lt;/h2&gt;&lt;h3 id=&quot;应用层：&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="计网" scheme="http://xiaobazeo.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>法大大（一面） 2023.4.6</title>
    <link href="http://xiaobazeo.github.io/2023/04/06/%E6%B3%95%E5%A4%A7%E5%A4%A7-%E4%B8%80%E9%9D%A2/"/>
    <id>http://xiaobazeo.github.io/2023/04/06/%E6%B3%95%E5%A4%A7%E5%A4%A7-%E4%B8%80%E9%9D%A2/</id>
    <published>2023-04-06T13:51:08.000Z</published>
    <updated>2023-04-06T14:26:41.963Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E6%B3%95%E5%A4%A7%E5%A4%A7(2023.4.6).png" alt="法大大(2023.4.6)"></p><h2 id="总结：（答得不是很完善的地方总结一下）"><a href="#总结：（答得不是很完善的地方总结一下）" class="headerlink" title="总结：（答得不是很完善的地方总结一下）"></a>总结：（答得不是很完善的地方总结一下）</h2><h3 id="接口和抽象类的共同点和区别："><a href="#接口和抽象类的共同点和区别：" class="headerlink" title="接口和抽象类的共同点和区别："></a>接口和抽象类的共同点和区别：</h3><p><strong>共同点：</strong> </p><ul><li>不可以被实例化</li><li>可以包含抽象方法</li><li>可以有默认的实现方法</li></ul><p><strong>区别：</strong></p><ul><li>接口对类的行为进行约束，实现某接口已经拥有了的具体行为，抽象类代码复用，强调的是从属关系</li><li>接口的成员变量只能用public static final修饰且不可修改并初始化，抽象类默认是default类型，可以在子类被重新定义且重新赋值</li><li>一个类只能继承一个抽象类（单继承），可实现多个接口。</li></ul><h3 id="和-equals-方法"><a href="#和-equals-方法" class="headerlink" title="== 和 equals()方法"></a>== 和 equals()方法</h3><p><strong>== 两种情况：</strong></p><ul><li>对于基本数据类型，直接比较值的大小</li><li>对于引用类型，比较对象的内存地址</li></ul><p><strong>equals（）方法：</strong></p><p>比较对象是否相等，即对象的内存地址是否相等，一般也分为两种情况</p><ul><li>重写了，一般比较两个对象的成员属性是否相等</li><li>未重写，比较的该类型的对象是否相等</li></ul><h3 id="try-catch-finally方法"><a href="#try-catch-finally方法" class="headerlink" title="try-catch-finally方法"></a>try-catch-finally方法</h3><ul><li>如果在catch中return了，那么finally里面的逻辑会在return之前被执行。</li><li>如果catch和finally都有return，那么catch的return会被忽略，</li><li>因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</li><li>finally一般用于资源回收、比如线程、数据库资源回收的情况</li></ul><h3 id="HashMap和HashSet区别"><a href="#HashMap和HashSet区别" class="headerlink" title="HashMap和HashSet区别"></a>HashMap和HashSet区别</h3><ul><li>前者实现了Map接口，后者实现了Set接口</li><li>HashSet底层是HashMap实现存储的</li></ul><h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><ul><li>前者继承了AbstractMap类，后者继承了Dictionary类</li><li>HashMap线程不安全，HashTable线程安全</li><li>contains不一样，HashMap没有contains方法只有containsValue和containsKey方法，但是HashTable这三个方法都有</li><li>key-value是否能为null，HashMap 都可以为null，HashTable都不可以null，否则就是空指针异常</li><li>获取hashCode方法不一样</li></ul><p>&emsp;&emsp;HashMap先调用hashCode获取到了hash值之后，再与右移16位的hash值相异或获取hash值。</p><p>&emsp;&emsp;HashTable直接通过hashCode方法获取</p><ul><li>解决hash冲突方法不一样</li></ul><p>&emsp;&emsp;HashMap通过数组+链表/红黑树，如果链表长度大于8，变成红黑树，若链表长度后面小于6，转回链表格式</p><p>&emsp;&emsp;HashTable只有链表存储</p><h3 id="项目介绍："><a href="#项目介绍：" class="headerlink" title="项目介绍："></a>项目介绍：</h3><p>因为主要是自己写的、在redis那一块也比较熟悉，也自己解决了缓存雪崩的问题，后面也解决了缓存和数据库一致性问题，但是面试的时候忘记提了，可能提了会更加加分~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/%E6%B3%95%E5%A4%A7%E5%A4%A7(2023.4.6).png&quot; alt=&quot;法大大(2023.4.6)&quot;&gt;&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    
    <category term="程序人生" scheme="http://xiaobazeo.github.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    <category term="面经" scheme="http://xiaobazeo.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之最长回文子串</title>
    <link href="http://xiaobazeo.github.io/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://xiaobazeo.github.io/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2023-03-21T08:46:39.000Z</published>
    <updated>2023-03-21T08:51:52.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbbd&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><h2 id="题解如下"><a href="#题解如下" class="headerlink" title="题解如下"></a>题解如下</h2><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230321164819370.png" alt="image-20230321164819370"></p><h5 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">boolean</span> [][]dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">//所有的一个字符的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">//记录回文子串的初始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录回文子串长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">childLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span>; l &lt;= len;l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">                <span class="comment">//j代表子串的尾字符的index，即确定右边界</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果尾字符超出字符串最大长度、跳出循环</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= len)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(charArray[i]!=charArray[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//可能是一个或者两个或者三个字符的子串</span></span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则就依次递归</span></span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//若 dp[i][l] == true 成立，就表示s[i....l]是回文，记录此时回文的长度以及起始位置</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; childLen)&#123;</span><br><span class="line">                    childLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin,begin + childLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目如下：&quot;&gt;&lt;a href=&quot;#题目如下：&quot; class=&quot;headerlink&quot; title=&quot;题目如下：&quot;&gt;&lt;/a&gt;题目如下：&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之寻找两个正序数组的中位数</title>
    <link href="http://xiaobazeo.github.io/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://xiaobazeo.github.io/2023/03/21/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</id>
    <published>2023-03-21T08:41:26.000Z</published>
    <updated>2023-03-21T08:46:03.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = <span class="comment">[1,3]</span>, nums2 = <span class="comment">[2]</span></span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = <span class="comment">[1,2,3]</span> ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="symbol">nums1</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="symbol">nums2</span> = [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2.50000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，中位数 <span class="comment">(2 + 3)</span> / <span class="number">2</span> = <span class="number">2.5</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>方法1：合并数组之后直接使用Arrays.sort()进行排序，最后返回中位数即可，若为奇数则返回(nums1.length + nums2.length)  / 2的值，偶数则返回(nums2.length + nums2.length) / 2 - 1和(nums1.length + nums2.length) / 2之和的平均数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[m+n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            nums[i] = nums1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n; j++)&#123;</span><br><span class="line">            nums[nums1.length + j] = nums2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span>(nums.length % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (nums[(m + n) / <span class="number">2</span> - <span class="number">1</span>] + nums[(m + n) / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[(m + n) / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法还在研究ing。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目如下：&quot;&gt;&lt;a href=&quot;#题目如下：&quot; class=&quot;headerlink&quot; title=&quot;题目如下：&quot;&gt;&lt;/a&gt;题目如下：&lt;/h2&gt;&lt;p&gt;给定两个大小分别为 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 的正序（从小到大）数组 &lt;cod</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之无重复字符的最长子串</title>
    <link href="http://xiaobazeo.github.io/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://xiaobazeo.github.io/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2023-03-19T10:02:35.000Z</published>
    <updated>2023-03-19T10:06:59.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目如下"><a href="#题目如下" class="headerlink" title="题目如下"></a>题目如下</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h2 id="题解如下："><a href="#题解如下：" class="headerlink" title="题解如下："></a>题解如下：</h2><p>主要用到的思想就是滑动窗口，通过HashMap集合的key值不可重复原理来判断是否遇到重复的字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//考虑孔字符串的情况</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//统计最大的子串长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左指针指向子串的第一个字符index</span></span><br><span class="line">        <span class="comment">//以字符串的一个字符作为key,其对应的index作为value</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;<span class="comment">//判断是否i位置下的字符是否有对应的value，如果有那么就说明重复了，此时将左指针定位到对应的value下，因为对应的value保存的就是此时此字符的index</span></span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            <span class="comment">//此时最大的子串不重复长度就是i - left + 1(即此时正在扫描的子串长度) 和 maxLength(上一串扫描的子串长度) 二者最大值之一。</span></span><br><span class="line">            maxLength = Math.max(maxLength,i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目如下&quot;&gt;&lt;a href=&quot;#题目如下&quot; class=&quot;headerlink&quot; title=&quot;题目如下&quot;&gt;&lt;/a&gt;题目如下&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之两数相加</title>
    <link href="http://xiaobazeo.github.io/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://xiaobazeo.github.io/2023/03/19/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2023-03-19T04:20:14.000Z</published>
    <updated>2023-03-19T04:25:12.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[2,4,3]</span>, l2 = <span class="comment">[5,6,4]</span></span><br><span class="line">输出：<span class="comment">[7,0,8]</span></span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[0]</span>, l2 = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">9,9,9,9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>], l2 = [<span class="number">9,9,9,9</span>]</span><br><span class="line">输出：[<span class="number">8,9,9,9</span>,<span class="number">0,0,0,1</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h2 id="题解如下："><a href="#题解如下：" class="headerlink" title="题解如下："></a>题解如下：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//进位数字</span></span><br><span class="line">        <span class="comment">//定义一个可移动的指针，用来指向存储两个数之和的位置</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">         <span class="comment">//定义一个新联表伪指针，用来指向头指针，返回结果</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="comment">//当l1 不等于null或l2 不等于空时，就进入循环</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果l1 不等于null时，就取他的值，等于null时，就赋值0，保持两个链表具有相同的位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="comment">//将两个链表的值，进行相加，并加上进位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x1 + x2 + carry;</span><br><span class="line">            <span class="comment">//计算进位数</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//计算两个数的和，此时排除超过10的请况（大于10，取余数）</span></span><br><span class="line">            sum %= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//将求和数赋值给新链表的节点，</span></span><br><span class="line">            <span class="comment">//注意这个时候不能直接将sum赋值给cur.next = sum。这时候会报，类型不匹配。</span></span><br><span class="line">            <span class="comment">//所以这个时候要创一个新的节点，将值赋予节点</span></span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);</span><br><span class="line">             <span class="comment">//将新链表的节点后移</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="comment">//当链表l1不等于null的时候，将l1 的节点后移</span></span><br><span class="line">            <span class="keyword">if</span>(l1!=<span class="literal">null</span>)&#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果最后两个数，相加的时候有进位数的时候，就将进位数，赋予链表的新节点。</span></span><br><span class="line">        <span class="comment">//两数相加最多小于20，所以的的值最大只能时1</span></span><br><span class="line">            <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目如下：&quot;&gt;&lt;a href=&quot;#题目如下：&quot; class=&quot;headerlink&quot; title=&quot;题目如下：&quot;&gt;&lt;/a&gt;题目如下：&lt;/h2&gt;&lt;p&gt;给你两个 &lt;strong&gt;非空&lt;/strong&gt; 的链表，表示两个非负的整数。它们每位数字都是按照 &lt;strong&gt;</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot开发规范(二)</title>
    <link href="http://xiaobazeo.github.io/2023/02/04/SpringBoot%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83-%E4%BA%8C/"/>
    <id>http://xiaobazeo.github.io/2023/02/04/SpringBoot%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83-%E4%BA%8C/</id>
    <published>2023-02-04T15:37:16.000Z</published>
    <updated>2023-02-04T15:39:01.276Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PO即persistant-Object-持久对象："><a href="#PO即persistant-Object-持久对象：" class="headerlink" title="PO即persistant Object 持久对象："></a><strong>PO即persistant Object 持久对象：</strong></h3><p>&emsp;在O/R 映射（即ORM-ObjectRelationMapping）中出现的概念，通常对应数据模型（数据库），是与数据库汇总的表想影射的java对象，最简单的PO就是对应数据库中某个表中的一条记录，多个记录则用PO的集合。PO中不应该包含任何对数据库的操作。</p><h3 id="DO即Domain-Object-领域对象："><a href="#DO即Domain-Object-领域对象：" class="headerlink" title="DO即Domain Object 领域对象："></a><strong>DO即Domain Object 领域对象：</strong></h3><p>&emsp;是从现实世界中抽象出来的有形或无形的业务实体。</p><h3 id="TO即Transfer-Object数据传输对象："><a href="#TO即Transfer-Object数据传输对象：" class="headerlink" title="TO即Transfer Object数据传输对象："></a><strong>TO即Transfer Object数据传输对象：</strong></h3><p>&emsp;不同应用程序之间传输的对象</p><h3 id="DTO即Data-Transfer-Object-数据传输对象："><a href="#DTO即Data-Transfer-Object-数据传输对象：" class="headerlink" title="DTO即Data Transfer Object:数据传输对象："></a><strong>DTO即Data Transfer Object:数据传输对象：</strong></h3><p>&emsp;泛指用于展示层与服务层之间的数据传输对象</p><h3 id="VO即value-Object："><a href="#VO即value-Object：" class="headerlink" title="VO即value Object："></a><strong>VO即value Object：</strong></h3><p>&emsp;通常用于业务层之间的数据传递，和PO一样仅包含数据，但是抽象出的业务对象，可以和表对应，用new 关键字创建，GC回收</p><h3 id="BO即Business-Object-业务对象"><a href="#BO即Business-Object-业务对象" class="headerlink" title="BO即Business Object 业务对象:"></a><strong>BO即Business Object 业务对象:</strong></h3><p>&emsp;主要是将业务逻辑封装为一个对象，这个对象可以包含一个或多个其他对象，如一个简历中包含教育经历、工作经历、社会关系等，可以将一个教育经历对应一个PO、工作经历对应一个PO、设计关系对应一个PO，然后简历一个对应简历的BO兑现处理简历，每个BO包含这个PO这样处理业务逻辑是，可以针对BO去处理。封装业务逻辑的java对象，通过调用DAO方法，结合PO,VO进行业务操作。</p><h3 id="POJO即Plain-Ordinary-Java-Object"><a href="#POJO即Plain-Ordinary-Java-Object" class="headerlink" title="POJO即Plain Ordinary Java Object:"></a><strong>POJO即Plain Ordinary Java Object:</strong></h3><p>&emsp;简单无规则的java对性，即在一些O/R 映射工具中，能做到维护数据库表记录的PO完全是一个符合Java Bean规范的纯java对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;PO即persistant-Object-持久对象：&quot;&gt;&lt;a href=&quot;#PO即persistant-Object-持久对象：&quot; class=&quot;headerlink&quot; title=&quot;PO即persistant Object 持久对象：&quot;&gt;&lt;/a&gt;&lt;strong&gt;</summary>
      
    
    
    
    
    <category term="SpringBoot开发规范" scheme="http://xiaobazeo.github.io/tags/SpringBoot%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-连续子数组的最大和</title>
    <link href="http://xiaobazeo.github.io/2023/02/02/%E5%89%91%E6%8C%87offer-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>http://xiaobazeo.github.io/2023/02/02/%E5%89%91%E6%8C%87offer-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</id>
    <published>2023-02-02T14:06:48.000Z</published>
    <updated>2023-02-02T14:25:05.835Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=cug7nw1"><em>剑指 Offer 42. 连续子数组的最大和</em></a></p><p>[TOC]</p><h2 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h2><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230202220726900.png"></p><h2 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h2><h3 id="1、动态规划"><a href="#1、动态规划" class="headerlink" title="1、动态规划"></a>1、动态规划</h3><h4 id="推想："><a href="#推想：" class="headerlink" title="推想："></a>推想：</h4><p>​    若nums数组的长度为n，下标则为0~n-1，用f(i)表示以第i个数结尾的<strong>连续子数组的最大和</strong>，故有：</p><p>​<br>$$<br>max{f(i)},0≤i≤n-1<br>$$</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>​    求出每段以第i个数结尾的子数组的f(i)，返回最大的f(i)即可</p><h4 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h4><p>​    考虑nums[i]单独成一段还是加入f(i-1)这一段子数组，则可以通过判断nums[i] + f(i-1)和nums[i]的大小实现</p><p>$$<br>f(i) = max{nums[i]+f(i-1),nums[i]}<br>$$</p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//存储f(i - 1)的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">           pre = Math.max(x + pre, x);</span><br><span class="line">           maxSum = Math.max(pre , maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、分治法："><a href="#2、分治法：" class="headerlink" title="2、分治法："></a>2、分治法：</h3><p>见<a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solutions/876881/lian-xu-zi-shu-zu-de-zui-da-he-by-leetco-tiui/">leetcode题解</a>(点击即可查看)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/?envType=study-plan&amp;id=lcof&amp;plan=lcof&amp;plan_progress=cug7nw1&quot;&gt;&lt;e</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>谈谈wx和wss</title>
    <link href="http://xiaobazeo.github.io/2023/02/02/%E8%B0%88%E8%B0%88wx%E5%92%8Cwss/"/>
    <id>http://xiaobazeo.github.io/2023/02/02/%E8%B0%88%E8%B0%88wx%E5%92%8Cwss/</id>
    <published>2023-02-02T12:21:50.000Z</published>
    <updated>2023-02-02T13:19:38.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="了解WS和WSS"><a href="#了解WS和WSS" class="headerlink" title="了解WS和WSS"></a>了解WS和WSS</h2><p>&emsp;WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。</p><p>&emsp;WebSocket建立在TCP之上，同HTTP一样通过TCP来传输数据，但是它和HTTP最大不同是：WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/Client Agent都能主动的向对方发送或接收数据，就像Socket一样；WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。</p><p>&emsp;WSS（Web Socket Secure）是WebSocket的加密版本。WS一般默认是80端口，而WSS默认是443端口，大多数网站用的就是80和433端口。（在高防防护过程中，80和433端口的网站是需要备案才可以接入国内的。）</p><p>&emsp;WS体现形式：<strong>TCP+WS AS WS 。</strong></p><p>&emsp;WSS体现形式：<strong>TCP+TLS+WS AS WS。</strong></p><p>&emsp;服务器网址就是 URL。</p><h2 id="WS-WSS出现的原因"><a href="#WS-WSS出现的原因" class="headerlink" title="WS/WSS出现的原因"></a>WS/WSS出现的原因</h2><p>&emsp;目前很多应用要求服务端有能力进行实时推送能力（例如直播间聊天室），以往很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。</p><p>​    这种传统的模式带来很明显的缺点，即浏览器需要不断地向服务器发出请求，但是HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽资源。</p><p>​    此时，WebSocket协议的出现，能更好地节省服务器资源和带宽，并且能够更实时地进行通讯。WebSocket实现了浏览器与服务器全双工（full-duplex）通信，允许服务器主动发送信息给客户端。</p><h2 id="WS特点"><a href="#WS特点" class="headerlink" title="WS特点"></a>WS特点</h2><ul><li>建立在 TCP 协议之上，服务端实现容易；</li><li>与 HTTP 协议有良好的兼容性，握手时不容易被屏蔽，可以通过各种 HTTP 代理服务器；</li><li>数据轻量，实时通讯；</li><li>可以发送文本和二进制数据；</li><li>不限制同源，客户端可以与任意服务器端进行通讯。</li></ul><h2 id="和http-https的关系"><a href="#和http-https的关系" class="headerlink" title="和http/https的关系"></a>和http/https的关系</h2><p>按照标准来是有如下对应关系的：</p><ul><li>http -&gt; new WebSocket(‘ws://xxx’)</li><li>https -&gt; new WebSocket(‘wss://xxx’)</li></ul><p>在https下应该使用wss协议做安全链接，且wss下不支持ip地址的写法，写成域名形式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;了解WS和WSS&quot;&gt;&lt;a href=&quot;#了解WS和WSS&quot; class=&quot;headerlink&quot; title=&quot;了解WS和WSS&quot;&gt;&lt;/a&gt;了解WS和WSS&lt;/h2&gt;&lt;p&gt;&amp;emsp;WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双</summary>
      
    
    
    
    
    <category term="计网" scheme="http://xiaobazeo.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://xiaobazeo.github.io/2023/02/01/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://xiaobazeo.github.io/2023/02/01/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2023-02-01T11:03:12.000Z</published>
    <updated>2023-05-20T05:35:06.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java基础（一）"><a href="#Java基础（一）" class="headerlink" title="Java基础（一）"></a>Java基础（一）</h2><h3 id="Java语言的特点："><a href="#Java语言的特点：" class="headerlink" title="Java语言的特点："></a>Java语言的特点：</h3><ul><li>简单易学</li><li>面向对象（封装、继承、多态）</li><li>平台无关性（Java虚拟机实现平台无关性）</li><li>支持多线程</li><li>可靠性</li><li>安全性</li><li>支持网络编程并且很方便</li><li>编译与解释并存</li></ul><h3 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a>什么是字节码？采用字节码的好处是什么？</h3><p>JVM可以理解的代码就是字节码（扩展名.class文件），JVM解释器进行对字节码的解释比较慢、引入了JIT编译器，JIT属于运行时编译，当JIT编译完成第一次编译之后，热点代码和方法的字节码对应机器码会被保存下来，下次可以直接进行使用，而不需要再次被解释器进行解释。</p><p>好处：</p><ul><li>面向虚拟机，不面向任何特定的处理器</li><li>通过字节码的方式，在一定程度上解决了传统解释性语言执行效率低的问题，同时又保留了解释型语言可移植的特点</li><li>字节码不针对某一特定机器，所以Java不需要重新编译就可以在不同的操作系统的计算机运行。</li></ul><h3 id="Java源码一次编写，为啥能到处运行？"><a href="#Java源码一次编写，为啥能到处运行？" class="headerlink" title="Java源码一次编写，为啥能到处运行？"></a>Java源码一次编写，为啥能到处运行？</h3><p>&emsp;JVM（Java虚拟机）是关键原因。</p><p>&emsp;<img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230204194523252.png" alt="image-20230204194523252"></p><blockquote><p>注意：Java程序是跨平台的程序、JVM是C/C++开发的软件，不同平台下的JVM版本不一样</p></blockquote><h3 id="为什么说Java语言“编译与解释并存”？"><a href="#为什么说Java语言“编译与解释并存”？" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h3><blockquote><p><strong>编译型：</strong>编译型语言可以通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较开，开发效率比较低，常见的编译型语言就是C、C++、GO等</p><p><strong>解释型：</strong>通过解释器将代码一句句解释成机器代码，解释型语言开发快，执行速度慢，常见的解释型语言就是PHP、Python、JavaScript等。</p></blockquote><p>&ensp;因为Java要先通过javac编译器将程序编译成字节码(.class文件)，然后通过Java解释器来解释执行。</p><h3 id="一个Java程序可包含多个类吗？（内部类除外）"><a href="#一个Java程序可包含多个类吗？（内部类除外）" class="headerlink" title="一个Java程序可包含多个类吗？（内部类除外）"></a>一个Java程序可包含多个类吗？（内部类除外）</h3><p>&emsp;可以包含多个类，但是被public修饰的类只有一个，且被public修饰的这个类必须跟类文件名同名</p><h3 id="Java的访问权限：private、protected、default、public"><a href="#Java的访问权限：private、protected、default、public" class="headerlink" title="Java的访问权限：private、protected、default、public"></a>Java的访问权限：private、protected、default、public</h3><p>&emsp;private &lt; default &lt; protected &lt; public：从左到右权限依次变大</p><p>&emsp;对成员变量/成员方法而言：</p><p>&emsp;&emsp;1、private：仅限该类内部成员访问</p><p>&emsp;&emsp;2、default：同包下的其他类成员以及该类内部成员可以访问</p><p>&emsp;&emsp;3、protected：同包下的其他类成员、该类内部成员、以及子类可以访问。</p><p>&emsp;&emsp;4、public：任意包下的任意类的成员均可访问。</p><p>&emsp;修饰类时，仅有default、public两种修饰符：</p><p>&emsp;&emsp;1、default：同包下的其他类可以访问</p><p>&emsp;&emsp;2、public：任意包下的任意类可以访问</p><blockquote><p>注：没有任何修饰符修饰，默认为default</p></blockquote><h3 id="Java数据类型"><a href="#Java数据类型" class="headerlink" title="Java数据类型"></a>Java数据类型</h3><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/image-20230204213714958.png" alt="image-20230204213714958"></p><p>byte(1 byte = 8 bits)&emsp;&emsp;&emsp;&emsp;&emsp;short(2 byte = 16 bits)&emsp;&emsp;&emsp;&emsp;&emsp;int(4 byte = 32 bits)&emsp;&emsp;&emsp;&emsp;&emsp;long(8 byte = 64 bits)</p><p>float(4 byte = 32 bits)&emsp;&emsp;&emsp;&emsp;double(8 byte = 64bits)&emsp;&emsp;&emsp;&emsp;&emsp;char(2byte = 16bits)&emsp;&emsp;&emsp;&emsp;&emsp;boolean(根据Java规范规定，不同JVM实现机制不同)</p><h3 id="Java语言关键字"><a href="#Java语言关键字" class="headerlink" title="Java语言关键字"></a>Java语言关键字</h3><table><thead><tr><th>分类</th><th>关键字</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td>类、方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p><ul><li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li><li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li><li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li></ul></blockquote><h3 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h3><p>这个需要结合 JVM 的相关知识，主要原因如下：</p><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol><h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><p><strong>1、调用方式</strong></p><p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p><p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staicMethod</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 调用实例方法</span></span><br><span class="line">        person.method();</span><br><span class="line">        <span class="comment">// 调用静态方法</span></span><br><span class="line">        Person.staicMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、访问类成员是否存在限制</strong></p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p><h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><ul><li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的<strong>局部变量</strong>存放在 Java 虚拟机<strong>栈</strong>中的局部变量表中，基本数据类型的<strong>成员变量（未被 <code>static</code> 修饰 ）</strong>存放在 Java 虚拟机的<strong>堆</strong>中。包装类型属于对象类型，我们知道<strong>几乎所有对象实例都存在于堆中</strong>。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><p><strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</p><p>⚠️ 注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果<strong>没有</strong>被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicTypeVar</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆区、栈区、方法区的区别："><a href="#堆区、栈区、方法区的区别：" class="headerlink" title="堆区、栈区、方法区的区别："></a>堆区、栈区、方法区的区别：</h3><p><strong>堆区:</strong> </p><p>1、存储的全部是对象 ，每个对象都包含一个与之对应的Class的信息。(Class的目的是得到操作指令) </p><p>2、JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 </p><p><strong>栈区:</strong> </p><p>1、每个线程包含一个栈区 ，栈中 只保存基础数据类型的对象和自定义对象的引用(不是对象) ，对象都存放在堆区中 </p><p>2、每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问 。 </p><p>3、栈分为3个部分： 基本类型变量区、执行环境上下文、操作指令区(存放操作指令) 。 </p><p><strong>方法区:</strong> </p><p>1、又叫 静态区 ，跟堆一样， 被所有的线程共享 。方法区 包含所有的Class和static变量 。</p><p>2、方法区中包含的都是在整个程序中永远唯一的元素，如Class，static变量。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java基础（一）&quot;&gt;&lt;a href=&quot;#Java基础（一）&quot; class=&quot;headerlink&quot; title=&quot;Java基础（一）&quot;&gt;&lt;/a&gt;Java基础（一）&lt;/h2&gt;&lt;h3 id=&quot;Java语言的特点：&quot;&gt;&lt;a href=&quot;#Java语言的特点：&quot; cla</summary>
      
    
    
    
    
    <category term="八股文" scheme="http://xiaobazeo.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="Java基础" scheme="http://xiaobazeo.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot开发规范（一）</title>
    <link href="http://xiaobazeo.github.io/2022/11/21/springboot-levelFunction/"/>
    <id>http://xiaobazeo.github.io/2022/11/21/springboot-levelFunction/</id>
    <published>2022-11-21T11:52:29.000Z</published>
    <updated>2023-02-04T15:36:34.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="model（entity）"><a href="#model（entity）" class="headerlink" title="model（entity）"></a>model（entity）</h2><p>​        model是模型的意思，与entity、domain、pojo类似，是存放实体的类，类中定义了多个类属性，并与数据库表的字段保持一致，一张表对应一个model类。 主要用于定义与数据库对象应的属性，提供get/set方法,tostring方法,有参无参构造函数。</p><h2 id="dao（mapper）"><a href="#dao（mapper）" class="headerlink" title="dao（mapper）"></a>dao（mapper）</h2><p>​        又被成为mapper层，叫数据持久层，先设计接口，然后在配置文件中进行配置其实现的关联。 dao层的作用为访问数据库，向数据库发送sql语句，完成数据的增删改查任务。 数据持久化操作就是指，把数据放到持久化的介质中，同时提供增删改查操作，比如数据通过hibernate插入到数据库中</p><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>​        业务逻辑层，完成功能的设计 和dao层一样都是先设计接口，再创建要实现的类，然后在配置文件中进行配置其实现的关联。接下来就可以在service层调用dao层的接口进行业务逻辑应用的处理。 service的impl是把mapper和service进行整合的文件 封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。</p><h2 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h2><p>​        控制层，控制业务逻辑service，控制请求和响应，负责前后端交互 controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/2052481-20210417164128180-1418412203.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;model（entity）&quot;&gt;&lt;a href=&quot;#model（entity）&quot; class=&quot;headerlink&quot; title=&quot;model（entity）&quot;&gt;&lt;/a&gt;model（entity）&lt;/h2&gt;&lt;p&gt;​        model是模型的意思，与enti</summary>
      
    
    
    
    
    <category term="SpringBoot开发规范" scheme="http://xiaobazeo.github.io/tags/SpringBoot%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之2-回文数</title>
    <link href="http://xiaobazeo.github.io/2022/10/27/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B2-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <id>http://xiaobazeo.github.io/2022/10/27/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B2-%E5%9B%9E%E6%96%87%E6%95%B0/</id>
    <published>2022-10-27T08:32:30.000Z</published>
    <updated>2022-10-27T08:33:13.799Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/palindrome-number/description/">9. 回文数</a></p></blockquote><p>[TOC]</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>看到这题的第一想法就是把数字x进行反转得到数字reverse，然后与x进行比较是否相等即可，刚开始我想的是把数字转成字符串然后使用反转函数直接反转，最后使用eqauls方法进行比较即可，但是我忘记了怎么将数字转换成String类型的字符串。后来遍知道一个数一个数字进行翻转</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>由题可知x&lt;0的时候因为含有负号，故所有小于0的数都不是回文数，直接return false即可，x&gt;0的时候，我用一个temp表示x翻转后的数字，num用于x逐一翻转，直到num/10==0的时候说明翻转完成，得到的结果return num == x的结果即可。</p></blockquote><p>但是，看了题解之后我发现其实翻转一半就行了，就算是奇数个位数，最后return reverse/10 == x即可</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p>O(logn)</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p>O(1)</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> x;</span><br><span class="line">            <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">                temp = temp*<span class="number">10</span>+num%<span class="number">10</span>;</span><br><span class="line">                num = num/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x == temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 特殊情况：</span></span><br><span class="line">        <span class="comment">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">revertedNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span></span><br><span class="line">        <span class="keyword">return</span> x == revertedNumber || x == revertedNumber / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：力扣官方题解</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/palindrome-number/solutions/281686/hui-wen-shu-by-leetcode-solution/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/palindrome-number/description/&quot;&gt;9. 回文数&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>力扣刷题之1. 两数之和</title>
    <link href="http://xiaobazeo.github.io/2022/10/26/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://xiaobazeo.github.io/2022/10/26/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B9%8B1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2022-10-26T12:38:24.000Z</published>
    <updated>2022-10-26T12:42:19.486Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和</a></p></blockquote><p>[TOC]</p><h1 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h1><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20221026204201974.png" alt="两数之和"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><blockquote><p>看到这一题我首先想到的就是通过类似于冒泡排序的思想，通过两个for循环对数组里面的值进行一一相加并跟target进行比较，如果值等于target那么就返回，否则就进行下一次循环，也就是所谓的暴力解法，不过这样真的非常损耗时间复杂度</p></blockquote><h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><blockquote><p>这里面要注意的是，同一个数x不能进行重复相加，那么就需要我们进行一一枚举，即在数组nums中寻找中有没有一个数是target - x，且当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。如果找到了这个target - x则返回x和target - x的下标index即可</p></blockquote><p>代码</p><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><ul><li><p>时间复杂度: </p><blockquote><p> $O(N2)$</p></blockquote></li><li><p>空间复杂度: </p><blockquote><p> $O(1)$</p></blockquote></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Problem: &lt;a href=&quot;https://leetcode.cn/problems/two-sum/description/&quot;&gt;1. 两数之和&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;题目如下</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://xiaobazeo.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>最近的成长</title>
    <link href="http://xiaobazeo.github.io/2022/07/10/%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%90%E9%95%BF/"/>
    <id>http://xiaobazeo.github.io/2022/07/10/%E6%9C%80%E8%BF%91%E7%9A%84%E6%88%90%E9%95%BF/</id>
    <published>2022-07-10T08:10:22.000Z</published>
    <updated>2022-08-24T08:11:34.213Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;你好，我是小八，好久不见，不知不觉停更我的<a href="https://xiaobazeo.com/">blog</a>已经将近半年了，不知道的，可能是觉得大二下的我开始颓废了，我可以在这里说NO，你猜错了，我只是最近在闲暇之余花更多的时间在我前面<a href="https://xiaobazeo.com/2022/01/01/2021-backing/">一篇博客</a>提到的项目中——“微布校园”，我们团队开发了一款基于微信生态环境的微信小程序和APP——微布校园，目前也有很多我校大学生在使用我们的产品，而我负责的主要是小程序端开发和Java后端开发，算得上是个前后端啥都干的小菜鸡吧。</p><p>&emsp;&emsp;不知不觉，微布校园的诞生已经半年之久了，用户量也达到了我们的预期估计。在这段参与开发的过程中，通过向几个在大厂工作的学长请教，交流，我发现了很多开发过程中需要注意的小问题，而这些也丰富积累了我的开发经验。比如 刚开始学习使用mina框架开发小程序的我过于小白，其实有些icon只需要写一个class改变其样式即可，而我当时却给每个icon单独写了一个class样式，现在想起来都觉得自己真的好蠢啊，hhhhhhh~</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220710223856616.png" alt="小白受教ing"></p><p>&emsp;&emsp;还有这样的：当时还记得是因为我们开发的时候，提到了tcp协议，而我又看到过一篇博客说http3.0的TCP被弃用了，就开始了这个话题。。。当时还从计网知识转到了计组的相关探讨，hhhhhhh，而且我才知道一个安卓手机小知识，这里也分享给大家：安卓大多数手机用WiFi给电脑传数据，比用数据线快，因为很多手机接口用的USB2.0协议，虽然协议写的是60M，但一般2.0不超过30M</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220710223300695.png" alt="请教计网相关问题"></p><p>&emsp;&emsp;好在我们的不断努力下，微布校园APP和小程序都成功诞生啦~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;你好，我是小八，好久不见，不知不觉停更我的&lt;a href=&quot;https://xiaobazeo.com/&quot;&gt;blog&lt;/a&gt;已经将近半年了，不知道的，可能是觉得大二下的我开始颓废了，我可以在这里说NO，你猜错了，我只是最近在闲暇之余花更多的时间在我前</summary>
      
    
    
    
    
    <category term="程序人生" scheme="http://xiaobazeo.github.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    <category term="回忆" scheme="http://xiaobazeo.github.io/tags/%E5%9B%9E%E5%BF%86/"/>
    
  </entry>
  
  <entry>
    <title>URI</title>
    <link href="http://xiaobazeo.github.io/2022/02/04/URI/"/>
    <id>http://xiaobazeo.github.io/2022/02/04/URI/</id>
    <published>2022-02-04T07:10:36.000Z</published>
    <updated>2022-02-04T07:18:02.632Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时隔一周，我终于抽空又来分享一些知识了<del>承蒙关注，希望各位小伙伴点赞加关注</del></p></blockquote><p>你好，我是小八，一个分享学习知识和经验的在读大学生。</p><p>前几期我们已经讲了 tcp/ip 协议族、IP，TCP，DNS 的作用，我们再来讲讲我们经常上网都会使用到的 URI 和 URL 吧~</p><h2 id="URL-和-URI"><a href="#URL-和-URI" class="headerlink" title="URL 和 URI"></a>URL 和 URI</h2><p><strong>URL</strong>（Uniform Resource Locator）：统一资源定位符。也就是我们口中所称的网址。</p><p><strong>URI</strong>（Uniform Resource Identifier）：URI 用字符串表示某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。</p><p>也就是说 URL 是 URI 的子集。</p><blockquote><p>所以我们下面讲一讲 URI 的格式，也就能理解什么是 URL 了~</p></blockquote><h2 id="URI-格式"><a href="#URI-格式" class="headerlink" title="URI 格式"></a>URI 格式</h2><p>URI 需要涵盖全部必要信息的绝对 URI、绝对 URL 以及相对 URL，这时候大家肯定很疑惑，什么是<strong>相对</strong>，什么是<strong>绝对</strong>？其实很好理解。</p><p><strong>绝对 URL</strong>（比如说一个完整的通信地址，包含国家，省，市，小区门牌号，姓名。） 包含了指向目录或文件的完整信息，包括指向目录或文件的完整信息，包括模式、主机名和路径。</p><p>绝对 url 本身与被引用的文件实际位置无关，无论在哪个主机上的网页中，某一文件的绝对 URL 都是完全一样的。因此，当引用别人服务器上的文件时，应该总是使用绝对 URL。</p><p><strong>相对 URL</strong> 指出的位置是以信息提供者的位置为参照的。（假设 A 的位置标记为在 B 的向左十米，那么这个位置就是相对地址，相对于 B 的位置而言的）相对 URL 以包含 URL 本身的文件位置为参照点，描述目标文件的位置。因此，相对 URL 可以表达像“指向本页面同一目录的那个文件”的意思。</p><p>下面就是绝对 URI 的格式：</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220124170905495.png" alt="绝对URI格式"></p><p>当然上面的协议方案名也不止一种，还有 https、ftp、mailto、file 等 30 种左右</p><p>说了这么多，我再来解释一下上面的各个小模块的意思吧</p><h3 id="登录信息（认证）"><a href="#登录信息（认证）" class="headerlink" title="登录信息（认证）"></a>登录信息（认证）</h3><p>其实就是为了当你在访问服务器资源的时候，通过用户名账号和密码对你的身份信息进行认证。</p><h3 id="服务器地址"><a href="#服务器地址" class="headerlink" title="服务器地址"></a>服务器地址</h3><p>使用绝对 URI 必须指定待访问的服务器地址。</p><ul><li><p>可以是类似 <a href="https://pengzihao166.work/">pengzihao166.work</a> 这种 DNS 可解析的地址</p></li><li><p>也可以是 192.168.1.1 这类 IPv4 地址</p></li><li><p>再或者是类似[0:0:0:0:0:0:0:1]这种 IPv6 地址名</p></li></ul><h3 id="服务器端口号"><a href="#服务器端口号" class="headerlink" title="服务器端口号"></a>服务器端口号</h3><p>此项和登录信息一样是可选项，可以指定服务器连接的网络端口号，如果省略就会自动使用默认的端口号。</p><h3 id="带层次的文件路径"><a href="#带层次的文件路径" class="headerlink" title="带层次的文件路径"></a>带层次的文件路径</h3><p>就和电脑某个文件的<strong>路径</strong>类似，指定服务器上的文件路径来定位特指的资源。</p><h3 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h3><p>对已指定的文件路径内资源，可以使用查询字符串传入任意参数。</p><h3 id="片段标识符"><a href="#片段标识符" class="headerlink" title="片段标识符"></a>片段标识符</h3><p>使用片段标识符通常可<strong>标记</strong>出已获取资源中的子资源（文档内的某个位置）。</p><p><strong>注意</strong>：登录信息、查询字符号、服务器端口号、片段标识符都是可选项~</p><p>好了~今天的知识分享就到此结束了</p><hr><p>你好，我是小八，承蒙厚爱，能不能点赞加个关注呢~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;时隔一周，我终于抽空又来分享一些知识了&lt;del&gt;承蒙关注，希望各位小伙伴点赞加关注&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你好，我是小八，一个分享学习知识和经验的在读大学生。&lt;/p&gt;
&lt;p&gt;前几期我们已经讲了 tcp/ip 协议族、</summary>
      
    
    
    
    
    <category term="计网" scheme="http://xiaobazeo.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>祝臭猪生日快乐！</title>
    <link href="http://xiaobazeo.github.io/2022/01/24/%E7%A5%9D%E8%87%AD%E7%8C%AA%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%EF%BC%81/"/>
    <id>http://xiaobazeo.github.io/2022/01/24/%E7%A5%9D%E8%87%AD%E7%8C%AA%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%EF%BC%81/</id>
    <published>2022-01-23T16:00:00.000Z</published>
    <updated>2023-03-19T04:27:00.082Z</updated>
    
    <content type="html"><![CDATA[<p>To 可爱迷人美丽的猪：        </p><p>&emsp;&emsp;恭喜啊，猪~</p><p>&emsp;&emsp;今天你成功奔三啦！</p><p>&emsp;&emsp;还记得我们在一起的时候是2020.3.12号，今天是我们在一起的第318天，第10个月12天，第45周3天，这也是我陪你过的第一个生日，很遗憾这次生日我不在你身边，但是我觉得，我人不在，情还是在的。</p><p>&emsp;&emsp;还记得这张是我们在官宣的前一天拍的~</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/img/image-20220123184150890.png" alt="image-20220123184150890"></p><p>&emsp;&emsp;对吧，嘻嘻嘻~</p><p>&emsp;&emsp;给你送的生日礼物昨天就到了，原本以为会隔一天到，没想到啊，终究还是草率了，提前了一天，礼物不贵，就上某书上面找了挺久的参考，还看了好多的评论，反正是从几十个款式里面挑出来的，也不知道你喜不喜欢~我可是花了<strong>一整天</strong>去挑选一个礼物，你多少都要喜欢一丢丢！！！</p><p>&emsp;&emsp;想想时间过得好快啊~ </p><p>&emsp;&emsp;好了好了，还是不说些回想过去的话了，免得搞得太伤感了，我也不长篇大论了。</p><blockquote><p>画个重点：</p><p>就希望未来的你，越来越优秀，越来越漂亮，成为你想成为的人，咱做好自己就行了，没必要管别人的三言两语，立足当下，一步一步脚踏实地向未来进发，给我冲冲冲！</p></blockquote><p>&emsp;&emsp;反正呢，<strong>朕</strong>今天放你一天假，开开心心快快乐乐过一个 20 岁的生日(虽然你永远3岁)，和你的好朋友们、亲人一起玩耍吧，hhhhhhhh，一定要记得注意安全~</p><p>&emsp;&emsp;晚安~</p><p>&emsp;&emsp; 我要去恶补前几天漏掉了的学习进度了，祝你今天玩的开心奥~</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;——小八</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;To 可爱迷人美丽的猪：        &lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;恭喜啊，猪~&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;今天你成功奔三啦！&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;还记得我们在一起的时候是2020.3.12号，今天是我们在一起的第318天，第10个</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>TCP、IP、DNS</title>
    <link href="http://xiaobazeo.github.io/2022/01/16/TCP%E3%80%81IP%E3%80%81DNS/"/>
    <id>http://xiaobazeo.github.io/2022/01/16/TCP%E3%80%81IP%E3%80%81DNS/</id>
    <published>2022-01-16T15:08:08.000Z</published>
    <updated>2022-01-16T15:09:57.141Z</updated>
    
    <content type="html"><![CDATA[<p>你好，我是小八，最近在备考，考试总算是结束了，终于可以放假，学习更多的技术了<del>干自己想干的事情了</del></p><p>下面分享一些 IP、TCP、DNS 的基础知识点，大家可以看看，绝对通俗易懂！！！</p><h1 id="与-HTTP-关系密切的协议：IP、TCP-和-DNS"><a href="#与-HTTP-关系密切的协议：IP、TCP-和-DNS" class="headerlink" title="与 HTTP 关系密切的协议：IP、TCP 和 DNS"></a>与 HTTP 关系密切的协议：IP、TCP 和 DNS</h1><h4 id="负责传输的-IP-协议："><a href="#负责传输的-IP-协议：" class="headerlink" title="负责传输的 IP 协议："></a>负责传输的 IP 协议：</h4><p>&emsp;&emsp;按层次分，IP（Internet Protocol）网际协议属于网络层。<strong>IP 地址</strong>和<strong>IP</strong>不同，“IP”其实就是一种协议的名称，即：网际协议。</p><p>&emsp;&emsp;IP 协议作用：把各种<strong>数据包</strong>传送给对方，但是必须满足<strong>IP 地址</strong>和<strong>MAC 地址</strong>（Media Access Control Address）两个条件才能确实送到对方那里。</p><p>&emsp;&emsp;<strong>IP 地址</strong>：节点被分配到的地址，</p><p>&emsp;&emsp;<strong>MAC 地址</strong>：网卡所属的固定地址。</p><p>&emsp;&emsp;<strong>注意：</strong> IP 地址可以变换，MAC 地址基本不变。</p><p>&emsp;&emsp;IP 通信依赖 MAC 地址, 因为不同计算机之间通信时，通常是不在一个局域网(LAN)下，此时就需要多个中间计算机和设备（路由器等均可作为中转设备）进行中转，最后连接到你所需要连接的计算机，在中转的过程中，会利用到下一个中转设备的 MAC 地址来寻找到下一个中转目标。这下就要用到了<strong>ARP 协议</strong>(Address Resolution Protocol).</p><p>&emsp;&emsp;<strong>ARP 协议：</strong> 一种解析地址的协议，根据对方的 IP 地址可以反查出对应的 MAC 地址。</p><p>&emsp;&emsp;如果还是不懂的话，就拿快递公司的收发货方式来打一个比方吧，我们要是双十一买了东西（“东西”就是我们在网络上要传递给某个设备的信息），卖家需要把东西寄给我们（”我们“就是接收信息的设备），那么他们就会把自己的货物送到某快递的集散中心，然后集散中心通过核对收件人地址，来确定送到下一个集散中心（这里的“集散中心”就是类似于一个中转设备），最后到达离收件地址最近的集散中心之后，再送到我们手上（这时候就实现了发起设备和接收设备的信息传递）。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/IP%E3%80%81TCP%E5%92%8CDNS/ARP%E5%8D%8F%E8%AE%AE.png?versionId=CAEQGRiBgID_98q58hciIGU2NDAxY2JlNmQ5MzQ2YjViYzQyZTgyZTQ3NmI0ZDY1" alt="img"></p><h4 id="确保可靠性的-TCP-协议"><a href="#确保可靠性的-TCP-协议" class="headerlink" title="确保可靠性的 TCP 协议"></a>确保可靠性的 TCP 协议</h4><p>&emsp;&emsp;TCP 和 UDP 都位于传输层，这个前面说过，其中 TCP 是用来提供可靠的字节流服务。</p><p>&emsp;&emsp;其中 TCP 协议能够准确确定数据是否送达目标处，这样的实现的过程就是通过三次握手（three-way handshaking）策略，其中握手过程中使用了 TCP 的标志（flag）——ACK 和 SYN，原理如下：</p><p>&emsp;&emsp;第一次由发起端首先发送一个 SYN 标志的数据包给接收端，第二次握手就是在接收端接收这个标志之后，接收端再反馈一个 SYN 和 ACK 的数据包给发起端，来表达自己已经接收到了发起端的请求，最后一次握手就是在收到接收端的确认信息之后，发起端回传一个 ACK 的数据包给接收端，代表“握手”结束。</p><p>&emsp;&emsp;如果其中有某一次握手中断，那就会延续上一次握手进行重复的请求，但要是请求超时之后就会重新开始由发送端进行第一次握手。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/IP%E3%80%81TCP%E5%92%8CDNS/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png?versionId=CAEQGRiBgMDa98q58hciIGZjNTZlZWU4OWI1MzRjYjdhMDIyMzEzYWYyNWNiMGE2" alt="image-20211230200934379"></p><h4 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h4><p>就是当你在访问某个网站的时候，会有一个网址(比如：<code>www.baidu.com</code>也就是此网站的域名)，而在访问某个计算机的时候也可以通过赋予此计算机一个域名，最后通过 DNS 解析域名来获取其 IP 地址，最后访问到此计算机。</p><p>DNS 的作用便是通过域名查找对应的设备的 IP 地址，或者逆向从 IP 地址查域名的服务。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/IP%E3%80%81TCP%E5%92%8CDNS/DNS.png?versionId=CAEQGRiBgMDIlN658hciIGI1YTcxNDhjZjNlMjQxNTdiMTA1OTVkYjJjZjE5ODg5" alt="image-20211230202446976"></p><hr><p>你好，我是小八，一个分享学习经历和知识的在读大学生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你好，我是小八，最近在备考，考试总算是结束了，终于可以放假，学习更多的技术了&lt;del&gt;干自己想干的事情了&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;下面分享一些 IP、TCP、DNS 的基础知识点，大家可以看看，绝对通俗易懂！！！&lt;/p&gt;
&lt;h1 id=&quot;与-HTTP-关系密切的协议：IP</summary>
      
    
    
    
    
    <category term="计网" scheme="http://xiaobazeo.github.io/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>终于熬过来了！！！</title>
    <link href="http://xiaobazeo.github.io/2022/01/06/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/"/>
    <id>http://xiaobazeo.github.io/2022/01/06/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/</id>
    <published>2022-01-06T04:55:10.000Z</published>
    <updated>2022-01-06T10:31:37.161Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是小八，好久不见啊，我今天终于熬完了课设和汇编备考。</p><p>现在来分享一下我的<strong>战斗经历</strong></p><p>我们课设的小组成员由 5 个人组成：周**、小八、赵.**、陈**、曹**</p><p>因为复习汇编的时间和课设的时间挤在了一起，导致我们寝室小组最近都经常肝到凌晨两三点，<strong>划重点：不建议学弟学妹们这么做！！！</strong> 属实很累。</p><p>经过是这样的，我们小组确定的课设题目是 <strong>校园助手</strong> 。</p><p>既然是校园助手，肯定得有查成绩、查课表、查地图、聊天、修改个人信息等功能，这样的话，因为我最近在学习前端，组长也在学习服务器开发，于是我们小组就一拍即合，做一个前后端分离的 demo，并且得有一个像校园助手的样子，自然就不能继续用控制台，用黑框框来展示我们的成果了，果断选择 QT 平台。</p><p>毕竟要做，就要做一个牛逼的东西！！！先给你们看看登录界面的展示效果吧。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/mainwindow1.png?versionId=CAEQGRiBgID80f.28RciIGE4OWU3ZDI1OGJmNzRiNGM4ZjQ4ZjEwYzgzZGYyYWRj"></p><p>下面的是我们客户端的图标，有没有想到湖工大考试平台的图标呢？？</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/myico.png?versionId=CAEQGRiBgIC7.ZS48RciIGZlZDVhM2MxYzE4NTRkNzliYjk2MjE5MjJlOTlhNTZm"></p><p>这个界面看似简单，但实际上，后面很多的功能实现、界面跳转、跟服务器的数据请求以及初始化数据都是在这个界面的代码块进行实现，简简单单看看代码就知道了，这个 demo 好歹也是做了大半个月呢。</p><p>截图如下：</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/code.png?versionId=CAEQGRiBgMDPis.38RciIDhkMjgyM2UyMGQwMDQ1MWE5ZDA1NzZlMDhmMzBkMjBl"></p><h2 id="最大瓶颈出现"><a href="#最大瓶颈出现" class="headerlink" title="最大瓶颈出现"></a>最大瓶颈出现</h2><p>而这也仅仅是主界面的一个很小的功能模块的代码块罢了，我还记得当时我们遇到的最大的一个瓶颈就是，实现两台不同设备之间的向服务器端发送请求，并且记录对方 IP，通过服务器作为中转站交互信息。我们小组一直在接触服务器开发的也就是我们的组长——周**，而我也最近才只是刚刚入门计网，我和他也只能仅仅讨论一下，解决的想法。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>遇到这个问题的时候，我和组长刚开始毫无思路，我就在一个在字节、腾讯、快手等大佬汇集的群里问一问经验和解决方案。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/chat1.png?versionId=CAEQGRiBgIDF1f238RciIGRhYWEyMTc2MmZkNDQ3MDU4ZDQ0MjY1NWZkMTA1YTg5"></p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/chat2.png?versionId=CAEQGRiBgMDH1f238RciIDgwODZlMWU3NmRiMzRhY2NiZTAyNzM1ZGFkMzk1NWIx"></p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/chat3.png?versionId=CAEQGRiBgMDN1f238RciIDM1M2RkNWNlZWNhZjQ5YjJiMWMwNjE5YWEyMzc2Yjll"></p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/chat4.png?versionId=CAEQGRiBgMDZ1f238RciIDVmMGZkNmMyZWU4YjQwZWU5NmZkYzg0ZTdiNDYzMjBi"></p><p>当时毕竟很晚了他们应该已经睡觉了，没有人回我，后来才回复了我。</p><p>过了一会，我和组长突然想到了一个办法，那就是通过每个人的固定学号绑定到每个用户的 IP，并固定 IP，就是说等我们连接到服务器之后，再分别在 cmd 里面 ipconfig /all 一下两台设备的 IP，最后改一下服务器端的代码块里面的 IP 地址，岂不是走了一波小捷径？毕竟不知道怎么获取 IP 地址，并实时更新对应用户的 IP，因为 IP 一直是会更新的，一般随着路由的分配形成一个局域网，重连一次网络 DHCP 就会重新分配一次新的 IP，而且咱也实力有限,能想到这个想法，个人觉得已经很不错了。</p><p>这虽然说是服务器端的任务，前端只需要直接从服务器获取数据就行了，但这样我对计网也有了更加深层次的了解，知道怎么在实际需求中，进行构思解决方案，并且我还发现，后端要跟着前端的需求走，前端需要什么，后端就得实时进行更新并处理数据，所以感觉后端好惨。</p><blockquote><p><strong>划重点</strong>：以后还是要转后端学习的我，先让组长替我受受苦吧，hhhhhhhh。</p></blockquote><p>当然当时这个 demo 的问题还有很多，比如，修改个人信息栏如何实现<strong>换行</strong>，而不是在一行里面显示，导致显示溢出的问题，当时不知道怎么解决，我就写了一个判断语句，来控制那个信息栏输入字符长度，让个人信息就显示在一行，但不会溢出，就类似于 QQ 个性签名文字个数限制一样。</p><h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><p>刚刚介绍的只是我们前后端交互当时遇到的一个最大的问题，而我们前端，当时有很多功能，比如：登录，注册，修改密码，显示课程表，班级成员成绩等，都需要从后端获取相应的数据之后，在前端进行逻辑实现，并反馈给服务器。</p><p>比如：你在登录的时候，需要输入账号密码之后，将用户数据发送到服务器进行用户信息的遍历，找到是否有匹配的用户，如果没有，那么服务器就会反馈 NO 的信息给前端，自然也就登录不进去，如果有，那么反馈给前端一个 YES，则就能登入客户端，进行查看课表、查成绩等功能。</p><p>登录失败前端反馈如下图：</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/logNO.png?versionId=CAEQGRiBgMCW9MO48RciIDdmYjJkYzU4YTZlNjQ1YmU5ZDA5OGEwM2M1NjRjN2Jm"></p><p>登录成功便进入此界面：</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/logYES.png?versionId=CAEQGRiBgMCX9MO48RciIDJlN2VmOGNjOWJkYjQ4YjU4MGI3MjA3Y2E3ZTM3NGJl"></p><p>服务器这边的反馈信息如下：</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/c-%E8%AF%BE%E8%AE%BE%E5%92%8C%E6%B1%87%E7%BC%96/houduan.png?versionId=CAEQGRiBgIC368q48RciIDQzOThjZDE3OTNiMDRkNGNhZWI0NjdjOTIwYzc2MTlk"></p><p>有一说一，看到这个后端是不是觉得很牛逼，我也确实佩服我的组长，一个人能完成所有的前端发来的数据处理，在下属实佩服，不知道你们怎么觉得，反正我还很菜，目前还做不出来一个服务器。</p><p>当然还有其他的功能，我就不一一展示了，比如：注册、修改个人信息、忘记密码、展示工大地图、查询成绩等。都是其他小组成员分别负责的几个小模块。</p><p>这里科普一下：只要服务器一开，我们打开客户端的时候，对服务器就会<strong>三次握手</strong>发送连接请求（有兴趣的小伙伴可以去了解一下）。</p><h2 id="答辩过程"><a href="#答辩过程" class="headerlink" title="答辩过程"></a>答辩过程</h2><p>昨天上午我们找到老师进行了答辩，而且我们小组因为敢于尝试 QT 平台和实现了前后端分离，小组成绩获得了所有小组中的最高分</p><p>还记得当时有挺多人来围观我们的课设，小组成员在答辩的时候附近声音属实嘈杂。</p><p>当组长答辩完他写的服务器之后，便到我进行对自己的功能模块的答辩了，首先我对老师介绍了我的功能模块，能够实现什么？能够干些什么？</p><p>我的解答就是，我的负责的模块可以分为三大块：</p><h4 id="1、窗口（mainwidow）、对话框（dialog）、按钮（button）之间的跳转-（QT-自带的信号，槽函数进行实现）"><a href="#1、窗口（mainwidow）、对话框（dialog）、按钮（button）之间的跳转-（QT-自带的信号，槽函数进行实现）" class="headerlink" title="1、窗口（mainwidow）、对话框（dialog）、按钮（button）之间的跳转 （QT 自带的信号，槽函数进行实现）"></a>1、窗口（mainwidow）、对话框（dialog）、按钮（button）之间的跳转 （QT 自带的信号，槽函数进行实现）</h4><p>比如这一块就是通过信号和槽来实现对数据传递，并跳转出成绩查询窗口。</p><p>代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow1::<span class="built_in">on_serch_clicked</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">connect</span>(dialog1, SIGNAL(sendNum(QString)), this, <span class="built_in">SLOT</span>(getNum(QString)));</span><br><span class="line">    <span class="comment">//查询成绩</span></span><br><span class="line">    dialog1-&gt;<span class="built_in">setModal</span>(true);</span><br><span class="line">    dialog1-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、在主窗口对服务器发送数据，接收服务器数据"><a href="#2、在主窗口对服务器发送数据，接收服务器数据" class="headerlink" title="2、在主窗口对服务器发送数据，接收服务器数据"></a>2、在主窗口对服务器发送数据，接收服务器数据</h4><p>比如下面的代码就是登录之后，将登录用户数据发送给服务器。</p><p>代码如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">this</span>-&gt;</span><span class="function"><span class="title">clint_Login</span>-&gt;</span>write(user_msg);</span><br></pre></td></tr></table></figure><h4 id="3、登录功能、课表的查询展示"><a href="#3、登录功能、课表的查询展示" class="headerlink" title="3、登录功能、课表的查询展示"></a>3、登录功能、课表的查询展示</h4><p>介绍完之后，老师问了我一个问题，下面的代码是什么意思：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QJsonDocument <span class="attr">doc</span> <span class="operator">=</span> QJsonDocument::fromJson(UserInfo, <span class="variable">&amp;json_error</span>)<span class="punctuation">;</span></span><br></pre></td></tr></table></figure><p>我的回答无疑就是解释它的是怎么用的，通过定义一个QJsonDocument的 doc 对象，把 userinfo 里面的信息进行解析出来获取数据放到 doc 中。</p><p>毕竟当时是一边学 QT 一边做的，并不是很了解深层原理，也就只好这么回答了。但老师好像就是要我剖析它的深层原理，对我的答案，并不是很满意，只怪自己当初并没有花更多的时间去研究 QT 吧。</p><p>再就是问了一下我的课表是怎么实现的，实现代码在哪？</p><p>我的回答就是，其实真的很简单，就是一个插图的办法实现的，通过 new 一个课表类的对象 Class_Schedule 初始化课表，再进行窗口模糊 setModal 和窗口展示 show 进行实现。</p><p>跳转代码段如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">void</span> <span class="variable">MainWindow1</span>::<span class="function"><span class="title">on_scotmtb_clicked</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">Class_Schedule</span>-&gt;<span class="function"><span class="title">setModal</span>(<span class="variable"><span class="literal">true</span></span>);</span></span><br><span class="line"><span class="function">    <span class="variable">Class_Schedule</span>-&gt;<span class="title">show</span>();</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>不过这有很大<strong>局限性</strong>：因为只能查到自己班的课表。嘻嘻嘻~</p><p>我的课设答辩差不多就这样结束了。</p><p>不过当时有一个学生在那里跟我们的课设指指点点，我当时就在想：能不能尊重一下我？是我在答辩，不是你！你当你能像毛主席一样指点江山？</p><p>希望关注我的小伙伴们以后不会遇到这种人。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>说了这么多，总结以下几点：</p><p>1、前后端分离，能改善修改代码的效率，不会因为一个小 bug，去修改一整片的代码，从而提高了功能更新的效率。</p><p>2、少熬夜，熬夜伤身。（在这里再立一个 flag，2022 年不仅要好好学习技术，还得少熬夜，跟以前一样 11 点之前就睡觉，没事多锻炼一下身体。）</p><p>3、bug 常常有，有时候一个 bug 一天都修复不了很正常，慢慢去想就行了，不要急躁，切记，敲代码务必要戒骄戒躁。</p><p>4、不知道某个瓶颈怎么解决，可以换一种思路或者方式去解决这个问题，多和同学讨论，或者像大佬请教，上百度找教程等等。<strong>（忌:ctrl c + ctrl v）</strong></p><p>5、最近计网的知识，能够在实际应用中想到相应的解决方案，并跟组员一同分享。</p><p>6、不足就是，组员中除了我都不会用 Git，不然能更高效率实现各功能模块代码的合并，减少很多不必要的麻烦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家好，我是小八，好久不见啊，我今天终于熬完了课设和汇编备考。&lt;/p&gt;
&lt;p&gt;现在来分享一下我的&lt;strong&gt;战斗经历&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们课设的小组成员由 5 个人组成：周**、小八、赵.**、陈**、曹**&lt;/p&gt;
&lt;p&gt;因为复习汇编的时间和课设的时间</summary>
      
    
    
    
    
    <category term="程序人生" scheme="http://xiaobazeo.github.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>2021 backing</title>
    <link href="http://xiaobazeo.github.io/2022/01/01/2021-backing/"/>
    <id>http://xiaobazeo.github.io/2022/01/01/2021-backing/</id>
    <published>2022-01-01T15:44:02.000Z</published>
    <updated>2022-01-06T10:32:35.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回首2021"><a href="#回首2021" class="headerlink" title="回首2021"></a>回首2021</h2><p>大家好，我是小八，是一名HUT的大二在校本科生，今天写一篇博客来说说2021我的成长之旅吧。</p><h3 id="2021年上半年（大一下学期）"><a href="#2021年上半年（大一下学期）" class="headerlink" title="2021年上半年（大一下学期）"></a>2021年上半年（大一下学期）</h3><h4 id="2021-1-1"><a href="#2021-1-1" class="headerlink" title="2021.1.1"></a>2021.1.1</h4><p>大病初愈的我，和我好兄弟们跨过了第二个大学元旦，也抓到了2021年的第一个娃娃，而这也是我新的一年的开始，那时候的我也才大一下学期，对未来也只是仅仅抱着幻想，但仍然十分的迷茫和无奈。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/20210101.jpg?versionId=CAEQGRiBgMDPtKvZ8BciIDhiZWMwZDEyYTRjODRjMjk5YTc3NTcxZWJkY2FiMmQy" alt="20210101"></p><h4 id="2021-1-1—2021-3-13"><a href="#2021-1-1—2021-3-13" class="headerlink" title="2021.1.1—2021.3.13"></a>2021.1.1—2021.3.13</h4><p>这段时间，没错正如我所说的，非常迷茫、无知，天天除了打游戏，打篮球，和好兄弟们一起在外面狂嗨等，也没啥事干，可以说是天天无所事事，天天在学校混世度日，虽然我的综合成绩排名在年级也混得过去，不算很差（年级几十名吧），但真的算不上优秀。</p><p>可是当时的我真的不知道去干嘛，但应该去做一些什么有意义的事情。</p><h4 id="2021-3-14"><a href="#2021-3-14" class="headerlink" title="2021.3.14"></a>2021.3.14</h4><p>我遇到了我生命中除了亲朋好友之外最喜欢的人——那个她，在这一天，我们官宣了，实际上我们当时2021.3.12号就在一起了，我在那之后的每一周周末都会去陪着我喜欢的人，一起开心的玩耍，当时我以为，这样的我，算是走出了一点点的迷茫大学生涯，其实我还是一个迷茫的憨批。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/20210314.jpg?versionId=CAEQGRiBgMDZtKvZ8BciIGUxODM4YTRiMThlMjQwNWE5MTUwMDA3OTRjOWNjMzJh" alt="20210314"></p><h4 id="2021-3-27"><a href="#2021-3-27" class="headerlink" title="2021.3.27"></a>2021.3.27</h4><p>这一天，我真的可以说是上天给我了一个莫名的惊喜，我肯定要好好把握住这一个很好的机会，毕竟我当时也意识到了自己的迷茫，而这也算是人生中的一次转折点吧，很高兴遇到了这个学长，有一说一，我和他的大学经历，真的很像，因为他给的这个机会，我真的有了很大的改变，也就有了后面很大的学习动力和进步，但是这也需要付出一定的代价。那时候，我也便开始了我的java学习之旅。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/202103271.png?versionId=CAEQGRiBgICktKvZ8BciIDhjNTdhNzFhNDIxNzQzMmFiZGY1YTU2NjE2MzAwOWRm" alt="20210327 1"></p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/202103272.png?versionId=CAEQGRiBgICdtKvZ8BciIDMzNjVlZjI2MDA4ODRhNjNiODc4MjQ3ODRmNzk1MWIy" alt="20210327 2"></p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/202103273.png?versionId=CAEQGRiBgMCntKvZ8BciIDcwYmE5MTc5Yjk2NjQ2YzA4M2Q0YTM1MGIxZTU5ZDk3" alt="20210327 3"></p><p>可是好景不长，果然我要付出的代价来了，我和我的好兄弟，也因为这个，渐渐减少了和他们一起聚会，一起快乐，一起玩耍，一起做我们大学生想做的事情，想想真的挺烦的，但是也没有办法，说点自私的，我也是在为自己的未来奋斗，毕竟我实力有限，我也只能独自前行，不能带着他们一起进步。</p><p>虽说后悔，但是我也无法后退，既然踏出了那一步，我只能看好当下，而不是留在过去，只想着能够在自己变优秀之后，慢慢再带着他们一起变优秀，一起在大学留下属于自己的足迹。</p><h4 id="2021-6月"><a href="#2021-6月" class="headerlink" title="2021.6月"></a>2021.6月</h4><p>我们学院为了迎接新生，辅导员需要在19级和20级学生里面选一部分同学当大小班助，为21级新生的到来提供我们力所能及的帮助，并为他们解决进入大学之后的迷茫，无知。可是在我看来，其实当时的我，也顶多只是比21级新生多了一点点“如何在大学生存下去”的生活常识？</p><p>但是我想着这也是一次锻炼自己的机会，我当然不想放弃，果断下定决心，参加这一次的选拔，记得当时报名的人有一百来个吧，我也不知道能不能选上，单纯就抱着一个尝试的心理去面试了，没想到当时真的通过了老师和各个主席的认同，当上了2107班的小班助。</p><p>在得到这次机会之后，也是临近放假的时候，当时就在想，当上了小班助可得懂得更多一点，那这暑假更不能闲着了，得好好学学还没有学完的java了，到时候可不能比大部分新生差啊。</p><p><img src="https://pengzihao166.oss-cn-beijing.aliyuncs.com/blog/2021backing/20216.jpg?versionId=CAEQGRiBgICptKvZ8BciIDhjZjdhYzU4NmJlODQ0MGRhM2UzY2M1ZTNiMmE1YzQ1" alt="20216"></p><h3 id="2021下半年（大二上学期）"><a href="#2021下半年（大二上学期）" class="headerlink" title="2021下半年（大二上学期）"></a>2021下半年（大二上学期）</h3><h4 id="2021-7-10月"><a href="#2021-7-10月" class="headerlink" title="2021.7-10月"></a>2021.7-10月</h4><p>这是我和她吵架高峰期，因为学习和班助工作，真的少了很多时间对她的陪伴，这段时间，我尽量不把自己的心情影响到身边人，不想因为周围的人被我的心情影响到，我只能努力忍着自己随时可能爆发的情绪，每天照常如故对待身边的人，先把自己感情的事情放在一边，做好自己身为班助应该做的工作。</p><p>可以说，我算得上是一个合格的班助吧，但算不上一个合格的男朋友，那段时间居然还有人在外面传言说我分手了，真的听到了我都笑了，对这些人挺够无语的。</p><p>迎新工作开始，而我也陷入了学习java和迎新的工作之中，在迎新的过程中，当时还立了好几个flag，要学好java其他相关的技术，比如：MySQL、ssm框架、spring boot、spring cloud等等。</p><p>当时的我真的觉得，自己会在暑假干好上面的flag，但事与愿违，自制力还是不够，仅仅只是学完了java基础部分和很浅的了解了一下java的ssm框架，终究还是败给了懒惰。</p><p>大二正式开学之后，因为有了新的课程学习，自然没有暑假那么多时间学习java更多的知识了，而且当上了小班助，为了防止他们军训时发生什么事故，请了很多节课假，选择陪他们一起军训，java的学习进度也就减慢了很多。</p><p>到了十月份，我基本放下了班助的工作，那时候，我不知道为什么，再次陷入了学习的迷茫之中，那段时间，我感觉我学了java，但是毫无用处，对java的框架学习也比较反感，那时候我还想着要不要转iOS开发呢？</p><p>带着这个疑惑，突然想起了那个学长，便去咨询了他，我在这种迷茫的时候，到底应该怎么办，我该怎么做？后来在和他的聊天过程中发现，不是我对java彻底失去兴趣，也不是我不适合学习java，只是暂时的失去了对它的兴趣，这算是一种叫做“递减效应”的心理效应吧。他当时推荐我去学学前端，写写网页后面再去转向后端，用前端来做一个跳板，像后端再去慢慢转换。</p><p>在他的建议下，我很快入手了前端，毕竟web前端的核心js的学习，其实跟java十分相似，自然上手就很快。</p><h4 id="2021-11"><a href="#2021-11" class="headerlink" title="2021.11"></a>2021.11</h4><p>这一个月怎么说呢，有快乐也有伤心吧，快乐就是我得到了学长的认可，有不开心的事情，也可以跟学长分享，并且他能在闲暇的时候帮我解决，伤心的是我失去了很多，少了很多时间给她，少了和兄弟们当初的快乐。陪她的时间越来越少，我们之间的争吵也越来越多，可是我当初也是想着做这个项目，能够好好带着她一起去她想去的城市，也算是为未来打拼奋斗，虽然以后我可能不是一个Winner，但我不想做一个未来的Loser。</p><h5 id="2021-11-24-9-34"><a href="#2021-11-24-9-34" class="headerlink" title="2021.11.24 9:34"></a>2021.11.24 9:34</h5><p>那个学长给我发了一条微信，询问我是否愿意来一起和他一起做项目，我当时收到这条消息，真的乐开了花，多的不说，机会是自己把握的，当机立断就答应了，毕竟我觉得，不管最终结果如何，我相信我一定能学到很多东西，学到在学校学不到的东西，慢慢摆脱在大学的迷茫和无知。</p><h4 id="2021-12"><a href="#2021-12" class="headerlink" title="2021.12"></a>2021.12</h4><p>我在学长的学习路线下，慢慢学会了怎样使用Git、HEXO、Node.js、前端等等开发技术，在慢慢学习了计网、计组等基础知识。</p><p>我还记得，我当时为了学习，经常熬夜到晚上一两点，前面的好几篇blog，也是在那段时间写出来的。有兴趣的可以去看看“<a href="https://pengzihao166.work/2021/11/28/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">小八学习git从0到基本运用</a>”，“<a href="https://pengzihao166.work/2021/11/29/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Git%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">自学如何使用Git+Hexo搭建个人博客</a>”。</p><p>真的很喜欢一句话，<strong>“没有人会因为你熬到两三点就心疼你，也没有人会在乎你在熬什么，你只需要知道你自己在奋斗”</strong>。</p><p>这个月我也便在学习新知识和期末备考中度过了，过得算不上很“大学生”。而我的一年差不多也就这么过去了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说了这么多，有了很多的失去，也有很多的收获，多的不说，送给大家一句话，<strong>看好当下，跳向未来吧</strong>。做好自己2022立下的flag，加油加油，冲冲冲，也希望我身边的人能够快快乐乐，成为自己想成为的人！！！</p><p>你好，这里是小八，一个专门分享学习经验和经历的菜鸟。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;回首2021&quot;&gt;&lt;a href=&quot;#回首2021&quot; class=&quot;headerlink&quot; title=&quot;回首2021&quot;&gt;&lt;/a&gt;回首2021&lt;/h2&gt;&lt;p&gt;大家好，我是小八，是一名HUT的大二在校本科生，今天写一篇博客来说说2021我的成长之旅吧。&lt;/p&gt;
&lt;h3</summary>
      
    
    
    
    
    <category term="程序人生" scheme="http://xiaobazeo.github.io/tags/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
</feed>
